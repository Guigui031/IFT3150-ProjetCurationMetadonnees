key	project	title	abstract	keywords	authors	venue	doi	references	pages	bibtex	screened_decision	final_decision	mode	inclusion_criteria	exclusion_criteria	reviewer_count	source	year	meta_title	link	publisher	metadata_missing
0	Behave	On the understanding of BDD scenarios’ quality: Preliminary practitioners’ opinions	[Context & Motivation] In agile development, acceptance tests are written to express the details from the conversations between customers and developers. One of the formats to express those details is BDD (Behavior-Driven Development) scenarios, which use a ubiquitous language, one that business and technical people can understand, to build an executable specification that represents a system behavior. [Question/Problem] Problems caused by bad documentation are known to cause project failure and we believe those problems apply to documentation in the format of acceptance tests as well. Thus, in the long-term, we seek to understand what would be the definition of a good BDD scenario and the criteria to define it. [Principal idea/results] To achieve that, we previously identified known requirements’ quality attributes that would be suitable to evaluate BDD scenarios’ quality. Based on that list of attributes, we now aim to validate that list with practitioners, identify their interpretation of the listed attributes, and uncover general recommendations to write BDD scenarios. [Contribution] Preliminary results from our initial set of interviews revealed practitioners’ interpretations for consistent, testable, valuable, understandable, and unambiguous attributes and some recommendations to write good BDD scenarios, such as the use of declarative form of writing. © Springer International Publishing AG, part of Springer Nature 2018.		Oliveira G., Marczak S.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)					Excluded	Excluded	new_screen			2						
1	Behave	Testing schematron using XSpec	[No abstract available]		[No author name available]	Balisage Series on Markup Technologies					Excluded	Excluded	new_screen			2						
2	Behave	Enhancing the Student Learning Experience by Adopting TDD and BDD in Course Projects	A demonstration of the application and contribution of Test-Driven Development (TDD) and Behavior-Driven Development (BDD) in the student learning experience in the context of a Software Engineering course. Background: Software testing is an activity for ensuring software quality. Although teaching testing rigorously to students is a priority in academia, undergraduate students often encounter difficulties performing testing tasks effectively. Intended Outcomes: To increase satisfaction rate and course grades, and reduce delivery time. Application Design: We experimented with the Software Engineering Laboratory (LES) course of a Private University in the Bachelor of Computer Science and Information Systems courses. This experiment corroborated the learning difficulties of students. Collected data were assessed both quantitatively and qualitatively. Findings: Backed up with statistical tests, the results showed a reduction in student absences, higher student satisfaction rate, and higher grades in the courses. Furthermore, our approach allowed students to deliver a product in a short period, representing a possibility of adoption of BDD due to their successful learning experience. Finally, we aim to foster a discussion of appropriate teaching methods of software testing.	Software Testing;Student Learning Experience;Software Engineering Education;course Project;Agile Software Development	F. G. Rocha; L. S. Souza; T. S. Silva; G. Rodríguez	2021 IEEE Global Engineering Education Conference (EDUCON)					Included	Included	new_screen			2						
3	Behave	How to Evaluate BDD Scenarios' Quality?	A scenario from the Behavior-driven development (BDD) practice is a known format to represent acceptance tests in agile methodologies, communicating assumptions and expectations by expressing the details that result from the conversations between customers and developers. We believe that this formalization of behavior need to be of good quality to avoid known requirement problems that arise from bad documentation, such as incomplete, underspecified and inconsistent requirements. However, there are only informal guidelines to guide practitioners on their BDD scenarios' elaboration and quality evaluations. To address this lack of guidance, we define a set of quality attributes and propose a question-based checklist to assist BDD scenarios' quality evaluations. [Methods] The quality attributes were identified from an interview-based study with 18 practitioners. In this study, practitioners shared their interpretations on an initial set of literature-informed quality attributes and their own personal evaluation criteria. We consolidated both in a single list of newly redefined attributes, used in the definition of our proposed checklist. We believe that our newly re-defined quality attributes and question-based checklist can enhance the existing guidelines and practitioners' ability to evaluate BDD scenario's quality by providing them with an standard guideline for scenarios' refinement conversations.	behavior-driven development; empirical study; checklist; documentation; quality	Oliveira, Gabriel; Marczak, Sabrina; Moralles, Cassiano	Proceedings of the XXXIII Brazilian Symposium on Software Engineering					Included	Included	new_screen			2						
4	Behave	Implementing behavior driven development in an open source ERP	A typical problem in Software Engineering is how to guarantee that all system's requirements are correctly implemented through source code. Traditionally, requirement tracing is a manual task comprised of keeping links from requirements to source code, going through different modeling artifacts, including models. However, these techniques cannot guarantee that requirements are always correctly implemented by source code. Aiming at solving this problem, Behavior-Driven Development (BDD) is a specification technique that automatically checks if all functional requirements are treated properly by source code through the connection of the textual description of requirements to automated tests. Given that for Enterprise Information Systems, requirements are usually identified by analyzing business process models, and these processes are implemented through workflows, connecting workflows to automated tests through BDD specifications can provide automated requirements traceability. The aim of this paper is to briefly present this proposal and show how it was implemented for the open source ERP5 system. © 2013 IFIP International Federation for Information Processing.		De Carvalho R.A., De Carvalho E Silva F.L., Manhães R.S., De Oliveira G.L.	Lecture Notes in Business Information Processing					Included	Included	new_screen			2						
5	Behave	Business Language Driven Development: Joining business process models to automated tests	A typical problem in Software Engineering is how to guarantee that every system requirement is correctly implemented by source code. Many techniques were proposed, mostly based on taking notes of relationships between requirements and code in modeling and documenting artifacts. However, these techniques cannot guarantee that the artifacts are always synchronized with source code. Aiming at solving this problem, Behavior-Driven Development (BDD) is a specification technique that automatically checks that all functional requirements are treated properly by source code, through connecting the textual description of requirements to automated tests. Nevertheless, in some software development areas, such as Enterprise Information Systems (EIS), requirements are usually identified by analyzing business process models - which use graphical notations of the underlying processes logic. Therefore, the aim of this paper is to present Business Language Driven Development (BLDD), a method that aims to extend BDD, by connecting business process models directly to automated tests, thus guaranteeing that requirements are properly covered by code. © 2012 Taylor & Francis Group, London.		De Carvalho R.A., De Carvalho E Silva F.L., Manhaes R.S.	Advances in Enterprise Information Systems II - Proceedings of the 5th International Conference on Research and Practical Issues of Enterprise Information Systems, CONFENIS 2011					Included	Included	new_screen			2						
6	Behave	Test Automation Using Selenium Webdriver 3.0 with C#	About the Book Test Automation using Selenium WebDriver with C#, is the latest book released on Selenium 3.0 using C# as a programming language. This Selenium book has been designed with the objectives of simplicity and ease of understanding. After the huge success of author Vaibhav Mittal and Navneesh Gargs Test Automation books on Selenium with Java, UFT and Microsoft Coded UI this book follows a similar step by step approach to Install, configure and design automation framework using Selenium WebDriver using Visual Studio 2017 and its components. Who is this book for? This book is recommended both for those who are beginning to learn test automation (using Selenium WebDriver) and for advanced automation users. It follows a unique training based approach instead of a regular textbook approach. Using a step by step approach, it guides the students through the exercises using pictorial snapshots. It includes many practical examples and issues which most of the automation testers encounter in day-to-day automation. These experiences will give you an insight into what challenges you could face with automation in the real world. Practical examples cover how to use most of the features within Selenium WebDriver using Visual Studio 2017. No Programming Background? A major fear amongst functional testers who want to learn Selenium is of programming language and coding. As a part of this, we will cover just enough basics of C# programming language that will give the readers the confidence to use Selenium WebDriver. Integrations Covered This book covers Selenium Webdriver integration with independent components to be installed like Microsoft Visual Studio 2017, Katalon, Extent Report, VSTS (Continuous Integration tool) and Specflow (Behaviour Driven Development). We will cover step by step installation, configuration and use of each of these components. Those want to know about Cross Browser testing, it covers how to use Selenium WebDriver to run on IE, Firefox and Chrome browsers. It also covers aspects of Continuous Integration tool from Microsoft (VSTS) so that Selenium WebDriver scripts can be integrated with the development environment and run on nightly builds.		Mittal, Vaibhav; Garg, Navneesh						Excluded	Excluded	new_screen			2						
7	Behave	Bridging the Gap between Requirements Modeling and Behavior-Driven Development	Acceptance criteria (AC) are implementation agnostic conditions that a system must meet to be consistent with its requirements and be accepted by its stakeholders. Each acceptance criterion is typically expressed as a natural-language statement with a clear pass or fail outcome. Writing AC is a tedious and error-prone activity, especially when the requirements specifications evolve and there are different analysts and testing teams involved. Analysts and testers must iterate multiple times to ensure that AC are understandable and feasible, and accurately address the most important requirements and workflows of the system being developed. In many cases, analysts express requirements through models, along with natural language, typically in some variant of the UML. AC must then be derived by developers and testers from such models. In this paper, we bridge the gap between requirements models and AC by providing a UML-based modeling methodology and an automated solution to generate AC. We target AC in the form of Behavioral Specifications in the context of Behavioral-Driven Development (BDD), a widely used agile practice in many application domains. More specially we target the well-known Gherkin language to express AC, which then can be used to generate executable test cases. We evaluate our modeling methodology and AC generation solution through an industrial case study in the financial domain. Our results suggest that (1) our methodology is feasible to apply in practice, and (2) the additional modeling effort required by our methodology is outweighed by the benefits the methodology brings in terms of automated and systematic AC generation and improved model precision.	Software testing;BDD;modeling;requirements engineering;text generation;Gherkin;FinTech	M. Alferez; F. Pastore; M. Sabetzadeh; L. Briand; J. Riccardi	2019 ACM/IEEE 22nd International Conference on Model Driven Engineering Languages and Systems (MODELS)					Included	Included	new_screen			2						
8	Behave	Design and validation of a C++ code generator from Abstract State Machines specifications	According to best practices of model-driven engineering, the implementation of a system should be obtained from its model through a systematic model-to-code transformation. We present in this paper a methodology supported by the Asm2C++ tool, which allows the users to generate C++ code from abstract state machine models. Thanks to Asm2C++, the implementation is generated in a seamless manner with an assurance of potential bug freeness of the generated code. Following the same approach, model-based testing suggests deriving also (unit) tests from abstract models. We extend the Asm2C++ tool such that it can automatically produce unit tests for the generated code. Abstract test sequences, either generated randomly or through model checking, are translated to concrete C++ unit tests using the Boost library. In a similar manner, also, scenarios are generated in a behavior-driven development (BDD) approach. To guarantee the correctness of the transformation process, we define a mechanism to test the correctness of the model-to-code transformation with respect to two main criteria: syntactical correctness and semantic correctness, which is based on the definition of conformance between the specification and the code. Using this approach, we have devised a process able to test the generated code by reusing unit tests. The process has been used to validate our model-to-code transformations. © 2019 John Wiley & Sons, Ltd.		Bonfanti S., Gargantini A., Mashkoor A.	Journal of Software: Evolution and Process					Excluded	Excluded	new_screen			2						
9	Behave	An optimized algorithm on distributed network node data access path based on behavior drive model	According to different node data access objects, and based on the idea of behavior-driven development, an interface-oriented node data access tool is designed and implemented. The tool mainly implements an executable node data access tool that is based on MFC, and writes a set of Win32 console application, which improves the node data automation access scripts and encapsulates the module interfaces, thus improving the distributed network data access speed. © (2014) Trans Tech Publications, Switzerland.		Jiang W.X., Hu X.Z., Wang S., Liang Y.	Applied Mechanics and Materials					Excluded	Excluded	new_screen			2						
10	Behave	The new Y Chromosome Haplotype Reference Database	After opening the first version of an internet-accessible worldwide reference database of Y chromosome profiles 14 years ago and six years after the last major relaunch the new YHRD 4.0 repository and website has been rolled-out. By November 2014 about 136k 9-locus haplotypes, among these 84k 17-locus haplotypes, 25k 23-locus haplotypes and 15k Y SNP profiles from 917 sampling locations in 128 countries have been submitted by more than 250 institutes and laboratories. In geographic terms, about 39% of the YHRD samples are from Europe, 32% from Asia, 16% from South America, 6% from North America, 4% from Africa and 2% from Oceania/Australia. Worldwide collaboration is the driving force for the rapid growth of the database and this, in turn, allows the evaluation and implementation of enhanced interpretation tools (variable frequency estimators, LR-based mixture and kinship analysis, Y-SNP-based ancestry assessment).	Database, Y chromosome, Haplotype, Y-STR, Frequency estimation, Metapopulation	Willuweit, Sascha; Roewer, Lutz	Forensic Science International: Genetics					Excluded	Excluded	new_screen			2						
11	Behave	Digital forensics as a service: Stepping up the game	After providing Digital Forensics as a Service (DFaaS) implementations to law enforcement agencies for close to a decade, we present our view from an inside-out perspective. We share the lessons learned from an organizational, operational and development perspective in a forensic and legal context. We conclude with our vision on how to bring the DFaaS concept to the next level for both investigative and innovative purposes.	Digital forensics, Digital forensics as a service, DFaaS, Hansken	van Beek, H. M. A.; van den Bos, J.; Boztas, A.; van Eijk, E. J.; Schramp, R.; Ugen, M.	Forensic Science International: Digital Investigation					Excluded	Excluded	new_screen			2						
12	Behave	Behavior-Driven Development Benefits and Challenges: Reports from an Industrial Study	Agile approaches arose as a way of addressing some of the main challenges in software development, such as changing requirements, lack of understanding about the system scope, and out-of-sync between code, requirements, and documentation. Studies show that agile projects still suffer from lack of customer support, resulting in difficulties to represent customer needs on requested features. Behavior-Driven Development (BDD) brings a structured way to represent user behaviors and to validate user stories by using an ubiquitous language, shared among everyone involved on the development of the software. The approach allows the creation of scenarios that can be used by the team to share information between different stakeholders, enabling all those players to successfully collaborate and coordinate their work. In this paper, we report on an empirical study conducted with 24 IT professionals with practical experience on BDD. Through this, we identify the perceived benefits and challenges of adopting BDD.	agile development; behavior-driven development; empirical study; grounded theory	Pereira, Lauriane; Sharp, Helen; de Souza, Cleidson; Oliveira, Gabriel; Marczak, Sabrina; Bastos, Ricardo	Proceedings of the 19th International Conference on Agile Software Development: Companion					Included	Included	new_screen			2						
13	Behave	Legend: An Agile DSL Toolset for Web Acceptance Testing	Agile development emphasizes collaborations among customers, business analysts, domain experts, developers, and testers. However, the large scale and rapid pace of many agile projects presents challenges during testing activities. Large sets of test artifacts must be comprehensible and available to various stakeholders, traceable to requirements, and easily maintainable as the software evolves. In this paper we describe Legend, a toolset that leverages domain-specific language to streamline functional testing in agile projects. Some key features of the toolset include test template generation from user stories, model-based automation, test inventory synchronization, and centralized test tagging.	Behavior-Driven Development; Software Testing; Agile Development; Domain-Specific Languages; Test Automation	King, Tariq M.; Nunez, Gabriel; Santiago, Dionny; Cando, Adam; Mack, Cody	Proceedings of the 2014 International Symposium on Software Testing and Analysis					Included	Included	new_screen			2						
14	Behave	Combining STPA and BDD for Safety Analysis and Verification in Agile Development	Agile development is in widespread use, even in safety-critical domains. However, there is a lack of an appropriate safety analysis and verification method in agile development. In this poster, we propose the use of Behavior Driven Development for safety verification with System-Theoretic Process Analysis for safety analysis in agile development. It shows a good capability on communication effectiveness through a preliminary controlled experiment.	agile development; safety verification; safety-critical systems	Wang, Yang; Wagner, Stefan	Proceedings of the 40th International Conference on Software Engineering: Companion Proceeedings					Included	Included	new_screen			2						
15	Behave	Poster: Combining STPA and BDD for Safety Analysis and Verification in Agile Development	Agile development is in widespread use, even in safety-critical domains. However, there is a lack of an appropriate safety analysis and verification method in agile development. In this poster, we propose the use of Behavior Driven Development for safety verification with System-Theoretic Process Analysis for safety analysis in agile development. It shows a good capability on communication effectiveness through a preliminary controlled experiment.	Agile Development;Safety Verification;Safety-Critical Systems	Y. Wang; S. Wagner	2018 IEEE/ACM 40th International Conference on Software Engineering: Companion (ICSE-Companion)					Excluded	Excluded	new_screen			2						
16	Behave	Identifying critical areas for improvement in agile multi-site co-development	Agile processes potentially ease distributed software development by demanding regular communication and self-management of virtual team members. However, being designed for collocated teams, extensions to the regular process need to be made. We investigate critical areas of improvement based on a case of distributed Scrum involving two unaffiliated Austrian IT organizations that collaborate to build software. We identified eight critical areas for improvement originating from interviews, retrospective meetings and an in-depth case analysis. Key suggestions for practice include the establishment of long-lived single-site Scrum teams and the application of Behavior Driven Development (BDD) to make implicit requirement knowledge explicit and transparent to all of the distributed parties. Copyright © 2013 SCITEPRESS.		Vallon R., Bayrhammer K., Strobl S., Bernhart M., Grechenig T.	ENASE 2013 - Proceedings of the 8th International Conference on Evaluation of Novel Approaches to Software Engineering					Excluded	Excluded	new_screen			2						
17	Behave	Quality of software requirements specification in agile projects: A cross-case analysis of six companies	Agile Software Development (ASD) has several limitations concerning its requirements engineering activities. Improving the quality of Software Requirements Specifications (SRSs) in ASD may help to gain a competitive advantage in the software industry. Based on the findings of a Systematic Mapping study, six industrial case studies in different contexts were conducted to investigate and characterize the requirements specification activity in ASD. Data collected from documents, observations, and interviews with software engineers were triangulated, analyzed, and synthesized using Grounded Theory and Meta-Ethnography. The analysis and cross-synthesis of the six case studies resulted in a model describing the phenomenon. This model defines the simplicity and objectivity as essential quality factors of SRSs in ASD. The main factors that affect the SRSs quality in ASD projects are related to their customer-driven nature that leads to prolix SRSs, hindering its understanding from the developer perspective. The emerged model is supported by explanations and provides a deeper understanding of the requirements specification activity in ASD. This creates opportunities for further studies and improvements in SRSs for ASD in industry.	Requirements specification, Agile methods, Empirical study, Agile Requirements Engineering	Medeiros, Juliana; Vasconcelos, Alexandre; Silva, Carla; Goulão, Miguel	Journal of Systems and Software					Excluded	Excluded	new_screen			2						
18	Behave	Assessing The Effectiveness Of Test-Driven Development and Behavior-Driven Development in an Industry Setting	Agile software development deviates from the traditional and plan-based approaches to software engineering as its iterative cycles embrace changes in software requirements. Test-Driven Development (TDD) and Behavior-Driven Development (BDD) are techniques that have been recently adopted by the software industry and have evolved from agile practices. These techniques aim at improving both the quality of the delivered software and the developers' productivity. They are several studies that have been conducted on TDD in both academic and industry settings with however only a few on BDD. While TDD and BDD have both become popular, many organizations and developers still do not understand the differences between these concepts or where they overlap. The aim of this paper is to assess the effectiveness of these two approaches in terms of external code quality, internal code quality and developers' productivity. To understand the weaknesses and strengths of each of these methods, a literature review was first performed. An experiment was then carried out in an industry setting to observe the effectiveness of TDD and BDD on a number of subjects. Our results showed that both techniques indeed increased the external quality of the delivered product. However, a decrease in productivity and internal quality were noted when BDD was used compared to TDD which might be due to the additional steps involved in BDD.	Test-Driven Development;Behavior-Driven Development;TDD;BDD;productivity;quality;code coverage	A. S. Dookhun; L. Nagowah	2019 International Conference on Computational Intelligence and Knowledge Economy (ICCIKE)					Included	Included	new_screen			2						
19	Behave	The effect of Test-Driven Development and Behavior-Driven Development on Project Success Factors: A Systematic Literature Review Based Study	Agile testing approaches test-driven development (TDD), behavior-driven development (BDD); have gained popularity since the introduction of agile practices. The concept of using these approaches in software projects is to help projects succeed. The effect of TDD and BDD on Project success factors namely, cost, time, and customer satisfaction/external quality, remains an area of investigation. Therefore, this study investigates the results of previously published articles on the effect of TDD and BDD on project success factors. A systematic literature review has been conducted considering articles published between 1999 up to 2020. Thirty-one studies were selected and analyzed. 74.1% of studies are experiments, 25.8% are case studies. 67.7% of these studies were performed in an industrial setting, 29.0% were performed in an academic setting and only one study with 3.22% was mixed academic and industrial settings. The result shows that the TDD and the BDD consume more time and cost compared to traditional testing (TLD). Moreover, the TDD as TLD may not necessarily satisfy the customer unlike the BDD appears that achieve customer satisfaction. Although, when TDD compared to BDD, TDD consumed more time and lower customer acceptance than the BDD.	Test Driven Development;Behavior Driven Development;Test Last Development;Systematic Literature Review;Agile Testing;Projects Success Factors	H. M. Abushama; H. A. Alassam; F. A. Elhaj	2020 International Conference on Computer, Control, Electrical, and Electronics Engineering (ICCCEEE)					Excluded	Excluded	new_screen			2						
20	Behave	Behavior driven testing in ALMA telescope calibration software	ALMA software development cycle includes well defined testing stages that involves developers, testers and scientists. We adapted Behavior Driven Development (BDD) to testing activities applied to Telescope Calibration (TELCAL) software. BDD is an agile technique that encourages communication between roles by defining test cases using natural language to specify features and scenarios, what allows participants to share a common language and provides a high level set of automated tests. This work describes how we implemented and maintain BDD testing for TELCAL, the infrastructure needed to support it and proposals to expand this technique to other subsystems. © COPYRIGHT SPIE. Downloading of the abstract is permitted for personal use only.		Gil J.P., Garces M., Broguiere D., Shen T.-C.	Proceedings of SPIE - The International Society for Optical Engineering					Included	Included	new_screen			2						
21	Behave	Behavior-Driven Requirements Traceability via Automated Acceptance Tests	Although information retrieval advances significantly improved automated traceability tools, their accuracy is still far from 100% and therefore they still need human intervention. Furthermore, despite the demonstrated benefits of traceability, many practitioners find the overhead for its creation and maintenance too high. We propose the Behavior Driven Traceability Method (BDT) that takes a different standpoint on automated traceability: we establish ubiquitous traceability between user story requirements and source code by taking advantage of the automated acceptance tests that are created as part of the Behavior Driven Development process.	User stories;automated acceptance tests;traceability;requirements;behavior-driven development	G. Lucassen; F. Dalpiaz; J. M. E. M. van der Werf; S. Brinkkemper; D. Zowghi	2017 IEEE 25th International Requirements Engineering Conference Workshops (REW)					Included	Included	new_screen			2						
22	Behave	Orchestration of Domain Specific Test Languages with a Behavior Driven Development approach	An airplane is composed by many complexes and embedded systems. During the integration testing phase, the design office produces requirements of the targeted system, and the test center produces concrete test procedures to be executed on a test bench. In this context, integration tests are mostly written in natural language and manually executed step by step by a tester. In order to formalize integration tests procedures dedicated to each system with domain specific languages approved by testers, and in order to automatize integration tests, we have introduced agile practices in the integration testing phase. We have chosen a Behavior Driven Development (BDD) approach to orchestrate Domain Specific Test Languages produced for the ACOVAS FUI project.		R. Bussenot; H. Leblanc; C. Percebois	2018 13th Annual Conference on System of Systems Engineering (SoSE)					Included	Included	new_screen			2						
23	Behave	Android Best Practices	Android Best Practices by Godfrey Nolan shows you how to make your Android apps stand out from the crowd with great reviews. Why settle for just making any Android app? Build a brilliant Android app instead that lets your users praise it for ease of use, better performance, and more. Using a series of example apps which gradually evolve throughout this book, Android Best Practices brings together current Android best practices from user interface (UI)/user experience (UX) design, test-driven development (TDD), and design patterns (e.g., MVC) to help you take your app to the next level. In this book youll learn how to: Use Android design patterns for consistent UI experience on many devices Use agile techniques such as test-driven development, behavior-driven development, and continuous integration Improve the speed and overall performance of your app Organize an Android app using design patterns such as MVC/MVP Create and consume REST and SOAP web servicesDesigning and developing an app that runs well on many if not all the leading Android smartphones and tablets today can be one of the most daunting challenges for Android developers. Well, this book takes much of the mystery out of that for you. After reading and using Android Best Practices, you'll become a much better Android app designer and developer, which in turn can make your apps better placed and more successful in the market place. What youll learn How to use Android design patterns for consistent UI experience on many devicesHow to use Agile techniques such as Test Driven Development, Behavior Driven Development and Continuous Integration How to test Android APKs on many devices and master device fragmentation Secure coding practices on Android How to organize an Android app using design patterns such as MVC/MVP etc. How to create and consume REST and SOAP web services Who this book is for This book is for Android developers looking to solidify their coding and overall app design and development skills.		Nolan, Godfrey; Cinar, Onur; Truxall, David						Excluded	Excluded	new_screen			2						
24	Behave	Smells in software test code: A survey of knowledge in industry and academia	As a type of anti-pattern, test smells are defined as poorly designed tests and their presence may negatively affect the quality of test suites and production code. Test smells are the subject of active discussions among practitioners and researchers, and various guidelines to handle smells are constantly offered for smell prevention, smell detection, and smell correction. Since there is a vast grey literature as well as a large body of research studies in this domain, it is not practical for practitioners and researchers to locate and synthesize such a large literature. Motivated by the above need and to find out what we, as the community, know about smells in test code, we conducted a ‘multivocal’ literature mapping (classification) on both the scientific literature and also practitioners’ grey literature. By surveying all the sources on test smells in both industry (120 sources) and academia (46 sources), 166 sources in total, our review presents the largest catalogue of test smells, along with the summary of guidelines/techniques and the tools to deal with those smells. This article aims to benefit the readers (both practitioners and researchers) by serving as an “index” to the vast body of knowledge in this important area, and by helping them develop high-quality test scripts, and minimize occurrences of test smells and their negative consequences in large test automation projects.	Software testing, Automated testing, Test automation, Test scripts, Test smells, Test anti-patterns, Multivocal literature mapping, Survey, Systematic mapping	Garousi, Vahid; Küçük, Barış	Journal of Systems and Software					Excluded	Excluded	new_screen			2						
25	Behave	Omni-script: Device independent user interface development for omni-channel fintech applications	As the number of devices and platforms gradually increased that serve as a medium for online banking services, the number of replicated services for different platforms also increase. Each service has a different representation in a different platform even though targeting the same business objectives. This situation results in the problem of re-developing similar set of requirements for different devices and services which in turn results in multiplied effort in software development and degradation in the software quality because of the replicated code. The objective of this paper is to present a device independent user interface development approach that eliminates the replicated user interface development effort of the same set of services for different platforms/devices while increasing the presentation performance. In this context, we provide a basic technique that uses a json based user interface definition format, called omni-script, to separate the representation of banking services in different platforms/devices, so called channels. Omni-script is a pioneering solution being used in a real development environment in banking software domain that is experiencing a shift towards omni-channel user experience, where users are able to seamlessly continue using banking services in different platforms and devices. As the evaluation method, we have measured the actual development effort on a representative sample development team and a set of services. Additionally, we later deployed and measured the rendering time and the amount of data communication for the proposed approach in a real production environment. Production deployment resulted in a remarkable decrease in data communication and in loading times at the client side. As importantly, the proposed approach also resulted in a nearly 75% decrease in service development time by enabling analysts to produce user interface prototypes that can be integrated to service development with minimal effort.	Multimodal user interface definition, Omni-channel user experience, Omni-channel banking services	Ulusoy, Simge; Batıoğlu, Alper; Ovatman, Tolga	Computer Standards & Interfaces					Excluded	Excluded	new_screen			2						
26	Behave	Validating enterprise architecture using ontology-based approach: A case study of student internship programme	As the practice of Enterprise Architecture (EA) diversifies, the schematic management of its objects, semantics and relationship continues to be complex. Given that EA provides support for the IT environment by simulating alignment between dynamic business architectures, heterogeneous application systems and incongruent technologies, the need to ensure validation of conceptualized EA models has become also critical. As a relatively new discipline, its disparate and widespread methodologies makes it even more challenging to adopt a generic approach in which models can be verified sequel to the unavailability of unified EA modelling languages able to describe a wide range of Information Technology domains. This paper seeks to present an approach for addressing this challenge through the use of ontologies and queries based on constraints specified in the model's motivation taxonomy. The paper is experimental research-based and grounds its hypothesis on initial model created using the ArchiMate modelling language. By transforming its conceptual metamodel into a model instance, a process which can be achieved irrespective of the modeling language used in the design of the EA, it represents extracted triples as resource description framework schema (RDFS) by mapping the model artefacts directly into classes and slots using a more conventional web ontology language. The generated RDF is then queried using Protocol and RDF Query Language (SPARQL) adopting the Behavior Driven Development (BDD) concept. A case study of the Student Internship Program (SIP) is deployed to translate information from business needs to IT solutions encapsulating a view of abstraction of the EA. The paper also proposes an implementation of the approach using an open source platform that allows construction of domain models and knowledge-based applications with ontologies and is a contribution towards effective validation of EA through taxonomy decomposition, systematic generation of testable EA artifacts, creation of structural triples of model elements and alignment of motivational goals to business behavior specifications.	Ontology;Enterprise Architecture;Metamodel;Model;Viewpoints;Resource Description Framework;Schema and Query Language;ArchiMate;Validation	S. Oussena; J. Essien	2013 3rd International Symposium ISKO-Maghreb					Excluded	Excluded	new_screen			2						
27	Behave	Did You Remember To Test Your Tokens?	"Authentication is a critical security feature for confirming the identity of a system's users, typically implemented with help from frameworks like Spring Security. It is a complex feature which should be robustly tested at all stages of development. Unit testing is an effective technique for fine-grained verification of feature behaviors that is not widely-used to test authentication. Part of the problem is that resources to help developers unit test security features are limited. Most security testing guides recommend test cases in a ""black box"" or penetration testing perspective. These resources are not easily applicable to developers writing new unit tests, or who want a security-focused perspective on coverage.In this paper, we address these issues by applying a grounded theory-based approach to identify common (unit) test cases for token authentication through analysis of 481 JUnit tests exercising Spring Security-based authentication implementations from 53 open source Java projects. The outcome of this study is a developer-friendly unit testing guide organized as a catalog of 53 test cases for token authentication, representing unique combinations of 17 scenarios, 40 conditions, and 30 expected outcomes learned from the data set in our analysis. We supplement the test guide with common test smells to avoid. To verify the accuracy and usefulness of our testing guide, we sought feedback from selected developers, some of whom authored unit tests in our dataset."	Unit Test; Java; Authentication; Repository Mining; Security Test	Gonzalez, Danielle; Rath, Michael; Mirakhorli, Mehdi	Proceedings of the 17th International Conference on Mining Software Repositories					Excluded	Excluded	new_screen			2						
28	Behave	XUnit Test Patterns: Refactoring Test Code	"Automated testing is a cornerstone of agile development. An effective testing strategy will deliver new functionality more aggressively, accelerate user feedback, and improve quality. However, for many developers, creating effective automated tests is a unique and unfamiliar challenge.xUnit Test Patterns is the definitive guide to writing automated tests using xUnit, the most popular unit testing framework in use today. Agile coach and test automation expert Gerard Meszaros describes 68 proven patterns for making tests easier to write, understand, and maintain. He then shows you how to make them more robust and repeatable–and far more cost-effective.Loaded with information, this book feels like three books in one. The first part is a detailed tutorial on test automation that covers everything from test strategy to in-depth test coding. The second part, a catalog of 18 frequently encountered ""test smells,"" provides trouble-shooting guidelines to help you determine the root cause of problems and the most applicable patterns. The third part contains detailed descriptions of each pattern, including refactoring instructions illustrated by extensive code samples in multiple programming languages.Topics covered include Writing better tests–and writing them faster The four phases of automated tests: fixture setup, exercising the system under test, result verification, and fixture teardown Improving test coverage by isolating software from its environment using Test Stubs and Mock Objects Designing software for greater testability Using test ""smells"" (including code smells, behavior smells, and project smells) to spot problems and know when and how to eliminate them Refactoring tests for greater simplicity, robustness, and execution speedThis book will benefit developers, managers, and testers working with any agile or conventional development process, whether doing test-driven development or writing the tests last. While the patterns and smells are especially applicable to all members of the xUnit family, they also apply to next-generation behavior-driven development frameworks such as RSpec and JBehave and to other kinds of test automation tools, including recorded test tools and data-driven test tools such as Fit and FitNesse.Visual Summary of the Pattern Languageï Foreword Preface Acknowledgments Introduction Refactoring a TestPART I: The Narratives Chapter 1 A Brief Tour Chapter 2 Test Smells Chapter 3 Goals of Test Automation Chapter 4 Philosophy of Test Automation Chapter 5 Principles of Test Automation Chapter 6 Test Automation Strategy Chapter 7 xUnit Basics Chapter 8 Transient Fixture Management Chapter 9 Persistent Fixture Management Chapter 10 Result Verification Chapter 11 Using Test Doubles Chapter 12 Organizing Our Tests Chapter 13 Testing with Databases Chapter 14 A Roadmap to Effective Test Automation PART II: The Test Smellsï Chapter 15 Code Smells Chapter 16 Behavior Smells Chapter 17 Project Smells PART III: The Patternsï Chapter 18 Test Strategy Patterns Chapter 19 xUnit Basics Patterns Chapter 20 Fixture Setup Patterns Chapter 21 Result Verification Patterns Chapter 22 Fixture Teardown Patterns Chapter 23 Test Double Patterns Chapter 24 Test Organization Patterns Chapter 25 Database Patterns Chapter 26 Design-for-Testability Patterns Chapter 27 Value Patterns PART IV: Appendixes Appendix A Test Refactorings ï Appendix B xUnit Terminologyï Appendix C xUnit Family Members Appendix D Tools Appendix E Goals and Principles Appendix F Smells, Aliases, and Causes Appendix G Patterns, Aliases, and Variations Glossary Referencesï Indexï"		Meszaros, Gerard						Excluded	Excluded	new_screen			2						
29	Behave	Visualizing data, encouraging change: Technical interventions in food purchasing	Baked Potato is a mobile web service geared at addressing the imbalance of power between those who market and those who consume food products. Food marketers rarely provide a detailed range of information about products that would allow consumers to understand how a product and its company connect to their cultural values. The main goal of this application is to connect people in a way that celebrates their differences and gives them agency by helping them make better decisions about their food purchases.	Behavior Driven Development;decision making;human-computer interaction;incentive design;social gaming	D. J. Sackey; N. Ullmann	2012 IEEE International Professional Communication Conference					Excluded	Excluded	new_screen			2						
30	Behave	Visualizing data, encouraging change: Technical interventions in food purchasing	Baked Potato is a mobile web service geared at addressing the imbalance of power between those who market and those who consume food products. Food marketers rarely provide a detailed range of information about products that would allow consumers to understand how a product and its company connect to their cultural values. The main goal of this application is to connect people in a way that celebrates their differences and gives them agency by helping them make better decisions about their food purchases. © 2012 IEEE.		Sackey D.J., Ullmann N.	IEEE International Professional Communication Conference					Excluded	Excluded	new_screen			2						
31	Behave	Behavior driven development for airborne software engineering	Behavior Driven Development (BDD) is a test driven development approach which aims at bridging the gap between the end-user and the software development. It promotes a semi-formal ubiquitous language for executable behavior specification and automated acceptance testing. The BDD infrastructure Cucumber and the language Gherkin have been established in many application domains. This paper discusses their utilization for airborne software engineering with an example application, Class C Terrain Awareness and Warning System, being developed using Rust language with Rust BDD infrastructure. © 2021, American Institute of Aeronautics and Astronautics Inc, AIAA. All rights reserved.		Zaeske W., Beck J., Torrens C., Durak U.	AIAA Scitech 2021 Forum					Included	Included	new_screen			2						
32	Behave	Predicting Co-Changes between Functionality Specifications and Source Code in Behavior Driven Development	Behavior Driven Development (BDD) is an agile approach that uses .feature files to describe the functionalities of a software system using natural language constructs (English-like phrases). Because of the English-like structure of .feature files, BDD specifications become an evolving documentation that helps all (even non-technical) stakeholders to understand and contribute to a software project. After specifying a .feature files, developers can use a BDD tool (e.g., Cucumber) to automatically generate test cases and implement the code of the specified functionality. However, maintaining traceability between .feature files and source code requires human efforts. Therefore, .feature files can be out-of-date, reducing the advantages of using BDD. Furthermore, existing research do not attempt to improve the traceability between .feature files and source code files. In this paper, we study the co-changes between .feature files and source code files to improve the traceability between .feature files and source code files. Due to the English-like syntax of .feature files, we use natural language processing to identify co-changes, with an accuracy of 79%. We study the characteristics of BDD co-changes and build random forest models to predict when a .feature files should be modified before committing a code change. The random forest model obtains an AUC of 0.77. The model can assist developers in identifying when a .feature files should be modified in code commits. Once the traceability is up-to-date, BDD developers can write test code more efficiently and keep the software documentation up-to-date.	behavior driven development; co-changes; empirical software engineering; traceability	Yang, Aidan Z. H.; da Costa, Daniel Alencar; Zou, Ying	Proceedings of the 16th International Conference on Mining Software Repositories					Included	Included	new_screen			2						
33	Behave	Theoretical Verification of Test Cases for Behavior Driven Development	Behavior Driven Development insists on generation of early test cases during requirements elicitation. These would form the basis for pseudo use cases in TDD. These early test cases for BDD, aka theoretical test cases, are developed using Named Entity Recognition approaches over expanded use cases. This paper proposes the algorithm for theoretical verification of obtaining the original reduced use case sequences from the obtained BDD test cases.	Reduced UC Sequence;Test cases;Usecase Dependency Graph	G. S. Mahalakshmi; V. Vani	2017 Second International Conference on Recent Trends and Challenges in Computational Models (ICRTCCM)					Included	Included	new_screen			2						
34	Behave	A Model-Driven Approach for Behavior-Driven GUI Testing	Behavior-driven development (BDD) brings requirement specifications and their test cases closer together by using a ubiquitous language to describe requirements that are automatically mapped to test methods. Although industry-proven tools support this automated requirement mapping, the test methods need to be implemented manually. The approach presented in this paper transforms BDD-like requirement specifications and low fidelity graphical user interface (GUI) descriptions in the format of wireframes into automatically executable graphical user interface test cases. The requirement descriptions are defined in a domain-specific language (DSL) that obeys the rules of the ubiquitous language enhanced by references to screens and widgets in a graphical user interface model. The paper reports on a controlled AB/BA crossover experiment comparing the efficiency of our approach to the industry-proven JBehave tooling. The results show that the introduced approach on average takes 63% less time to specify automated tests and thereby diminishes the problem of graphical user interface test cases being expensive to write. The experimental results were supported by experience made applying the approach in three differently sized components at a large Swiss bank.	behavior-driven development; domain-specific language; GUI test case generation; model-driven engineering	Bünder, Hendrik; Kuchen, Herbert	Proceedings of the 34th ACM/SIGAPP Symposium on Applied Computing					Included	Included	new_screen			2						
35	Behave	Evaluating the usage of predefined interactive behaviors for writing user stories: an empirical study with potential product owners	Behavior-driven development (BDD) has gained popularity in agile software development as a means of specifying user requirements through user stories and scenarios for interactive systems under construction. Templates for guiding the writing of such stories are widely employed and can be helpful to ensure that consistent information about the requirements is provided. With the aim of getting preliminary results about how product owners (POs) write their own user stories under a predefined template, we conducted a case study with potential POs at the department in charge of business trips in a French research institute. The participants were invited to write their own user stories to describe a feature they are used to perform. The resultant stories have been analyzed to check their adherence to a template including common interactive behaviors defined by an ontology for interactive systems. Although the participants have followed different specification strategies, we observed an overall high level of adherence to the proposed template (62.26%). The results also pointed out to a wide use of domain-dependent behaviors, with the interactive behaviors defined by the ontology being, to some extent, reproduced by the participants even without prior training in the adopted vocabulary. © 2019, Springer-Verlag London Ltd., part of Springer Nature.		Rocha Silva T., Winckler M., Bach C.	Cognition, Technology and Work					Included	Included	new_screen			2						
36	Behave	On the Empirical Evaluation of BDD Scenarios Quality: Preliminary Findings of an Empirical Study	"Behavior-Driven Development (BDD) is a set of software engineering practices which uses a ubiquitous language, one that business and technical people can understand, to describe and model a system by a series of textual scenarios. However, we believe that the value of those textual scenarios is connected with how well they convey and document the details discussed by the team about the behaviors needed to fulfill customer needs. Thus, there is the need to define what would be a ""good"" BDD scenario and how to evaluate scenarios. On this research design paper, we describe a study designed to understand how known quality attributes from other types of requirements specifications (like use cases or user stories) can be used with BDD scenarios. We also report our preliminary findings after performing it with novice evaluators. Those findings indicate that some of those attributes can be used to support BDD scenarios assessments."	documentation quality;documentation evaluation;behavior-driven development;empirical study	G. Oliveira; S. Marczak	2017 IEEE 25th International Requirements Engineering Conference Workshops (REW)					Included	Included	new_screen			2						
37	Behave	On the Applicability of BDD in a Business Intelligence Project: Experience Report	Behavior-driven development (BDD) is a software development technique that in order to succeed relies heavily on the definition of clear acceptance criteria by software developers in the form of behavioral scenarios, later translated into acceptance tests. The adoption of BDD in Business Intelligence (BI) projects requires developers to have a broad acquaintance to business that often even customers themselves do not possess. This article presents an experience report on the use of BDD in the development of a large public health related BI project. Experience suggests that the use of BDD may not be appropriate for BI projects, especially during the early stages of development, when there is still insufficient clarity about business acceptance criteria. The need for broad maturity towards business understanding makes it complex to adopt the behavioral approach within the development process in projects of this nature.	behavior-driven development; business intelligence.; Software quality	Mello, Patrícia; Ximenes, Pablo; Lemos, Rousiany; Bessa, Ana Luíza; Cortés, Mariela I.; Rocha, Cleilton Lima	Proceedings of the 17th Brazilian Symposium on Software Quality					Included	Included	new_screen			2						
38	Behave	BHive: Behavior-Driven development meets B-Method	Behavior-Driven Development (BDD) is an “outside-in” approach to software development built upon semi-formal mediums for specifying the behavior of a system as it would be observed externally. Through the representation of a system as a collection of user stories and scenarios using BDD’s notation, practitioners automate acceptance tests using examples of desired behavior for the envisioned system. A formal model created in concert with BDD tests would provide valuable insight into test validity and enhance the visibility of the problem domain. This work called BHive builds upon the formal underpinnings of BDD scenarios by mapping their “Given,” “When,” and “Then” statements to “Precondition,” “Command,” and “Postcondition” constructs as introduced by Floyd-Hoare logic. We posit that this mapping allows for a B-Method representation to be created and that such a model is useful for exploring system behavior and exposing gaps in requirements and test plans. In this extension of previous work, we outline recent additions to BDD tooling required for the described integration, present a new strategy for test case generation from our approach, and expand on the benefits of the BHive approach to integrating formalism within a BDD project. © 2018, Springer International Publishing AG.		Carter J.D., Gardner W.B.	Advances in Intelligent Systems and Computing					Included	Included	new_screen			2						
39	Behave	Automatically generating tests from natural language descriptions of software behavior	"Behavior-Driven Development (BDD) is an emerging agile development approach where all stakeholders (including developers and customers) work together to write user stories in structured natural language to capture a software application's functionality in terms of required ""behaviors."" Developers can then manually write ""glue"" code so that these scenarios can be translated into executable software tests. This glue code represents individual steps within unit and acceptance test cases, and tools exist that automate the mapping from scenario descriptions to manually written code steps (typically using regular expressions). This paper takes the position that, instead of requiring programmers to write manual glue code, it is practical to convert natural language scenario descriptions into executable software tests fully automatically. To show feasibility, this paper presents preliminary results from a tool called Kirby that uses natural language processing techniques to automatically generate executable software tests from structured English scenario descriptions. Kirby relieves the developer from the laborious work of writing code for the individual steps described in scenarios, so that both developers and customers can both focus on the scenarios as pure behavior descriptions (understandable to all, not just programmers). Preliminary results from assessing the performance and accuracy of this technique are presented. Copyright © 2013 SCITEPRESS."		Kamalakar S., Edwards S.H., Dao T.M.	ENASE 2013 - Proceedings of the 8th International Conference on Evaluation of Novel Approaches to Software Engineering					Included	Included	new_screen			2						
40	Behave	On the Understanding of How to Measure the Benefits of Behavior-Driven Development Adoption: Preliminary Literature Results from a Grey Literature Study	Behavior-Driven Development (BDD) is the integration of a ubiquitous language with Test-Driven Development and Automated Testing. From this integration, BDD supports software teams to build and deliver software. Although the perceived arguments of better results and of a more efficient development process, we still have no consolidated evidence of such benefits and how to measure them. Therefore, this long-term research aims to characterize how BDD adoption benefits can be measured. To do so, our research design includes a Multivocal Literature Review, composed of a Grey Literature to explore how industry tackles the topic and a Systematic Review to gather scientific evidences, followed of a Snowballing Review to supplement the search. Next, we will conduct empirical studies to characterize the topic from practice. This paper introduces our research and presents the results from our exploratory Grey Literature. We learned from these preliminary results that there are no models or frameworks defined to measure BDD adoption benefits but that teams indeed perceive improvements in software quality, communication, rework rates, among others. We also found that these teams also perceive that team engagement improves with the adoption of BDD and that although there is a certain cost (e.g., time and financial) involved, the investment pays off in the end. These results will inform the design of our Systematic Review and of our downstream empirical studies.	Behavior-Driven Development; BDD Adoption; Benefits; Grey Literature Review; Quality Measurement	Couto, Thiciane; Marczak, Sabrina; Gomes, Fabio	19th Brazilian Symposium on Software Quality					Excluded	Excluded	new_screen			2						
41	Behave	Behavior-Driven Development: Conference Tutorial	Behavior-driven development is a software development technique in which system behaviors are determined and made into test cases before the software itself is written. Benefits can include a richer and deeper understanding of system requirements in addition to making these requirements executable. Moreover, this technique helps guide software developers in knowing what to test as well as knowing how much to test. In this tutorial, we introduce the fundamentals of this approach, a language for expressing system behaviors, and explain how to use this technique effectively in the undergraduate computer science curriculum.		Kart, Michael	J. Comput. Sci. Coll.					Excluded	Excluded	new_screen			2						
42	Behave	A Study of the Characteristics of Behaviour Driven Development	Behaviour Driven Development (BDD) has gained increasing attention as an agile development approach in recent years. However, characteristics that constituite the BDD approach are not clearly defined. In this paper, we present a set of main BDD charactersitics identified through an analysis of relevant literature and current BDD toolkits. Our study can provide a basis for understanding BDD, as well as for extending the exisiting BDD toolkits or developing new ones.	Automated Acceptance Testing; Behaviour Driven Development; Test Driven Development; Ubiquitous Language	Solis, Carlos; Wang, Xiaofeng	Proceedings of the 2011 37th EUROMICRO Conference on Software Engineering and Advanced Applications					Included	Included	new_screen			2						
43	Behave	Behave nicely! automatic generation of code for behaviour driven development test suites	Behaviour driven development (BDD) has gained widespread use in the software industry. System specifications can be expressed as test scenarios, describing the circumstances, actions and expected outcomes. These scenarios are written in a structured natural language (Gherkin), with each step in the scenario associated with a corresponding step implementation function in the underlying programming language. A challenge recognised by industry is ensuring that the natural language scenarios, step implementation functions and underlying system implementation remain consistent with one another, requiring on-going maintenance effort as changes are made to a system. To address this, we have developed behave-nicely, a tool, for automatically generating step implementation functions from structured natural language steps, with the intention of eliminating the need for maintaining step implementation functions. We evaluated our approach on a sample of 20 white box and 50 black box projects using behaviour driven development, drawn from GitHub. Our results show that behave-nicely can generate step implementation functions for 80% of the white box and 17% of black box projects. We conclude that (a) there is significant potential for automating the process of code generation for BDD tests and (b) that the development of guidelines for writing tests in Gherkin would significantly improve the results. © 2019 IEEE.		Storer T., Bob R.	Proceedings - 19th IEEE International Working Conference on Source Code Analysis and Manipulation, SCAM 2019					Included	Included	new_screen			2						
44	Behave	Characterising the Quality of Behaviour Driven Development Specifications	Behaviour Driven Development (BDD) is an agile testing technique that enables software requirements to be specified as example interactions with the system, using structured natural language. While (in theory) being readable by non-technical stakeholders, the examples can also be executed against the code base to identify behaviours that are not yet correctly implemented. Writing good BDD suites, however, is challenging. A typical suite can contain hundreds of individual scenarios, that must correctly specify the system as a whole as well as individually. Despite much discussion amongst practitioners and in the blogosphere, as yet no formal definition of what makes for a high quality BDD suite has been given. To shed light on this, we surveyed BDD practitioners, asking for their opinions on the quality criteria that are important for BDD suites. We proposed, and asked for opinions on, four quality principles, and gave practitioners the option to add more principles of their own. This paper reports on the results of the survey, and presents an approach to defining BDD suite quality. © The Author(s) 2020.		Binamungu L.P., Embury S.M., Konstantinou N.	Lecture Notes in Business Information Processing					Included	Included	new_screen			2						
45	Behave	Behaviour-Driven Development of Foundational UML Components	Behaviour-Driven Development (BDD) focuses all development activities on the delivery of behaviours - what a system should do, described such that developers and domain experts speak the same language. BDD frameworks allow users to represent the required system behaviour as executable user stories and the acceptance criteria as executable scenarios attached to user stories. In this paper we define a UML profile that allows users to create executable Foundational UML (fUML) stories and scenarios. In order to easily construct scenarios we introduce a BDD model library which contains fUML activities for testing equalities and inclusions. We also present an Eclipse-based development tool that supports a BDD approach for developing fUML components. The tool provides developers a concrete syntax for defining executable scenarios, and automatically updates the project status based on verified delivered behaviorus.	acceptance criteria; behaviour-driven development; executable specification; executable UML; user story	Lazr, Ioan; Motogna, Simona; Pírv, Bazil	Electron. Notes Theor. Comput. Sci.					Included	Included	new_screen			2						
46	Behave	BHive: Towards Behaviour-Driven Development Supported by B-Method	"Behaviour-Driven Development (BDD) is an ""outside-in"" approach to software development built upon semi-formal mediums for specifying the behaviour of a system as it would be observed externally. Through the representation of a system as a collection of user stories and scenarios using BDD's notation, practitioners automate acceptance tests using examples of desired behaviour for the envisioned system. A formal model created in concert with BDD tests would provide valuable insight into test validity and enhance the visibility of the problem domain. This work called BHive builds upon the formal underpinnings of BDD scenarios by mapping their ""Given,"" ""When,"" and ""Then"" statements to ""Precondition,"" ""Command,"" and ""Postcondition"" constructs as introduced by Floyd-Hoare logic. We posit that this mapping allows for a B-Method representation to be created and that such a model is useful for exploring system behaviour and exposing gaps in requirements. We also outline extensions to BDD tooling required for the described integration and present benefits of the BHive approach to integrating formalism within a BDD project."		Carter, J.; Gardner, W. B.	2016 IEEE 17th International Conference on Information Reuse and Integration (IRI)					Included	Included	new_screen			2						
47	Behave	Empirical Findings on BDD Story Parsing to Support Consistency Assurance between Requirements and Artifacts	Behaviour-Driven Development (BDD) stories have gained considerable attention in recent years as an effective way to specify and test user requirements in agile software development projects. External testing frameworks also allow developers to automate the execution of BDD stories and check whether a fully functional software system behaves as expected. However, other software artifacts may quite often lose synchronization with the stories, and many inconsistencies can arise with respect to requirements representation. This paper reports on preliminary empirical findings regarding the performance of two existing approaches in the literature intended to support consistency assurance between BDD stories and software artifacts. The first approach involves the parsing of BDD stories in order to identify conceptual elements to automatically generate consistent class diagrams, while the second approach seeks to identify interaction elements to automatically assess the consistency of task models and GUI prototypes. We report on the precision of these approaches when applied to a study with BDD stories previously written by Product Owners (POs). Based on the results, we also identify a set of challenges and opportunities for BDD stories in the consistency assurance of such artifacts.		Silva, Thiago Rocha; Fitzgerald, Brian	Evaluation and Assessment in Software Engineering					Included	Included	new_screen			2						
48	Behave	Blockchain smart contracts formalization: Approaches and challenges to address vulnerabilities	Blockchain as a distributed computing platform enables users to deploy pieces of software (known as smart contracts) for a wealth of next-generation decentralized applications without involving a trusted third-party. The advantages of smart contracts do, however, come at a price. As with most technologies, there are potential security threats, vulnerabilities and various other issues associated with smart contracts. Writing secure and safe smart contracts can be extremely difficult due to various business logics, as well as platform vulnerabilities and limitations. Formal methods have recently been advocated to mitigate these vulnerabilities. This paper aims to provide a first-time study on current formalization research on all smart contract-related platforms on blockchains, which is scarce in the literature. To this end, a timely and rigorous systematic review to examine the state-of-the-art research and achievements published between 2015 and July 2019 is provided. This study is based on a comprehensive review of a set of 35 research papers that have been extracted from eight major online digital databases. The results indicate that the most common formalization technique is theorem proving, which is most often used to verify security properties relating to smart contracts, while other techniques such as symbolic execution and model checking were also frequently used. These techniques were most commonly used to verify the functional correctness of smart contracts. From the language and automation point of views, there were 12 languages (domain specific/specification/general purpose) proposed or used for the formalization of smart contracts on blockchains, while 15 formal method-specific automated tools/frameworks were identified for mitigating various vulnerabilities of smart contracts. From the results of this work, we further highlight three open issues for future research in this emerging domain including: formal testing, automated verification of smart contracts, and domain specific languages (DSLs) for Ethereum. These issues suggest the need for additional, in-depth research. Our study also provides possible future research directions.	Blockchain, Smart contracts, Formal methods, Verification, Systematic review	Singh, Amritraj; Parizi, Reza M.; Zhang, Qi; Choo, Kim-Kwang Raymond; Dehghantanha, Ali	Computers & Security					Excluded	Excluded	new_screen			2						
49	Behave	Survey on blockchain based smart contracts: Applications, opportunities and challenges	Blockchain is one of the disruptive technical innovation in the recent computing paradigm. Many applications already notoriously hard and complex are fortunate to ameliorate the service with the blessings of blockchain and smart contracts. The decentralized and autonomous execution with in-built transparency of blockchain based smart contracts revolutionize most of the applications with optimum and effective functionality. The paper explores the significant applications which already benefited from the smart contracts. We also highlight the future potential of the blockchain based smart contracts in these applications perspective.	Blockchain, Smart contracts, Applications, DLT, Hyperledger Fabric, Ethereum, Corda, Stellar	Hewa, Tharaka; Ylianttila, Mika; Liyanage, Madhusanka	Journal of Network and Computer Applications					Excluded	Excluded	new_screen			2						
50	Behave	End-to-End Automatic Business Process Validation	Business Process Testing is the act of validating that end-to-end transactions through enterprise systems continue to work correctly as the underlying packaged applications evolve. End-to-end automatic business process validation can be a challenging task, but an important way to check that business rules continue to work properly and that problems are detected and corrected as soon as possible. This paper presents the design of a test automation platform, ETAP-Pro, to test end-to-end business processes that aims to overcome some challenges in validating business processes.	Business Process Testing; End-to-end Process Testing; Model Based Testing; Software Testing	Paiva, Ana C.R.; Flores, Nuno H.; Faria, Joo P.; Marques, Jos M.G.	Procedia Comput. Sci.					Excluded	Excluded	new_screen			2						
51	Behave	A Reusable Automated Acceptance Testing Architecture for Microservices in Behavior-Driven Development	Cloud Computing and Mobile Cloud Computing are reshaping the way applications are being developed and deployed due to their unique needs such as massive scalability, guaranteed fault tolerance, near zero downtime, etc. and also daunting challenges such as security, reliability, continuous deployment and update capability. Microservices architecture, where application is composed of a set of independently deployable services, is increasingly becoming popular due to its capability to address most of these needs and challenges. In recent years, the Behavior-Driven Development (BDD) has become one of the most popular agile software development processes, and frequently used in microservices development. The key to success of BDD is the executable acceptance tests that describe the expected behavior of a feature and its acceptance criteria in the form of scenarios using simple and business people readable syntax. The reusability, auditability, and maintainability become some of the major concerns when BDD test framework is applied for each microservice repository and no previous research addresses these concerns. In this paper, we present a reusable automated acceptance testing architecture to address all these concerns.	behavior-driven development; Gherkin; executable automated acceptance testing; functional testing; microservice	Rahman, Mazedur; Gao, Jerry	Proceedings of the 2015 IEEE Symposium on Service-Oriented System Engineering					Excluded	Excluded	new_screen			2						
52	Behave	A reusable automated acceptance testing architecture for microservices in behavior-driven development	Cloud Computing and Mobile Cloud Computing are reshaping the way applications are being developed and deployed due to their unique needs such as massive scalability, guaranteed fault tolerance, near zero downtime, etc. and also daunting challenges such as security, reliability, continuous deployment and update capability. Microservices architecture, where application is composed of a set of independently deployable services, is increasingly becoming popular due to its capability to address most of these needs and challenges. In recent years, the Behavior-Driven Development (BDD) has become one of the most popular agile software development processes, and frequently used in microservices development. The key to success of BDD is the executable acceptance tests that describe the expected behavior of a feature and its acceptance criteria in the form of scenarios using simple and business people readable syntax. The reusability, auditability, and maintainability become some of the major concerns when BDD test framework is applied for each microservice repository and no previous research addresses these concerns. In this paper, we present a reusable automated acceptance testing architecture to address all these concerns. © 2015 IEEE.		Rahman M., Gao J.	Proceedings - 9th IEEE International Symposium on Service-Oriented System Engineering, IEEE SOSE 2015					Included	Included	new_screen			2						
53	Behave	Generating educational mobile applications using UIDPs identified by artificial intelligence techniques	Commercial mobile devices vary in brand, size, and functionalities, but they all allow people to interact with educational applications. In software engineering, application development techniques, approaches, methodologies, and processes (e.g., BBD, FDD, RAD, DDD) are often time consuming, costly, or aim at expert developers – which implies that users outside the software development field (e.g., teachers) need great practice to become experienced application developers. This work proposes an artificial-intelligence-based process for generating educational mobile apps from freehand-generated images. The images’ design is based on User Interface Design Pattern (UIDP) representations. As a proof of concept, we introduce EduMatic, an application development tool. To test our process, we assessed Wiki-Comp, an application built with EduMatic, along with three other external educational applications: Khan Academy, Wiki encyclopedia, and Kiwix. According to the evaluation results, Wiki-Comp outstands in functionality, usability, and performance aspects.	Mobile development, Automatic code generation, Image processing, Educational apps, User interface design pattern	Sánchez-Morales, Laura Nely; Alor-Hernández, Giner; Rosales-Morales, Viviana Yarel; Cortes-Camarillo, Cesar Augusto; Sánchez-Cervantes, José Luis	Computer Standards & Interfaces					Excluded	Excluded	new_screen			2						
54	Behave	Concurrent development and verification of an all-software baseband for satellite ground operations	Communication systems are adopting all-software architectures, because of their scalability, extensibility, flexibility, and cost-effectiveness. This paper introduces a concurrent approach to the development and verification of baseband systems for satellite ground operations based on the behaviour-driven development methodology. The open-source GNU Radio development kit is used for developing the software-defined radio baseband signal processing, as well as simulating the satellite and realistic channel impairments. The system performance at the end shows deviations of less than 1 dB with respect to the ideal performance and the Green Book standards specified by the Consultative Committee for Space Data Systems. © 2019 John Wiley & Sons, Ltd.		Mwakyanjala M.B., Nieto-Peroy C., Emami M.R., van de Beek J.	International Journal of Satellite Communications and Networking					Included	Included	new_screen			2						
55	Behave	Automation Support for Mobile App Quality Assurance – A Tool Landscape	Competitive pressure in app stores, as well as direct and transparent feedback of app store reviews have resulted in an increased demand for outstanding app quality and user experience. At the same time, reduced time-to-market, decreased budgets and time available for quality assurance, and careful user experience design have to be considered. In response, an enormous market for mobile app quality and user experience measurement tools has grown around the mobile app store ecosystems. Developers following lean and agile development approaches continuously produce new features and ready-to-ship software increments. In those settings, budgets for evaluation and familiarization into new tools are very limited. Currently there are alone more than 28 tools and frameworks for functional test automation and more than 16 different device clouds available. For most of the software developing companies, it is impossible to evaluate and test all of them. In this paper, we present a classification in order to help navigation through the mobile app quality tools landscape for easier selection and more targeted evaluation of tools.	Mobile Applications, Quality, Quality Assurance, User Experience	Braun, Susanne; Elberzhager, Frank; Holl, Konstantin	Procedia Computer Science					Excluded	Excluded	new_screen			2						
56	Behave	CIaaS - computational intelligence as a service with Athena	Computational Intelligence (CI) is a sub-branch of Artificial Intelligence (AI) that focus on studying adaptive mechanisms to enable intelligent behavior in complex environments. CI techniques have been successful in solving complex problems in many different knowledge areas. However, despite their usefulness, developing solutions based on CI techniques is not a trivial activity, since it involves the codification/adaptation of algorithms to specific context and problems. In this paper, we present and validate through a quasi-experiment a new paradigm to develop CI-based solutions using a more mature version of Athena (2.0): Computational Intelligence as a Service (CIaaS). Using this tool, both researchers and practitioners can design and evaluate CI-based solutions by dragging and dropping components in a visual environment, in a cloud-based platform. The results of the quasi-experiment suggest that our approach can help researchers to design and evaluate CI-based systems in a simple, reliable and fast way.	Computational intelligence, Tool, Visual programming	Oliveira, Pedro; Santos Neto, Pedro; Britto, Ricardo; Rabêlo, Ricardo; Braga, Ronyerison; Souza, Matheus	Computer Languages, Systems & Structures					Excluded	Excluded	new_screen			2						
57	Behave	Optimizing stock assessment workflows by applying software development methodology	Considering that stock assessment requires iterative work including exploratory calculations and discussion, efficiency in completing projects is the key to a successful contribution to stock management. However, if the production speed of each process of the project is inconsistent, a faster process may be worse than a slower process because a large amount of information produced by a faster process induces human error. To coordinate the production speed of each process, we applied software development methodology to the whole assessment project, including small important tasks such as scenario selection, debugging, and yearly updates. First, we established a continuously integrated (CI) document system that monitors project files and triggers report generation when they are updated. The system is composed of four cloud services: a code hosting service, a cloud computing service, cloud storage, and a website hosting service. Because of the CI document system, all the following iterative work was reflected in the report without creating any unused output. The workflow benefited not only from the collaboration but also from the maintainability of the project because work progress and the discussion remained visible for all collaborators. We discuss the effectiveness of a workflow by Lean manufacturing that allows us to focus on the essential problem of the assessment project.	Continuous integration, Lean manufacturing, Open science, Reproducible research	Hayashi, Akira; Ichinokawa, Momoko; Kinoshita, Junji; Manabe, Akihiro	Fisheries Research					Excluded	Excluded	new_screen			2						
58	Behave	Architecting with microservices: A systematic mapping study	Context A microservice architecture is composed of a set of small services, each running in its own process and communicating with lightweight mechanisms. Many aspects on architecting with microservices are still unexplored and existing research is still far from being crispy clear. Objective We aim at identifying, classifying, and evaluating the state of the art on architecting with microservices from the following perspectives: publication trends, focus of research, and potential for industrial adoption. Method We apply the systematic mapping methodology. We rigorously selected 103 primary studies and we defined and applied a classification framework to them for extracting key information for subsequent analysis. We synthesized the obtained data and produced a clear overview of the state of the art. Results This work contributes with (i) a classification framework for research studies on architecting with microservices, (ii) a systematic map of current research of the field, (iii) an evaluation of the potential for industrial adoption of research results, and (iv) a discussion of emerging findings and implications for future research. Conclusion This study provides a solid, rigorous, and replicable picture of the state of the art on architecting with microservices. Its results can benefit both researchers and practitioners of the field.	Microservices, Software architecture, Systematic mapping study	Di Francesco, Paolo; Lago, Patricia; Malavolta, Ivano	Journal of Systems and Software					Excluded	Excluded	new_screen			2						
59	Behave	Design from detail: Analyzing data from a global day of coderetreat	Context Coderetreats are reflective communities of practice, where participants congregate informally to apply their coding abilities to a clearly defined problem setting with the aim of developing their software design skills. One of these events is the global day of coderetreat (GDCR) involving more than two thousand software developers worldwide. Objective The GDCR provided an opportunity to explore the ways that the coderetreat activity is perceived by its participants as a medium for reflective practice, and to suggest ways that we can enhance the design of coderetreats for improving both the experience and learning outcomes. Method We conducted both quantitative and qualitative surveys from a number of participants in the GDCR to understand how software developers hone their craft in the context of a coderetreat. Results Our study indicates that future coderetreats, particularly those that are likely to attract less experienced developers, should consider providing more structural scaffolding to the initial processes of test driven development. Conclusion We believe that all coderetreats should more explicitly encourage practice and reflection on the four elements of simple design. We suggest a more sustained approach throughout the coderetreat with provision of more structural scaffolding. Accordingly, we have derived a set of recommended practices to make the coderetreat more effective for less experienced developers.	Global day of coderetreat, Survey, Simple design, Test driven development, Legacy coderetreat	Parsons, David; Susnjak, Teo; Mathrani, Anuradha	Information and Software Technology					Excluded	Excluded	new_screen			2						
60	Behave	A multi-case study of agile requirements engineering and the use of test cases as requirements	Context It is an enigma that agile projects can succeed ‘without requirements’ when weak requirements engineering is a known cause for project failures. While agile development projects often manage well without extensive requirements test cases are commonly viewed as requirements and detailed requirements are documented as test cases. Objective We have investigated this agile practice of using test cases as requirements to understand how test cases can support the main requirements activities, and how this practice varies. Method We performed an iterative case study at three companies and collected data through 14 interviews and two focus groups. Results The use of test cases as requirements poses both benefits and challenges when eliciting, validating, verifying, and managing requirements, and when used as a documented agreement. We have identified five variants of the test-cases-as-requirements practice, namely de facto, behaviour-driven, story-test driven, stand-alone strict and stand-alone manual for which the application of the practice varies concerning the time frame of requirements documentation, the requirements format, the extent to which the test cases are a machine executable specification and the use of tools which provide specific support for the practice of using test cases as requirements. Conclusions The findings provide empirical insight into how agile development projects manage and communicate requirements. The identified variants of the practice of using test cases as requirements can be used to perform in-depth investigations into agile requirements engineering. Practitioners can use the provided recommendations as a guide in designing and improving their agile requirements practices based on project characteristics such as number of stakeholders and rate of change. © 2016 Elsevier B.V.		Bjarnason E., Unterkalmsteiner M., Borg M., Engström E.	Information and Software Technology					Excluded	Excluded	new_screen			2						
61	Behave	NLP-assisted software testing: A systematic mapping of the literature	Context To reduce manual effort of extracting test cases from natural-language requirements, many approaches based on Natural Language Processing (NLP) have been proposed in the literature. Given the large amount of approaches in this area, and since many practitioners are eager to utilize such techniques, it is important to synthesize and provide an overview of the state-of-the-art in this area. Objective Our objective is to summarize the state-of-the-art in NLP-assisted software testing which could benefit practitioners to potentially utilize those NLP-based techniques. Moreover, this can benefit researchers in providing an overview of the research landscape. Method To address the above need, we conducted a survey in the form of a systematic literature mapping (classification). After compiling an initial pool of 95 papers, we conducted a systematic voting, and our final pool included 67 technical papers. Results This review paper provides an overview of the contribution types presented in the papers, types of NLP approaches used to assist software testing, types of required input requirements, and a review of tool support in this area. Some key results we have detected are: (1) only four of the 38 tools (11%) presented in the papers are available for download; (2) a larger ratio of the papers (30 of 67) provided a shallow exposure to the NLP aspects (almost no details). Conclusion This paper would benefit both practitioners and researchers by serving as an “index” to the body of knowledge in this area. The results could help practitioners utilizing the existing NLP-based techniques; this in turn reduces the cost of test-case design and decreases the amount of human resources spent on test activities. After sharing this review with some of our industrial collaborators, initial insights show that this review can indeed be useful and beneficial to practitioners.	Software testing, Natural Language Processing (NLP), Systematic literature mapping, Systematic literature review	Garousi, Vahid; Bauer, Sara; Felderer, Michael	Information and Software Technology					Excluded	Excluded	new_screen			2						
62	Behave	Speed up BDD for Safety Verification in Agile Development: A Partially Replicated Controlled Experiment	Context: Agile development has aroused interest in developing safety-critical systems. Problem statement: However, an increasingly changing architecture makes traditional safety assurance, especially safety analysis and verification, difficult to work. Recently, we proposed STPA-BDD (System-Theoretic Process Analysis-Behaviour Driven Development) for safety analysis and verification in agile development. It showed a good communication effectiveness in a controlled experiment with 44 undergraduate students. However, productivity, test thoroughness and fault detection effectiveness show no statistically significant difference in comparison with UAT (User Acceptance Testing). Objective: In this article, we aim to speed up STPA-BDD through improving productivity, test thoroughness and fault detection effectiveness of STPA-BDD. We develop a semi-automated tool to speed up BDD for safety verification. Method: We evaluate the semi-automated tool concerning productivity, test thoroughness and fault detection effectiveness in a replicated experiment with 11 additional undergraduate students by comparing them with the results from 22 students in the original experiment. Results: The results turn out that productivity is more than 7 times greater, while test thoroughness is more than 1.5 times greater and fault detection effectiveness is more than 2 times greater by using this semi-automated tool than without using it. Conclusion: BDD for safety verification has beed sped up by using this semi-automated tool. Using professionals instead of students as subjects might provide a clearer impact.	agile development; safety verification; controlled experiment	Wang, Yang; Degutis, Daniel Ryan; Wagner, Stefan	Proceedings of the 19th International Conference on Agile Software Development: Companion					Included	Included	new_screen			2						
63	Behave	Combining STPA and BDD for safety analysis and verification in agile development: A controlled experiment	Context: Agile development is in widespread use, even in safety-critical domains. Motivation: However, there is a lack of an appropriate safety analysis and verification method in agile development. Objective: In this paper, we investigate the use of Behavior Driven Development (BDD) instead of standard User Acceptance Testing (UAT) for safety verification with System-Theoretic Process Analysis (STPA) for safety analysis in agile development. Method: We evaluate the effect of this combination in a controlled experiment with 44 students in terms of productivity, test thoroughness, fault detection effectiveness and communication effectiveness. Results: The results show that BDD is more effective for safety verification regarding the impact on communication effectiveness than standard UAT, whereas productivity, test thoroughness and fault detection effectiveness show no statistically significant difference in our controlled experiment. Conclusion: The combination of BDD and STPA seems promising with an enhancement on communication, but its impact needs more research. © The Author(s) 2018.		Wang Y., Wagner S.	Lecture Notes in Business Information Processing					Included	Included	new_screen			2						
64	Behave	Is business domain language support beneficial for creating test case specifications: A controlled experiment	Context: Behavior Driven Development (BDD), widely used in modern software development, enables easy creation of acceptance test case specifications and serves as a communication basis between business- and technical-oriented stakeholders. BDD is largely facilitated through simple domain specific languages (DSL) and usually restricted to technical test domain concepts. Integrating business domain concepts to implement a ubiquitous language for all members of the development team is an appealing test language improvement issue. But the integration of business domain concepts into BDD toolkits has so far not been investigated. Objective: The objective of the study presented in this paper is to examine whether supporting the ubiquitous language features inside a DSL, by extending a DSL with business domain concepts, is beneficial over using a DSL without those concepts. In the context of the study, benefit is measured in terms of perceived quality, creation time and length of the created test case specifications. In addition, we analyze if participants feel supported when using predefined business domain concepts. Method: We investigate the creation of test case specifications, similar to BDD, in a controlled student experiment performed with graduate students based on a novel platform for DSL experimentation. The experiment was carried out by two groups, each solving a similar comparable test case, one with the simple DSL, the other one with the DSL that includes business domain concepts. A crossover design was chosen for evaluating the perceived quality of the resulting specifications. Results: Our experiment indicates that a business domain aware language allows significant faster creation of documents without lowering the perceived quality. Subjects felt better supported by the DSL with business concepts. Conclusion: Based on our findings we propose that existing BDD toolkits could be further improved by integrating business domain concepts.	Domain Specific Languages (DSL), Behavior driven development, Controlled experiment, Software testing, Student experiment	Häser, Florian; Felderer, Michael; Breu, Ruth	Information and Software Technology					Included	Included	new_screen			2						
65	Behave	Supporting refactoring of BDD specifications—An empirical study	Context: Behavior-driven development (BDD) is a variant of test-driven development where specifications are described in a structured domain-specific natural language. Although refactoring is a crucial activity of BDD, little research is available on the topic. Objective: To support practitioners in refactoring BDD specifications by (1) proposing semi-automated approaches to identify refactoring candidates; (2) defining refactoring techniques for BDD specifications; and (3) evaluating the proposed identification approaches in an industry context. Method: Using Action Research, we have developed an approach for identifying refactoring candidates in BDD specifications based on two measures of similarity and applied the approach in two projects of a large software organization. The accuracy of the measures for identifying refactoring candidates was then evaluated against an approach based on machine learning and a manual approach based on practitioner perception. Results: We proposed two measures of similarity to support the identification of refactoring candidates in a BDD specification base; (1) normalized compression similarity (NCS) and (2) similarity ratio (SR). A semi-automated approach based on NCS and SR was developed and applied to two industrial cases to identify refactoring candidates. Our results show that our approach can identify candidates for refactoring 6o times faster than a manual approach. Our results furthermore showed that our measures accurately identified refactoring candidates compared with a manual identification by software practitioners and outperformed an ML-based text classification approach. We also described four types of refactoring techniques applicable to BDD specifications; merging candidates, restructuring candidates, deleting duplicates, and renaming specification titles. Conclusion: Our results show that NCS and SR can help practitioners in accurately identifying BDD specifications that are suitable candidates for refactoring, which also decreases the time for identifying refactoring candidates.	Refactoring, Normalized Compression Distance (NCD), Normalized Compression Similarity (NCS), Reuse, Similarity ratio (SR), BDD, Behavior-driven development, Specifications, Testing	Irshad, Mohsin; Börstler, Jürgen; Petersen, Kai	Information and Software Technology					Excluded	Excluded	new_screen			2						
66	Behave	B-Refactoring: Automatic test code refactoring to improve dynamic analysis	Context: Developers design test suites to verify that software meets its expected behaviors. Many dynamic analysis techniques are performed on the exploitation of execution traces from test cases. In practice, one test case may imply various behaviors. However, the execution of a test case only yields one trace, which can hide the others. Objective: In this article, we propose a new technique of test code refactoring, called B-Refactoring. The idea behind B-Refactoring is to split a test case into small test fragments, which cover a simpler part of the control flow to provide better support for dynamic analysis. Method: For a given dynamic analysis technique, B-Refactoring monitors the execution of test cases and constructs small test cases without loss of the testability. We apply B-Refactoring to assist two existing analysis tasks: automatic repair of if-condition bugs and automatic analysis of exception contracts. Results: Experimental results show that B-Refactoring can effectively improve the execution traces of the test suite. Real-world bugs that could not be previously fixed with the original test suites are fixed after applying B-Refactoring; meanwhile, exception contracts are better verified via applying B-Refactoring to original test suites. Conclusions: We conclude that applying B-Refactoring improves the execution traces of test cases for dynamic analysis. This improvement can enhance existing dynamic analysis tasks.		Xuan, Jifeng; Cornu, Benoit; Martinez, Matias; Baudry, Benoit; Seinturier, Lionel; Monperrus, Martin	Information and Software Technology					Excluded	Excluded	new_screen			2						
67	Behave	Adapting Behavior Driven Development (BDD) for large-scale software systems	Context: Large-scale software projects require interaction between many stakeholders. Behavior-driven development (BDD) facilitates collaboration between stakeholders, and an adapted BDD process can help improve cooperation in a large-scale project. Objective: The objective of this study is to propose and empirically evaluate a BDD based process adapted for large-scale projects. Method: A technology transfer model was used to propose a BDD based process for large-scale projects. We conducted six workshop sessions to understand the challenges and benefits of BDD. Later, an industrial evaluation was performed for the process with the help of practitioners. Results: From our investigations, understanding of a business aspect of requirements, their improved quality, a guide to system-level use-cases, reuse of artifacts, and help for test organization are found as benefits of BDD. Practitioners identified the following challenges: specification and ownership of behaviors, adoption of new tools, the software projects’ scale, and versioning of behaviors. We proposed a process to address these challenges and evaluated the process with the help of practitioners. Conclusion: The evaluation proved that BDD could be adapted and used to facilitate interaction in large-scale software projects in the software industry. The feedback from the practitioners helped in improving the proposed process.	Behavior-driven, Large-scale, BDD, Software processes, System of systems	Irshad, Mohsin; Britto, Ricardo; Petersen, Kai	Journal of Systems and Software					Included	Included	new_screen			2						
68	Behave	Design, monitoring, and testing of microservices systems: The practitioners’ perspective	Context: Microservices Architecture (MSA) has received significant attention in the software industry. However, little empirical evidence exists on design, monitoring, and testing of microservices systems. Objective: This research aims to gain a deep understanding of how microservices systems are designed, monitored, and tested in the industry. Methods: A mixed-methods study was conducted with 106 survey responses and 6 interviews from microservices practitioners. Results: The main findings are: (1) a combination of domain-driven design and business capability is the most used strategy to decompose an application into microservices, (2) over half of the participants used architecture evaluation and architecture implementation when designing microservices systems, (3) API gateway and Backend for frontend patterns are the most used MSA patterns, (4) resource usage and load balancing as monitoring metrics, log management and exception tracking as monitoring practices are widely used, (5) unit and end-to-end testing are the most used testing strategies, and (6) the complexity of microservices systems poses challenges for their design, monitoring, and testing, for which there are no dedicated solutions. Conclusions: Our findings reveal that more research is needed to (1) deal with microservices complexity at the design level, (2) handle security in microservices systems, and (3) address the monitoring and testing challenges through dedicated solutions.	Microservices architecture, Design, Monitoring, Testing, Industrial survey	Waseem, Muhammad; Liang, Peng; Shahin, Mojtaba; Di Salle, Amleto; Márquez, Gastón	Journal of Systems and Software					Excluded	Excluded	new_screen			2						
69	Behave	Big Data analytics in Agile software development: A systematic mapping study	Context: Over the last decade, Agile methods have changed the software development process in an unparalleled way and with the increasing popularity of Big Data, optimizing development cycles through data analytics is becoming a commodity. Objective: Although a myriad of research exists on software analytics as well as on Agile software development (ASD) practice on itself, there exists no systematic overview of the research done on ASD from a data analytics perspective. Therefore, the objective of this work is to make progress by linking ASD with Big Data analytics (BDA). Method: As the primary method to find relevant literature on the topic, we performed manual search and snowballing on papers published between 2011 and 2019. Results: In total, 88 primary studies were selected and analyzed. Our results show that BDA is employed throughout the whole ASD lifecycle. The results reveal that data-driven software development is focused on the following areas: code repository analytics, defects/bug fixing, testing, project management analytics, and application usage analytics. Conclusions: As BDA and ASD are fast-developing areas, improving the productivity of software development teams is one of the most important objectives BDA is facing in the industry. This study provides scholars with information about the state of software analytics research and the current trends as well as applications in the business environment. Whereas, thanks to this literature review, practitioners should be able to understand better how to obtain actionable insights from their software artifacts and on which aspects of data analytics to focus when investing in such initiatives.	Agile software development, Software analytics, Data analytics, Machine learning, Artificial intelligence, Literature review	Biesialska, Katarzyna; Franch, Xavier; Muntés-Mulero, Victor	Information and Software Technology					Excluded	Excluded	new_screen			2						
70	Behave	Documentation of Quality Requirements in Agile Software Development	Context: Quality requirements (QRs) have a significant role in the success of software projects. In agile software development (ASD), where working software is valued over comprehensive documentation, QRs are often under-specified or not documented. Consequently, they may be handled improperly and result in degraded software quality and increased maintenance costs. Investigating the documentation of QRs in ASD, would provide evidence on existing practices, tools and aspects considered in ASD that other practitioners might utilize to improve documentation and management of QRs in ASD. Although there are some studies examining documentation in ASD, those that specifically investigate the documentation of QRs in depth are lacking.Method: we conducted a multiple case study by interviewing 15 practitioners of four ASD cases, to provide empirical evidence on documentation of QRs in ASD. We also run workshops with two of the cases, to identify important aspects that ASD practitioners consider when documenting QRs in requirements management repositories.Result and conclusions: ASD companies approach documentation of QRs to fit the needs of their context. They used tools, backlogs, iterative prototypes, and artifacts such as epic, and stories to document QRs, or utilized face-face communication without documenting QRs. We observed that documentation of QRs in ASD is affected by factors such as context (e.g. product domain, and size) and the experience of practitioners. Some tools used to document QRs also enhanced customer collaboration, enabling customers report and document QRs. Aspects such as levels of abstraction, the traceability of QRs, optimal details of information of QRs and verification and validation are deemed important when documenting QRs in ASD requirements management repositories.	documentation; agile software development; non-functional requirements; Quality requirement	Behutiye, Woubshet; Seppänen, Pertti; Rodríguez, Pilar; Oivo, Markku	Proceedings of the Evaluation and Assessment in Software Engineering					Excluded	Excluded	new_screen			2						
71	Behave	Improving the delivery cycle: A multiple-case study of the toolchains in Finnish software intensive enterprises	Context: Software companies seek to gain benefit from agile development approaches in order to meet evolving market needs without losing their innovative edge. Agile practices emphasize frequent releases with the help of an automated toolchain from code to delivery. Objective: We investigate, which tools are used in software delivery, what are the reasons omitting certain parts of the toolchain and what implications toolchains have on how rapidly software gets delivered to customers. Method: We present a multiple-case study of the toolchains currently in use in Finnish software-intensive organizations interested in improving their delivery frequency. We conducted qualitative semi-structured interviews in 18 case organizations from various software domains. The interviewees were key representatives of their organization, considering delivery activities. Results: Commodity tools, such as version control and continuous integration, were used in almost every organization. Modestly used tools, such as UI testing and performance testing, were more distinctly missing from some organizations. Uncommon tools, such as artifact repository and acceptance testing, were used only in a minority of the organizations. Tool usage is affected by the state of current workflows, manual work and relevancy of tools. Organizations whose toolchains were more automated and contained fewer manual steps were able to deploy software more rapidly. Conclusions: There is variety in the need for tool support in different development steps as there are domain-specific differences in the goals of the case organizations. Still, a well-founded toolchain supports speedy delivery of new software.	Continuous deployment, Continuous delivery, Software development tools, Deployment pipeline, Agile software development	Mäkinen, Simo; Leppänen, Marko; Kilamo, Terhi; Mattila, Anna-Liisa; Laukkanen, Eero; Pagels, Max; Männistö, Tomi	Information and Software Technology					Excluded	Excluded	new_screen			2						
72	Behave	Demystifying the adoption of behavior-driven development in open source projects	Context:Behavior-Driven Development (BDD) features the capability, through appropriate domain-specific languages, of specifying acceptance test cases and making them executable. The availability of frameworks such as Cucumber or RSpec makes the application of BDD possible in practice. However, it is unclear to what extent developers use such frameworks, and whether they use them for actually performing BDD, or, instead, for other purposes such as unit testing. Objective:In this paper, we conduct an empirical investigation about the use of BDD tools in open source, and how, when a BDD tool is in place, BDD specifications co-evolve with source code. Method:Our investigation includes three different phases: (i) a large-scale analysis to understand the extent to which BDD frameworks are used in 50,000 popular open-source projects written in five programming languages; (ii) a study on the co-evolution of scenarios, fixtures and production code in a sample of 20 Ruby projects, through the Granger’s causality test, and (iii) a survey with 31 developers to understand how they use BDD frameworks. Results:Results of the study indicate that  ≃  27% of the sampled projects use BDD frameworks, with a prevalence in Ruby projects (68%). In about 37% of the cases, we found a co-evolution between scenarios/fixtures and production code. Specifically, changes to scenarios and fixtures often happen together or after changes to source code. Moreover, survey respondents indicate that, while they understand the intended purpose of BDD frameworks, most of them write tests while/after coding rather than strictly applying BDD. Conclusions:Even if the BDD frameworks usage is widespread among open source projects, in many cases they are used for different purposes such as unit testing activities. This mainly happens because developers felt BDD remains quite effort-prone, and its application goes beyond the simple adoption of a BDD framework.	Behavior-driven development, Acceptance testing, Empirical study, Co-evolution	Zampetti, Fiorella; Di Sorbo, Andrea; Visaggio, Corrado Aaron; Canfora, Gerardo; Di Penta, Massimiliano	Information and Software Technology					Included	Included	new_screen			2						
73	Behave	A Multi-Case Study of Agile Requirements Engineering and the Use of Test Cases as Requirements	ContextIt is an enigma that agile projects can succeed 'without requirements' when weak requirements engineering is a known cause for project failures. While agile development projects often manage well without extensive requirements test cases are commonly viewed as requirements and detailed requirements are documented as test cases. ObjectiveWe have investigated this agile practice of using test cases as requirements to understand how test cases can support the main requirements activities, and how this practice varies. MethodWe performed an iterative case study at three companies and collected data through 14 interviews and two focus groups. ResultsThe use of test cases as requirements poses both benefits and challenges when eliciting, validating, verifying, and managing requirements, and when used as a documented agreement. We have identified five variants of the test-cases-as-requirements practice, namely de facto, behaviour-driven, story-test driven, stand-alone strict and stand-alone manual for which the application of the practice varies concerning the time frame of requirements documentation, the requirements format, the extent to which the test cases are a machine executable specification and the use of tools which provide specific support for the practice of using test cases as requirements. ConclusionsThe findings provide empirical insight into how agile development projects manage and communicate requirements. The identified variants of the practice of using test cases as requirements can be used to perform in-depth investigations into agile requirements engineering. Practitioners can use the provided recommendations as a guide in designing and improving their agile requirements practices based on project characteristics such as number of stakeholders and rate of change.	Acceptance test; Agile development; Behaviour-driven development; Case study; Empirical software engineering; Requirements; Test-driven development; Test-first development; Testing	Bjarnason, Elizabeth; Unterkalmsteiner, Michael; Borg, Markus; Engström, Emelie	Inf. Softw. Technol.					Included	Included	new_screen			2						
74	Behave	Continuous Delivery: Overcoming adoption challenges	Continuous Delivery (CD) is a relatively new software development approach. Companies that have adopted CD have reported significant benefits. Motivated by these benefits, many companies would like to adopt CD. However, adopting CD can be very challenging for a number of reasons, such as obtaining buy-in from a wide range of stakeholders whose goals may seemingly be different from—or even conflict with—our own; gaining sustained support in a dynamic complex enterprise environment; maintaining an application development team's momentum when their application's migration to CD requires an additional strenuous effort over a long period of time; and so on. To help overcome the adoption challenges, I present six strategies: (1) selling CD as a painkiller; (2) establishing a dedicated team with multi-disciplinary members; (3) continuous delivery of continuous delivery; (4) starting with the easy but important applications; (5) visual CD pipeline skeleton; (6) expert drop. These strategies were derived from four years of experience in implementing CD at a multi-billion-euro company. Additionally, our experience led to the identification of eight further challenges for research. The information contributes toward building a body of knowledge for CD adoption.	Agile Software Development, Continuous Delivery, Continuous Deployment, Continuous Software Engineering, DevOps, Adoption	Chen, Lianping	Journal of Systems and Software					Excluded	Excluded	new_screen			2						
75	Behave	Transition towards Continuous Delivery in the Healthcare Domain	Continuous Delivery is meanwhile well-established in many parts of the software industry. In a transition towards continuous delivery in the healthcare domain, there are a number of additional challenges that should be addressed. We present how we have addressed some of these challenges and highlight some potential research topics that could be addressed in this space to make further progress in this important area. Although our focus is on the healthcare domain, the approach and the research topics are applicable also to a broad range of other application domains.	behavior-driven development; agile; continuous delivery; deployment pipeline; domain-driven design; pair-programming; test automation; test-driven development	Giorgi, Fabio; Paulisch, Frances	Proceedings of the 41st International Conference on Software Engineering: Software Engineering in Practice					Excluded	Excluded	new_screen			2						
76	Behave	Transition Towards Continuous Delivery in the Healthcare Domain	Continuous Delivery is meanwhile well-established in many parts of the software industry. In a transition towards continuous delivery in the healthcare domain, there are a number of additional challenges that should be addressed. We present how we have addressed some of these challenges and highlight some potential research topics that could be addressed in this space to make further progress in this important area. Although our focus is on the healthcare domain, the approach and the research topics are applicable also to a broad range of other application domains.	continuous delivery, agile, test-driven development, behavior-driven development, domain-driven design, test automation, pair-programming, deployment pipeline	F. Giorgi; F. Paulisch	2019 IEEE/ACM 41st International Conference on Software Engineering: Software Engineering in Practice (ICSE-SEIP)					Included	Included	new_screen			2						
77	Behave	Learning Behavior-Driven Development with JavaScript	Create powerful yet simple-to-code BDD test suites in JavaScript using the most popular tools in the community About This BookMaster the most popular testing tools in the JavaScript ecosystem, such as CucumberJS, Mocha, SinonJS, and more.Learn how Behavior-driven development can help you to write software that is more modular and has less defects.Avoid common mistakes in testing, simplify your test suites, and make them more maintainable using a very pragmatic approach to BDD.Who This Book Is ForTThis book is ideal for any JavaScript developer who is interested in producing well-tested code. If you have no prior experience with testing, Node.js, or any other tool, do not worry, as they will be explained from scratch. In Detail JavaScript is not only widely used to create attractive user interfaces for the Web, but with the advent of Node.js, it is also becoming a very popular and powerful language to write server-side applications. Using behavior-driven development and some common testing patterns and best practices, you will be able to avoid these traps.This book will show you how to do BDD in a practical way. We will start with a basic introduction of what BDD is and why the classical approach to testing has failed. Afterwards, we will dive directly into an introduction to Node.js, Mocha, and Sinon.JS. Finally, we will cover more advanced subjects such as how to write a fast and effective test suite for a RESTful web API, and how to do the same with a rich UI using Cucumber.js and Protractor.This book will give you great insight into how to architect your system to make it more testable and modular, but at the same time avoid the nightmare of abusing mock objects.		Amodeo, Enrique						Excluded	Excluded	new_screen			2						
78	Behave	SS-BDD: Automated Acceptance Testing for Spreadsheets	Current Spreadsheet Applications, such as Excel and Google Sheets, provide innumerous built-in facilities, including arithmetic, financial and statistical operations, as well as conditional expressions. Thus, users with little or no formal training in programming can use Spreadsheet Applications to implement their own Spreadsheet Programs. In fact, Spreadsheet Applications have become one of the most popular end-user programming environments nowadays. However, these applications also ease the introduction of errors in Spreadsheet Programs. Minor mistakes in formulas can mislead decisionmaking processes, resulting in uncountable costs to organizations. In general, end-user programmers are unaware of the potential risks that the uncontrolled construction of Spreadsheet Programs can cause. Therefore, a major focus of this paper is to offer an automated approach that makes programmers aware of introduced faults, so that they can build high quality Spreadsheet Programs. In particular, we propose SS-BDD, a framework for building and running Spreadsheets test scenarios, which relies on the use of Behavior Driven Development (BDD). We used SS-BDD to test three different Spreadsheet Programs. Our experience shows that SS-BDD can be used to build end-user friendly test scenarios which can achieve high fault-detection effectiveness.	Behavior Driven Development; Software Testing Tool; Spreadsheet Testing	Almeida, Lara; Cirilo, Elder; Barbosa, Eiji Adachi	Proceedings of the 1st Brazilian Symposium on Systematic and Automated Software Testing					Included	Included	new_screen			2						
79	Behave	BMT: Behavior Driven Development-based Metamorphic Testing for Autonomous Driving Models	Deep Neural Network based models are widely used for perception and control in autonomous driving. Recent work leverages metamorphic testing to improve defect detection but is limited to using only an equality-based metamorphic relation. Thus, it does not provide sufficient expressiveness for users to define custom metamorphic relations nor means to automatically generate meaningful inputs based on such expressive metamorphic relations that reflect real-world traffic behaviors. In this paper, we preliminarily design and evaluate a declarative Behaviour-Driven Development (BDD)-based metamorphic testing framework BMT, which enables domain experts to specify custom traffic behaviors-a car shall decelerate by x% when a bicycle is in front, etc. It then automatically translates a human-written behavior to a corresponding metamorphic relation and synthesizes meaningful test inputs using a variety of image and graphics processing techniques. Our preliminary evaluation shows that BMT can detect a significant number of erroneous predictions of three driving models for speed predictions. These detected erroneous predictions are manually examined and confirmed by six human judges as meaningful traffic violations. By automating test generation from custom behaviors, BMT enables experts to easily express domain-specific constraints and finds violations of such constraints.	Metamorphic Testing;Autonomous Driving;Deep Learning Models;Software Testing and Verification	Y. Deng; G. Lou; X. Zheng; T. Zhang; M. Kim; H. Liu; C. Wang; T. Y. Chen	2021 IEEE/ACM 6th International Workshop on Metamorphic Testing (MET)					Included	Included	new_screen			2						
80	Behave	3DEvent: A Framework Using Event-Sourcing Approach for 3D Web-Based Collaborative Design in P2P	Despite recent advances, especially in web-based Collaborative Virtual Environments (CVEs) using real-time 3D content, Web technology still requires an efficient way to distribute and stream large-scale 3D data. In this paper, we present 3DEvent: an event-driven framework to collaboratively manipulate predesigned 3D content in real-time on a web-based platform. This work introduces a new approach in achieving 3D object manipulation tasks during collaborative design stages using event-sourcing. Usually, a client-server architecture supports updates to the 3D environment state. Peer-to-peer (P2P) allows direct communication between teammates reducing response times during collaboration and decreasing server load, reducing the costs of providers. 3DEvent enables P2P-assisted delivery of 3D dynamic content in a web browser via WebRTC. By combining concepts from distributed event-processing and mesh-processing, 3D independent rendering and event-based synchronization, we present 3DEvent framework and potential uses associated that support history-aware 3D applications into a unified distributed processing solution for 3D web-based CVEs.	collaborative manipulation; distributed application; event-driven architecture; Web 3D; WebRTC	Desprat, Caroline; Jessel, Jean-Pierre; Luga, Hervé	Proceedings of the 21st International Conference on Web3D Technology					Excluded	Excluded	new_screen			2						
81	Behave	Test-Driven Development of Relational Databases	Developers can use a test-driven development with database schema just as they use it with application code. Implementing test-driven database development (TDDD) involves three relatively simple steps: database refactoring, database regression testing, and continuous database integration. In database refactoring, developers make a simple change to a database to improve the design without changing its semantics. In database regression testing, they run a comprehensive test suite that validates the database regularly-ideally, whenever developers change the database schema or access the database in a different way. In continuous database integration, developers rebuild and retest the database schema whenever it changes. From a technical viewpoint, TDDD is straightforward. However, cultural challenges can make it difficult to adopt.	BDD; behavior-driven development; test-driven development; database refactoring; database testing; relational database; TDD; test-driven database design	Ambler, Scott W.	IEEE Softw.					Excluded	Excluded	new_screen			2						
82	Behave	Automatic production of end user documentation for DSLs	Domain-specific languages (DSL) are developed for answering specific problems by leveraging the expertise of domain stakeholders. The development of DSLs requires a significant software engineering effort: editors, code generators, etc, must be developed to make a DSL usable. Documenting a DSL is also a major and time-consuming task required to promote it and address its learning curve. Recent research work in software language engineering focus on easing the development of DSLs. This work focuses on easing the production of documentation of textual DSLs. The API documentation domain identified challenges we adapted to DSL documentation. Based on these challenges we propose a model-driven approach that relies on DSL artifacts to extract information required to build documentation. Our implementation, called Docywood, targets two platforms: Markdown documentation for static web sites and Xtext code fragments for live documentation while modeling. We used Docywood on two DSLs, namely ThingML and Target Platform Definition. Feedback from end users and language designers exhibits qualitative benefits of the proposal with regard to the DSL documentation challenges. End user experiments conducted on ThingML and Target Platform Definition show benefits on the correctness of the created models when using Docywood on ThingML.	Software documentation, Domain-specific language, Model slicing	Le Moulec, Gwendal; Blouin, Arnaud; Gouranton, Valérie; Arnaldi, Bruno	Computer Languages, Systems & Structures					Excluded	Excluded	new_screen			2						
83	Behave	A Process for Evidence-Based Engineering of Domain-Specific Languages	Domain-specific languages (DSLs) are mainly designed ad-hoc and gut feeling resulting in languages that are often not well suited for their users and engineers. In this paper we develop a process for evidence-based language engineering to design domain-specific languages based on empirical evidence to support decision in language engineering. The developed process comprises an iterative execution of the phases DSL engineering, issue identification, data collection and evidence appraisal. We exemplify the concept by designing a DSL for Gherkin, a language test-driven acceptance testing in Xtext. The required evidence is derived by mining and analyzing all GitHub projects until July 1, 2017 that apply Gherkin.	domain-specific languages; DSL engineering; empirical research; evidence-based software engineering; repository mining	Felderer, Michael; Jeschko, Fabian	Proceedings of the 22nd International Conference on Evaluation and Assessment in Software Engineering 2018					Excluded	Excluded	new_screen			2						
84	Behave	Reproducing Failures Based on Semiformal Failure Scenario Descriptions	Due to the increasing size and complexity of software systems, it becomes hard to test these systems exhaustively. As a result, some faults can be left undetected. Undetected faults can lead to failures in deployed systems. Such failures are usually reported by the users from the field or test engineers back to developers. It requires considerable time and effort to analyze and reproduce the reported failures because their descriptions are not always complete, structured and formal. In this paper, we introduce a novel approach for automatically reproducing failures to aid their debugging. Our approach relies on semi-structured failure scenario descriptions that employ a set of keywords. These descriptions are preprocessed and mapped to a set of predefined test case templates with valid input sets. Then, test cases are generated and executed to reproduce the reported failure scenarios. The approach is evaluated with an industrial case study performed in a company from the telecommunications domain. Several failures were successfully reproduced. The approach is also adopted in the quality assurance process of the company. After one-time preparation of reusable test case templates and training of test engineers, 24.9 % of the reported failures (and 40 % of those that were manually reproducible) could be reproduced without any manual effort.	Behavior-driven development; Automated test case generation; Failure reproduction; Industrial case study	Karagöz, Gün; Sözer, Hasan	Software Quality Journal					Included	Included	new_screen			2						
85	Behave	Behaviour-driven requirements engineering for agile product line engineering	Due to the need of the software development community to integrate the flexibility and the high responsiveness of agile software development with the economic advantages, of reuse and mass customisation, offered by product lines, agile product line engineering has been gaining a momentum of attention from both researchers and practitioners. Developing and managing the different requirements engineering phases of product lines present is a dilemma that the efforts done in the literature was not able to effectively and efficiently resolve. To realise the full potential of agile product line engineering in practice, a complete, consistent, correct, and unambiguous user requirements must be produced without investing that huge amount of time in the upfront domain engineering phase of a traditional software product line. In this proposal, a behaviour-driven cloud-based framework is introduced to develop and maintain software product lines in an agile-based environment. The approach relies on upfront automated testing to derive and manage core assets and variations of an agile-based software product line. The model is validated through an empirical study and the preliminary results are very promising. © 2019 IEEE.		Elshandidy H.	Proceedings of the IEEE International Conference on Requirements Engineering					Included	Included	new_screen			2						
86	Behave	From Requirements to Source Code: A Model-Driven Engineering Approach for RESTful Web Services	During the last few years, the REST architectural style has drastically changed the way web services are developed. Due to its transparent resource-oriented model, the RESTful paradigm has been incorporated into several development frameworks that allow rapid development and aspire to automate parts of the development process. However, most of the frameworks lack automation of essential web service functionality, such as authentication or database searching, while the end product is usually not fully compliant to REST. Furthermore, most frameworks rely heavily on domain specific modeling and require developers to be familiar with the employed modeling technologies. In this paper, we present a Model-Driven Engineering (MDE) engine that supports fast design and implementation of web services with advanced functionality. Our engine provides a front-end interface that allows developers to design their envisioned system through software requirements in multimodal formats. Input in the form of textual requirements and graphical storyboards is analyzed using natural language processing techniques and semantics, to semi-automatically construct the input model for the MDE engine. The engine subsequently applies model-to-model transformations to produce a RESTful, ready-to-deploy web service. The procedure is traceable, ensuring that changes in software requirements propagate to the underlying software artefacts and models. Upon assessing our methodology through a case study and measuring the effort reduction of using our tools, we conclude that our system can be effective for the fast design and implementation of web services, while it allows easy wrapping of services that have been engineered with traditional methods to the MDE realm.	Automated Software Engineering; Model-Driven Engineering; RESTful web services; Software requirements	Zolotas, Christoforos; Diamantopoulos, Themistoklis; Chatzidimitriou, Kyriakos C.; Symeonidis, Andreas L.	Automated Software Engg.					Excluded	Excluded	new_screen			2						
87	Behave	Analysing Requirements Communication Using Use Case Specification and User Stories	Effective requirements communication is essential in software development projects due to the importance of understanding the requirements throughout the software development cycle. Software requirements can be specified in different formats, for instance using free texts or more structured forms, such as use cases and user stories used in Behavior Driven Development (BDD). We present a comparative analysis on the requirements communication dynamics using use case specification and user stories as the basis for mockups creation. We carried out an exploratory empirical study involving 16 students. The study comprised 3 steps: requirements specification, mockups construction, and inspection to investigate whether the mockups were in accordance with the specifications. Results show that there is no significant difference in using use case specification or user stories to communicate software requirements. Our findings suggest that different specification formats can provide similar results while communicating requirements, nonetheless the human factor should not be neglected.	Behavior Driven Development; experimental study; Requirements communication; requirements specification; use case	Oran, Ana Carolina; Nascimento, Elizamary; Santos, Gleison; Conte, Tayana	Proceedings of the 31st Brazilian Symposium on Software Engineering					Included	Included	new_screen			2						
88	Behave	Generating Testing Codes for Behavior-Driven Development from Problem Diagrams: A Tool-Based Approach	Eliciting requirements in their real-world contexts and creating and transforming visual models which can help lead to early designs of software is a challenging and time-consuming step in software engineering processes. In order to support the creation of these models and generate artifacts useful for software designs, we have developed the Problem-to-Design tool (PROD) based on Jackson's Problem Frames approach. The tool has been inspired by the work in the behavior-driven development community, which recommends that testing codes be generated as early as in the requirements engineering phase. The tool provides an open portal where multiple stakeholders can draw their own problem diagrams online, which can be used to generate use case narratives and testing codes for further behavior-driven development.	Problem Frames;problem progression;behavior-driven development	N. Gao; Z. Li	2016 IEEE 24th International Requirements Engineering Conference (RE)					Included	Included	new_screen			2						
89	Behave	Behavior-driven Development for Real-time Embedded Systems	Embedded systems are a class of computer systems that are typically characterized by a tight interaction with the physical environment. Various methodologies have been adopted for the development of such systems, ranging from traditional waterfall to modern agile techniques. One of the agile techniques that has recently attracted increasing attention is Behavior-Driven Development (BDD). BDD promotes the engagement of all stakeholders in every development iteration to minimize the misunderstanding between technical and non-technical stakeholders and, consequently, to speed up the development process and lower the costs. In this paper, we investigate the application of BDD to the development of embedded systems, especially focusing on the testing of timing requirements for real-time embedded software. In particular, we extend BDD with time-related concepts and propose an approach to generate test code for the verification of timing behavior of real-time embedded systems. Our approach offers more automation for the development of test code compared to existing BDD tools, thus minimizing the risk of timing faults and reducing development costs and time-to-market.		A. S. Nezhad; J. J. Lukkien; R. H. Mak	2018 IEEE 23rd International Conference on Emerging Technologies and Factory Automation (ETFA)					Included	Included	new_screen			2						
90	Behave	Benchmark Driven Framework for Development of Emotion Sensing Support Systems	Emotion sensing support system to assist human decision making during interview scenario is a developing research field. This paper presents a new framework for the development of emotion sensing support systems that is a complete, easily extendible, flexible, and configurable environment with intensive benchmark capabilities. The design of the framework was inspired by behavior-driven development, agile software development technique. It provides: 1) effective collaboration platform between technological and psychological researches, and 2) intensive benchmarking capabilities to test the performance of the entire system as well as individual algorithms.	behavior-driven development; affect; emotion detection; sensor fusion	Polikovsky, Senya; Quiros-Ramirez, Maria Alejandra; Kameda, Yoshinori; Ohta, Yuichi; Burgoon, Judee	Proceedings of the 2012 European Intelligence and Security Informatics Conference					Excluded	Excluded	new_screen			2						
91	Behave	Benchmark Driven Framework for Development of Emotion Sensing Support Systems	Emotion sensing support system to assist human decision making during interview scenario is a developing research field. This paper presents a new framework for the development of emotion sensing support systems that is a complete, easily extendible, flexible, and configurable environment with intensive benchmark capabilities. The design of the framework was inspired by behavior-driven development, agile software development technique. It provides: (1) effective collaboration platform between technological and psychological researches, and (2) intensive benchmarking capabilities to test the performance of the entire system as well as individual algorithms.	affect;emotion detection;behavior-driven development;sensor fusion	S. Polikovsky; M. A. Quiros-Ramirez; Y. Kameda; Y. Ohta; J. Burgoon	2012 European Intelligence and Security Informatics Conference					Excluded	Excluded	new_screen			2						
92	Behave	Beyond Page Objects: Testing Web Applications with State Objects: Use States to Drive Your Tests	End-to-end testing of Web applications typically involves tricky interactions with Web pages by means of a framework such as Selenium WebDriver. The recommended method for hiding such Web-page intricacies is to use page objects, but there are questions to answer first: Which page objects should you create when testing Web applications? What actions should you include in a page object? Which test scenarios should you specify, given your page objects?		van Deursen, Arie	Queue					Excluded	Excluded	new_screen			2						
93	Behave	Ensuring the Consistency Between User Requirements and Graphical User Interfaces: A Behavior-Based Automated Approach	Ensuring the consistency between Graphical User Interfaces (GUIs) and user requirements is a critical aspect of the design process since it is through the GUIs that users perceive the system and experience the available features in order to achieve their goals. This paper presents an approach based on Behavior-Driven Development (BDD) which employs an ontology in order to provide automated assessment for web GUIs. The approach has been evaluated by exploiting user requirements described by a group of experts in the flight tickets e-commerce domain. Such requirements gave rise to a set of User Stories that have been used to automatically assess the GUIs of an existing web system for booking business trips. The results have shown our approach was able to identify different types of inconsistencies in the set of GUIs analyzed, allowing to build an effective correspondence between user requirements and their representation on the GUI. © 2019, Springer Nature Switzerland AG.		Rocha Silva T., Winckler M., Trætteberg H.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)					Included	Included	new_screen			2						
94	Behave	A Practical Method for API Testing in the Context of Continuous Delivery and Behavior Driven Development	Enterprises are increasingly adopting an API-first approach to connect and expose software services. Saxo Bank is no exception to this. Crafting test suites for such APIs can seem straight forward due to the headless nature, but our experience shows that test suites often have two problems. The first problem is that execution of tests tends to fail and pass in seemingly nondeterministic ways (tests are flaky). The second problem is that functional coverage is not clearly documented. We have found that both problems stem from a lack of explicit focus on initial context (IC), a concept from behavior driven development. When a test is flaky it is often because actual IC in the test environment is not as required by the test. When functional coverage is not clear, it is most often because a systematic analysis involving IC was not performed. We propose a method for test analysis in which we include IC in the input space when analyzing functional coverage for an API, thereby including anything which can influence the outcome of test cases. Establishing IC is in general a hard problem. We have found that focus on the bounded context, a concept from domain driven design, of the system under test is a practical way to establish relevant IC. Experience with Saxo Bank's Open API shows that this method allows testers and developers to cooperate continuously, producing test plan documents which include the reasoning behind functional coverage. Explicit focus on IC in automated test case implementations turns flaky tests into tests which report on required IC in a test environment. The method easily generalizes to all levels of API tests.	Combinatorial Testing;API Testing;Behavior Driven Development;Domain Driven Design;Continuous Delivery;Industry;Application	B. E. Bennett	2021 IEEE International Conference on Software Testing, Verification and Validation Workshops (ICSTW)					Excluded	Excluded	new_screen			2						
95	Behave	Ensuring the Consistency between User Requirements and Task Models: A Behavior-Based Automated Approach	Evaluating and ensuring the consistency between user requirements and modeling artifacts is a long-time issue for model-based software design. Conflicts in requirements specifications can lead to many design errors and have a decisive impact on the quality of systems under development. This article presents an approach based on Behavior-Driven Development (BDD) to provide automated assessment for task models, which are intended to model the flow of user and system tasks in an interactive system. The approach has been evaluated by exploiting user requirements described by a group of experts in the domain of business trips. Such requirements gave rise to a set of BDD stories that have been used to automatically assess scenarios extracted from task models that were reengineered from an existing web system for booking business trips. The results have shown our approach, by performing a static analysis of the source files, was able to identify different types of inconsistencies between the user requirements and the set of task models analyzed.	automated requirements assessment; behavior-driven development (BDD); task models; user stories	Rocha Silva, Thiago; Winckler, Marco; Trætteberg, Hallvard	Proc. ACM Hum.-Comput. Interact.					Included	Included	new_screen			2						
96	Behave	Ensuring the Consistency between User Requirements and Task Models: A Behavior-Based Automated Approach	Evaluating and ensuring the consistency between user requirements and modeling artifacts is a long-time issue for model-based software design. Conflicts in requirements specifications can lead to many design errors and have a decisive impact on the quality of systems under development. This article presents an approach based on Behavior-Driven Development (BDD) to provide automated assessment for task models, which are intended to model the flow of user and system tasks in an interactive system. The approach has been evaluated by exploiting user requirements described by a group of experts in the domain of business trips. Such requirements gave rise to a set of BDD stories that have been used to automatically assess scenarios extracted from task models that were reengineered from an existing web system for booking business trips. The results have shown our approach, by performing a static analysis of the source files, was able to identify different types of inconsistencies between the user requirements and the set of task models analyzed. © 2020 ACM.		Rocha Silva T., Winckler M., Trætteberg H.	Proceedings of the ACM on Human-Computer Interaction					Included	Included	new_screen			2						
97	Behave	A Study of Value in Agile Software Development Organizations	Examines how Value is interpreted in 14 agile software development organizations.Data is collected from 13 project managers and 10 product owners.Sixteen categories of Value Aspects are identified and prioritized.The most important Value Aspect is Delivery process w.r.t. time.The most used activity to achieve Value is activities related to agile practices. The Agile manifesto focuses on the delivery of valuable software. In Lean, the principles emphasise value, where every activity that does not add value is seen as waste. Despite the strong focus on value, and that the primary critical success factor for software intensive product development lies in the value domain, no empirical study has investigated specifically what value is. This paper presents an empirical study that investigates how value is interpreted and prioritised, and how value is assured and measured. Data was collected through semi-structured interviews with 23 participants from 14 agile software development organisations. The contribution of this study is fourfold. First, it examines how value is perceived amongst agile software development organisations. Second, it compares the perceptions and priorities of the perceived values by domains and roles. Third, it includes an examination of what practices are used to achieve value in industry, and what hinders the achievement of value. Fourth, it characterises what measurements are used to assure, and evaluate value-creation activities.	Agile software development; Empirical; Value	Alahyari, Hiva; Berntsson Svensson, Richard; Gorschek, Tony	J. Syst. Softw.					Excluded	Excluded	new_screen			2						
98	Behave	Domain-specific scenarios for refinement-based methods	Formal methods use abstraction and rigorously verified refinement to manage the design of complex systems, ensuring that they satisfy important invariant properties. However, formal verification is not sufficient: models must also be tested to ensure that they behave according to the informal requirements and validated by domain experts who may not be expert in formal modelling. This can be satisfied by scenarios that complement the requirements specification. The model can be animated to check whether the scenario is feasible in the model and that the model reaches the states expected in the scenario. However, there are two problems with this approach. 1) The natural language used to describe the scenarios is often verbose, ambiguous and therefore difficult to understand; especially if the modeller is not a domain expert. 2) Provided scenarios are typically at the most concrete level corresponding to the full requirements and cannot be used until all the refinements have been completed in the model. We show by example how a precise and concise domain specific language can be used for writing these abstract scenarios in a style that can be easily understood by the domain expert (for validation purposes) as well as the modeller (for behavioural verification) and can be used as the persistence for automated tool support. We propose two alternative approaches to using scenarios during formal modelling: A method of refining scenarios before the model is refined so that the scenarios guide the modelling, and a method of abstracting scenarios from provided concrete ones so that they can be used to test early refinements of the model. We illustrate the two approaches on the ‘Tokeneer’ secure enclave example and the ERTMS/ETCS Hybrid Level 3 specification for railway controls. We base our approach on the Cucumber framework for scenarios and the Event-B modelling language and tool set. We have developed a new ‘Scenario Checker’ plugin to manage the animation of scenarios.11The example model and scenario scripts supporting this paper are openly available at https://doi.org/10.5258/SOTON/D1026.	Event-B, Cucumber, Validation, Domain specific language	Snook, Colin; Hoang, Thai Son; Dghaym, Dana; Fathabadi, Asieh Salehi; Butler, Michael	Journal of Systems Architecture					Excluded	Excluded	new_screen			2						
99	Behave	Behaviour-driven formal model development	Formal systems modelling offers a rigorous system-level analysis resulting in a precise and reliable specification. However, some issues remain: Modellers need to understand the requirements in order to formulate the models, formal verification may focus on safety properties rather than temporal behaviour, domain experts need to validate the final models to ensure they fit the needs of stakeholders. In this paper we discuss how the principles of Behaviour-Driven Development (BDD) can be applied to formal systems modelling and validation. We propose a process where manually authored scenarios are used initially to support the requirements and help the modeller. The same scenarios are used to verify behavioural properties of the model. The model is then mutated to automatically generate scenarios that have a more complete coverage than the manual ones. These automatically generated scenarios are used to animate the model in a final acceptance stage. For this acceptance stage, it is important that a domain expert decides whether or not the behaviour is useful. © Springer Nature Switzerland AG 2018.		Snook C., Hoang T.S., Dghyam D., Butler M., Fischer T., Schlick R., Wang K.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)					Included	Included	new_screen			2						
100	Behave	The Merb Way	Foy is a gifted writer and his descriptions of the philosophies that( impacted the design and implementation of Merb are definitely useful to( everyone affected by the changes in Rails 3. Obie Fernandez, Series Editor The Expert Guide to Building Merb Applications Thousands of Ruby and Rails developers are discovering the extraordinary scalability, agility, flexibility, and performance offered by the new Merb MVC framework. The Merb Way is the first comprehensive guide to using, extending, and deploying Merb. Like the bestseller The Rails Way (Addison-Wesley, 2008), this book can either be read cover-to-cover as a tutorial or used for modular coverage that makes it an ideal task reference. Foy Savas systematically covers everything developers need to know to build production-quality Merb applications, offering detailed code examples for jumpstarting virtually any project. Savas is not only involved in the Merb project as an open source contributor: He uses Merb every day as a professional developer. Drawing on his extensive practical expertise, he delves deeply into the Merb frameworks architecture and source code, revealing its elegance and offering powerful best practices for using it. To maximize this books practical value, he also covers the tools most widely used alongside Merb, including the DataMapper ORM, the RSpec tester (and associated behavior-driven development techniques), and several leading Merb plugins. The Merb Way will help you Master Merb innovations that will be incorporated into Rails 3 Understand the fundamentals of Merb development, one step at a time Use Merbs sophisticated application router to guide incoming requests Explore the Merb stack, master its configuration options, and dive into its internals Use Merb controllers to integrate application code, handle responses, and manage sessions, filters, and exceptions Build templates with both ERB (Erubis) and HAML Use the DataMapper ORM to represent object properties and behaviors Learn best practices for RESTful development with Merb Leverage Helpers to simplify many common development tasks Refactor code, encapsulate it in gems, and share it across multiple applications Customize the responses your application sends to each user Gain a deep, practical understanding of Merb plugins and extensibility Authenticate users with Merbs modular authentication plugin Configure, generate, describe, and test Merb mailers Use the merb-parts gem to create component-like regions on Web pages Cache content to relieve stress on Web servers Make the most of Behavior Driven Development and testing with RSpec		Savas, Foy						Excluded	Excluded	new_screen			2						
101	Behave	“BDD Assemble!”: A Paper-Based Game Proposal for Behavior Driven Development Design Learning	Game-based learning represents a promising alternative to teach computing in higher education. This paper presents “BDD Assemble!”, a paper-based game proposal for teaching Behavior Driven Development (BDD) competences. For this, the proposed game and the evaluation approach with software engineering students are described. As a result, a simple, interactive and colaborative game was provided, able to teach BDD concepts in a practical, competitive and fun way. © IFIP International Federation for Information Processing, 2019.		Sarinho V.T.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)					Excluded	Excluded	new_screen			2						
102	Behave	JavaScript Testing with Jasmine: JavaScript Behavior-Driven Development	Get a concise introduction to Jasmine, the popular behavior-driven testing framework for JavaScript. This practical guide shows you how to write unit tests with Jasmine that automatically check for bugs in your application. Learn how to write specifications for individual components, and then use those specs to test the code you write.Throughout the book, author Evan Hahn focuses primarily on methods for testing browser-based JavaScript applications, but youll also discover how to use Jasmine with CoffeeScript, Node.js, Ruby on Rails, and Ruby without Rails. You wont find a more in-depth source for Jasmine anywhere.Get an overview of both test-driven and behavior-driven development Write useful specs by determining what you need to testand what you dont Test the behavior of new and existing code against the specs you create Apply Jasmine matchers and discover how to build your own Organize code suites into groups and subgroups as your code becomes more complex Use a Jasmine spy in place of a function or an objectand learn why its valuable		Hahn, Evan						Excluded	Excluded	new_screen			2						
103	Behave	A real-life application of multi-agent systems for fault diagnosis in the provision of an Internet business service	Given that telecommunications networks are constantly growing in complexity and heterogeneity, management systems have to work with incomplete data, handle uncertain situations and deal with dynamic environments. In addition, the high competitiveness in the telecommunications market requires cost cutting and customer retention by providing reliable systems. Thus, improving fault diagnosis systems and reducing the mean time to repair with automatic systems is an important area of research for telecommunications companies. This paper presents a Fault Diagnosis Multi-Agent System (MAS) applied for the management of a business service of Telefónica Czech Republic. The proposed MAS is based on an extended Belief-Desire-Intention (BDI) model that combines heterogeneous reasoning processes, ontology-based reasoning and Bayesian reasoning. This hybrid diagnostic technique is described in detail in the paper. The system has been evaluated with data collected during one and a half years of system operation on a live network. The main benefits of the system have been a significant reduction in both the average incident solution time and the mean diagnosis time.	Network management, Agent, Bayesian network, Diagnosis, Uncertainty, BDI	Carrera, Álvaro; Iglesias, Carlos A.; García-Algarra, Javier; Kolařík, Dušan	Journal of Network and Computer Applications					Excluded	Excluded	new_screen			2						
104	Behave	Behavior-driven development (BDD) Cucumber Katalon for Automation GUI testing case CURA and Swag Labs	Graphical user interface (GUI) is widely used in software applications. About 50% of the application code is for GUI implementation. Because labor costs are high and demands for high-quality software are increasing, automation GUI testing will be a good investment for any software company. We will apply the Behavior-driven development (BDD) method for automation GUI testing with the Cucumber framework on the CURA and Swag Labs web applications. The BDD methodology used is based on the NLP (natural language program) concept. Where the information of semi-automatically produce a step definition and code framework. The scenarios are given on the natural language and then applied to Software Testing. Class diagrams and sequence diagrams are also applied to each represent a code framework automatically. The author uses Katalon Studio software. It was found that the results of the test case automation GUI testing on the CURA website with 210 steps passed, 3 step warnings with average responses times in the test case were 1.92 minutes. The results of the test case automation GUI testing on the Swag Labs web with 87 where 36 steps failed, 4 step warning and 44 step passed with an average responses times in the test case are 2,122 minutes.	Empirical Software Engineering;Software Testing Automation;GUI Testing;Behavior-driven Development;Cucumber	R. Broer Bahaweres; E. Oktaviani; L. Kesuma Wardhani; I. Hermadi; A. Suroso; I. Permana Solihin; Y. Arkeman	2020 International Conference on Informatics, Multimedia, Cyber and Information System (ICIMCIS)					Included	Included	new_screen			2						
105	Behave	Behaviour driven development for hardware design	Hardware verification requires a lot of effort. A recent study showed that on average, there are more verification engineers working on a project than design engineers. Hence, one of the biggest challenges in design and verification today is to find new ways to increase the productivity. For software development the agile methodology as an incremental approach has been proposed and is heavily used. Behavior Driven Development (BDD) as an agile technique additionally enables a direct link to natural language based testing. In this article, we show how BDD can be extended to make it viable for hardware design. In addition, we present a two-fold strategy which allows to specify textual acceptance tests and textual formal properties. Finally, this strategy is complemented by methods to generalize tests to properties, and to enhance design understanding by presenting debug and witness scenarios in natural language. © 2018 Information Processing Society of Japan.		Diepenbeck M., Kühne U., Soeken M., Grosse D., Drechsler R.	IPSJ Transactions on System LSI Design Methodology					Included	Included	new_screen			2						
106	Behave	Using acceptance tests to predict files changed by programming tasks	In a collaborative development context, conflicting code changes might compromise software quality and developers productivity. To reduce conflicts, one could avoid the parallel execution of potentially conflicting tasks. Although hopeful, this strategy is challenging because it relies on the prediction of the required file changes to complete a task. As predicting such file changes is hard, we investigate its feasibility for BDD (Behaviour-Driven Development) projects, which write automated acceptance tests before implementing features. We develop a tool that, for a given task, statically analyzes Cucumber tests and infers test-based interfaces (files that could be executed by the tests), approximating files that would be changed by the task. To assess the accuracy of this approximation, we measure precision and recall of test-based interfaces of 513 tasks from 18 Rails projects on GitHub. We also compare such interfaces with randomly defined interfaces, interfaces obtained by textual similarity of test specifications with past tasks, and interfaces computed by executing tests. Our results give evidence that, in the specific context of BDD, Cucumber tests might help to predict files changed by tasks. We find that the better the test coverage, the better the predictive power. A hybrid approach for computing test-based interfaces is promising.	Collaborative development, Task scheduling, Behaviour-driven development, File change prediction	Rocha, Thaís; Borba, Paulo; Santos, João Pedro	Journal of Systems and Software					Included	Included	new_screen			2						
107	Behave	Ensuring the Consistency Between User Requirements and GUI Prototypes: A Behavior-Based Automated Approach	In a user-centered design process, graphical user interface (GUI) prototypes may be seen as an important early artifact to design and validate user requirements before making strong commitments with a full-fledged version of the user interface. Ensuring the consistency of GUI prototypes with other representations of the user requirements is then a critical aspect of the design process. This paper presents an approach which extends Behavior-Driven Development (BDD) by employing an ontology in order to provide automated assessment for GUI prototypes as design artifacts. The approach has been evaluated by exploiting user requirements described by a group of experts in the flight tickets e-commerce domain. Such requirements gave rise to a set of User Stories that have been used to automatically check the consistency of Balsamiq prototypes which were reengineered from an existing web system for booking business trips. The results have shown our approach was able to identify different types of inconsistencies in the set of analyzed artifacts, allowing to build an effective correspondence between user requirements and their representation in GUI prototypes. © IFIP International Federation for Information Processing 2019.		Rocha Silva T., Winckler M., Trætteberg H.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)					Included	Included	new_screen			2						
108	Behave	Definition of a Behavior-Driven Model for Requirements Specification and Testing of Interactive Systems	In a user-centered development process, artifacts are aimed to evolve in iterative cycles until they meet users' requirements and then become the final product. Every cycle gives the opportunity to revise the design and to introduce new requirements which might affect the specification of artifacts that have been set in former development phases. Testing the consistency of multiple artifacts used to develop interactive systems every time that a new requirement is introduced it is a cumbersome and time consuming activity, especially if it should be done manually. For that we propose an approach based on Behavior-Driven Development (BDD) to support the automated assessment of artifacts along the development process of interactive systems. In order to prevent that test should be written to every type of artifact, we investigate the use of ontologies for specifying the test once and then run it in all artifacts sharing the ontological concepts.	Automated Requirements Checking;Behavior-Driven Development;Ontological Modeling;Prototyping;Multi-Artifact Testing	T. R. Silva	2016 IEEE 24th International Requirements Engineering Conference (RE)					Excluded	Excluded	new_screen			2						
109	Behave	Testing prototypes and final user interfaces through an ontological perspective for behavior-driven development	In a user-centered development process, prototypes evolve in iterative cycles until they meet users’ requirements and then become the final product. Every cycle gives the opportunity to revise the design and to introduce new requirements which might affect the specification of artifacts that have been set in former development phases. Testing the consistency of multiple artifacts used to develop interactive systems every time that a new requirement is introduced is a cumbersome activity, especially if it is done manually. This paper proposes an approach based on Behavior-Driven Development (BDD) to support the automated assessment of artifacts along the development process of interactive systems. The paper uses an ontology for specifying tests that can run over multiple artifacts sharing similar concepts. A case study testing Prototypes and Final User Interfaces is presented to demonstrate the feasibility of this approach in early phases of the design process, providing a continuous quality assurance of requirements, and helping clients and development teams to identify potential problems and inconsistencies before commitments with software implementation. © IFIP International Federation for Information Processing 2016.		Silva T.R., Hak J.-L., Winckler M.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)					Included	Included	new_screen			2						
110	Behave	A Domain Specific Test Language for Systems Integration	In avionic context, systems are complex, embedded, critical, reactive and real time. In this context, testing activities are predominant in a V development process. We propose to bring in some features coming from agile methods. System integration testing that means systems are tested individually and together in order to ensure that they all operate correctly. We focus on functional and system integration testing just before the ground testing phase. Nowadays, test procedures and test plans we studied are described in textual manner and are executed manually. We aim to provide a common specific language that improves communications for the team of test designers and between test designers and test performers. In the same manner as agile test frameworks, this language allows to structure the test procedures. Moreover, this language tends to facilitate the automatic execution of some parts of the procedures. We choose a domain specific language approach to design a first domain specific test language dedicated to networks system integration.	Domain Specific Language; Test procedure; Test system	Bussenot, Robin; Leblanc, Hervé; Percebois, Christian	Proceedings of the Scientific Workshop Proceedings of XP2016					Excluded	Excluded	new_screen			2						
111	Behave	Assisted Behavior Driven Development Using Natural Language Processing	In Behavior Driven Development (BDD), acceptance tests provide the starting point for the software design flow and serve as a basis for the communication between designers and stakeholders. In this agile software development technique, acceptance tests are written in natural language in order to ensure a common understanding between all members of the project. As a consequence, mapping the sentences to actual source code is the first step of the design flow, which is usually done manually.However, the scenarios described by the acceptance tests provide enough information in order to automatize the extraction of both the structure of the implementation and the test cases. In this work, we propose an assisted flow for BDD where the user enters into a dialog with the computer which suggests code pieces extracted from the sentences. For this purpose, natural language processing techniques are exploited. This allows for a semi-automatic transformation from acceptance tests to source code stubs and thus provides a first step towards an automatization of BDD.		Soeken, Mathias; Wille, Robert; Drechsler, Rolf	Proceedings of the 50th International Conference on Objects, Models, Components, Patterns					Included	Included	new_screen			2						
112	Behave	Maintaining behaviour driven development specifications: Challenges and opportunities	"In Behaviour-Driven Development (BDD) the behaviour of a software system is specified as a set of example interactions with the system using a ""Given-When-Then"" structure. These examples are expressed in high level domain-specific terms, and are executable. They thus act both as a specification of requirements and as tests that can verify whether the current system implementation provides the desired behaviour or not. This approach has many advantages but also presents some problems. When the number of examples grows, BDD specifications can become costly to maintain and extend. Some teams find that parts of the system are effectively frozen due to the challenges of finding and modifying the examples associated with them. We surveyed 75 BDD practitioners from 26 countries to understand the extent of BDD use, its benefits and challenges, and specifically the challenges of maintaining BDD specifications in practice. We found that BDD is in active use amongst respondents, and that the use of domain specific terms, improving communication among stakeholders, the executable nature of BDD specifications, and facilitating comprehension of code intentions are the main benefits of BDD. The results also showed that BDD specifications suffer the same maintenance challenges found in automated test suites more generally. We map the survey results to the literature, and propose 10 research opportunities in this area."	behaviour-driven development;test suite maintenance;test suite evolution	L. P. Binamungu; S. M. Embury; N. Konstantinou	2018 IEEE 25th International Conference on Software Analysis, Evolution and Reengineering (SANER)					Included	Included	new_screen			2						
113	Behave	Detecting duplicate examples in behaviour driven development specifications	In Behaviour-Driven Development (BDD), the behaviour of the software to be built is specified as a set of example interactions with the system, expressed using a “Given-When-Then” structure. The examples are written using customer language, and are readable by end-users. They are also executable, and act as tests that determine whether the implementation matches the desired behaviour or not. This approach can be effective in building a common understanding of the requirements, but it can also face problems. When the suites of examples grow large, they can be difficult and expensive to change. Duplication can creep in, and can be challenging to detect manually. Current tools for detecting duplication in code are also not effective for BDD examples. Moreover, human concerns of readability and clarity can rise. We present an approach for detecting duplication in BDD suites that is based around dynamic tracing, and describe an evaluation based on three open source systems.	behaviour-driven development;duplication detection;dynamic tracing	L. P. Binamungu; S. M. Embury; N. Konstantinou	2018 IEEE Workshop on Validation, Analysis and Evolution of Software Tests (VST)					Included	Included	new_screen			2						
114	Behave	Integrating Behavior Driven Development and Programming by Contract to Improve Correctness in Computer Programs	"In many professional development settings, Test Driven Development (TDD), and its evolutionary descendent, Behavior Driven Development (BDD) are increasingly being used to improve code quality and reducing error rates. While very valuable, they are considerably less rigorous than formal methodologies of program correctness via formal logic. A less rigorous methodology utilizing the ideas of formal methods but without requiring an actual full proof are also in use called ""Design by Contract"" (DBC) or ""Programming by Contract."" (PBC) This thesis will examine extending and combining the ideas behind TDD, BDD and DBC to improve the overall stability and quality of a system. It will examine using both TDD/BDD (hereinafter referred to as TDD) and PBC to enhance the quality of development throughout the software development life cycle, while aiding in the development and stabilization of sound architecture. A result of this examination is a tool that attempts to derive unit tests automatically by analyzing human written specifications for preconditions and post-conditions when coupled with data definitions. These results will be used to generate code to be run by a unit testing framework before deployment, either as part of a continuous integration environment or by individual developers. The tool will also attempt to generate wireframe classes implementing pre and post-conditions within the code and using runtime contract analysis to generate information when an exception occurs, thereby helping to automate verification of bug fixes. Ultimately, the tool produced would be useful in a non-academic environment as a utility to extend the benefit of design by contract combined with TDD to the agile space."		Schoeneman, Larry						Excluded	Excluded	new_screen			2						
115	Behave	Leveraging Natural-Language Requirements for Deriving Better Acceptance Criteria from Models	In many software and systems development projects, analysts specify requirements using a combination of modeling and natural language (NL). In such situations, systematic acceptance testing poses a challenge because defining the acceptance criteria (AC) to be met by the system under test has to account not only for the information in the (requirements) model but also that in the NL requirements. In other words, neither models nor NL requirements per se provide a complete picture of the information content relevant to AC. Our work in this paper is prompted by the observation that a reconciliation of the information content in NL requirements and models is necessary for obtaining precise AC. We perform such reconciliation by devising an approach that automatically extracts AC-related information from NL requirements and helps modelers enrich their model with the extracted information. An existing AC derivation technique is then applied to the model that has now been enriched by the information extracted from NL requirements.Using a real case study from the financial domain, we evaluate the usefulness of the AC-related model enrichments recommended by our approach. Our evaluation results are very promising: Over our case study system, a group of five domain experts found 89% of the recommended enrichments relevant to AC and yet absent from the original model (precision of 89%). Furthermore, the experts could not pinpoint any additional information in the NL requirements which was relevant to AC but which had not already been brought to their attention by our approach (recall of 100%).	acceptance criteria; gherkin; UML; acceptance testing; controlled natural language; requirements validation and verification	Veizaga, Alvaro; Alferez, Mauricio; Torre, Damiano; Sabetzadeh, Mehrdad; Briand, Lionel; Pitskhelauri, Elene	Proceedings of the 23rd ACM/IEEE International Conference on Model Driven Engineering Languages and Systems					Excluded	Excluded	new_screen			2						
116	Behave	Toward A Service Platform for Developing Smart Contracts on Blockchain in BDD and TDD Styles	In recent years, Blockchain technology has been highly valued, and the related applications have begun to be developed in large numbers. A smart contract is a software component encompass business logics and transactions that run on a blockchain. Thus, verifying whether the contract logics fully reflect the business requirements are one of the most important software engineering issues in blockchain application development. Currently, developing smart contracts is still a challenging task even for experienced programmers due to the lacking of an integrated tool for developing and testing. In response to this challenge, this paper presents a service platform that supports BDD-style (Behavior-Driven Development) smart contract development, testing, and deployment for the Ethereum-based blockchains. This platform focuses on providing and resolving the cross-cutting concerns across the life-cycle of smart contract development. The feasibility of this platform is shown by demonstrating how an application scenario, namely, loyalty points exchange, can be implemented using the proposed platform. Our experiences indicate that the burdens of developers when developing smart contracts can be effectively reduced and thus increases the quality of contracts.	Blockchain;Smart contract;Behavior-Driven Development;Test-Driven Development	C. Liao; C. Cheng; K. Chen; C. Lai; T. Chiu; C. Wu-Lee	2017 IEEE 10th Conference on Service-Oriented Computing and Applications (SOCA)					Included	Included	new_screen			2						
117	Behave	Proposing Regulatory-Driven Automated Test Suites for Electronic Health Record Systems	In regulated domains such as finance and health care, failure to comply with regulation can lead to financial, civil and criminal penalties. While systems vary from organization to organization, regulations apply across organizations. We propose the use of Behavior-Driven-Development (BDD) scenarios as the basis of an automated compliance test suite for standards such as regulation and interoperability. Such test suites could become a shared asset for use by all systems subject to these regulations and standards. Each system, then, need only create their own system-specific test driver code to automate their compliance checks. The goal of this research is to enable organizations to compare their systems to regulation in a repeatable and traceable way through the use of BDD. To evaluate our proposal, we developed an abbreviated HIPAA test suite and applied it to three open-source electronic health record systems. The scenarios covered all security behavior defined by the selected regulation. The system-specific test driver code covered all security behavior defined in the scenarios, and identified where the tested system lacked such behavior.	software engineering; behavior-driven-development; healthcare it; regulatory compliance; security; software testing	Morrison, Patrick; Holmgreen, Casper; Massey, Aaron; Williams, Laurie	Proceedings of the 5th International Workshop on Software Engineering in Health Care					Included	Included	new_screen			2						
118	Behave	Proposing Regulatory-Driven Automated Test Suites	In regulated domains such as finance and health care, failure to comply with regulation can lead to financial, civil and criminal penalties. While systems vary from organization to organization, the same regulations apply for all systems. As a result, efficiencies could be gained if the commonalities between systems could be captured in public, shared, test suites for regulations. We propose the use of Behavior-Driven-Development (BDD) technology to create these test suites. With BDD, desired system behavior with respect to regulatory requirements can be captured as constrained natural language 'scenarios'. The scenarios can then be automated through system-specific test drivers. The goal of this research is to enable organizations to compare their systems to regulation in a repeatable and traceable way through the use of BDD. To evaluate our approach, we developed seven scenarios based on the HITECH Act Meaningful Use (MU) regulations for healthcare. We then created system-specific code for three open-source electronic health record systems. We found that it was possible to create scenarios and system-specific code supporting scenario execution on three systems, that iTrust can be shown to be noncompliant, and that emergency access procedures are not defined clearly enough by the regulation to determine compliance or non-compliance.	Software Testing; Security; Software Engineering; Behavior-Driven-Development; Healthcare IT; Regulatory Compliance	Morrison, Patrick; Holmgreen, Casper; Massey, Aaron; Williams, Laurie	Proceedings of the 2013 Agile Conference					Included	Included	new_screen			2						
119	Behave	Combining IID with BDD to Enhance the Critical Quality of Security Functional Requirements	In software system, functional requirements are primary system requirements. Client cannot explicitly depicted security requirements and the development team is hard to understand security requirements, makes security requirements difficult to specific implant software system. In software system development process, security requirements often neglected and ignored. However, the cost of correcting security flaws in maintenance phase is over 100 times in requirements phase. Can't effectively improve the system security, enterprises loss is bound to continue to expand. In order to enhance the security of software system, this paper combines the popular software development methodology IID (Interactive and Incremental Development) with BDD (Behavior Driven Development), institutionalized requires functional requirements must be integrated into security requirements. And, using BDD process features to evaluate the major quality of security functional requirements. Timely identifies and modifies the quality defects of security functional requirements item, effectively enhance the security of software systems.	BDD; functional requirements; IID; security functional requirements; security requirements	Lai, Sen-Tarng; Leu, Fang-Yie; Chu, William Cheng-Chung	Proceedings of the 2014 Ninth International Conference on Broadband and Wireless Computing, Communication and Applications					Included	Included	new_screen			2						
120	Behave	Test-Driven Development of Relational Databases	In test-first development, developers formulate and implement a detailed design iteratively, one test at a time. Test-driven development (also called test-driven design) combines TFD with refactoring, wherein developers make small changes (refactorings) to improve code design without changing the code's semantics. When developers decide to use TDD to implement a new feature, they must first ask whether the current design is the easiest possible design to enable the feature's addition. Implementing test-driven database design involves database refactoring, regression testing, and continuous integration. TDDD is an integrated part of the overall development process, not a standalone activity that data professionals perform in parallel with application TDD. Although from a technical view point, TDDD is relatively straightforward, we must overcome several challenges to its whole sale adoption throughout the IT community	test-driven development;TDD;database refactoring;database testing;test-driven database design;TDD;relational database;behavior-driven development;BDD	S. W. Ambler	IEEE Software					Excluded	Excluded	new_screen			2						
121	Behave	Mobile Application Development: Automated Test Input Generation Via Model Inference based on User Story and Acceptance Criteria	In the past few years, there has been observed explosive growth in the development of Mobile Applications across Android and iOS operating system which has led to the direct impact towards mobile app development. In order to design and propose quality-oriented apps, it is the primary responsibility of the developers to devote time and sufficient efforts towards testing to make the Apps bug free and operational in the hands of end users without any hiccup. In order to test the mobile apps, manual testing procedures takes prolonged amount of time in writing test cases and even the full testing requirements are not met. In addition to this, lack of sufficient knowledge by the tester also impacts overall quality and assurance that app is bug free. To overcome all the issues of testing, and to assure that apps designed by developers are almost bug free, we propose a new testing methodology cum tool 'AgileUATM' which works primarily towards white-box and black-box testing. With this tool, all the test cases are generated automatically based on user stories and acceptance criteria by using formal specification and Z3 SMT solvers. To test the validity of the proposed tool, we applied the tool in real-time operational environment with regard to test Mobile apps. Using this tool, all the acceptance criteria is determined via user stories. The testers/developers specify requirements with formal specifications based on programs properties, predicates, invariants, and constraints. From the results, it is observed that the proposed tool i.e. AgileUATM generated effective and accurate test cases, test input, and expected output was generated in a unified fashion from the user stories to meet acceptance criteria. In addition to this, the tool also reduced the development time to identify test data as compared to manual Behavior Driven Development (BDD) methodologies. With this tool, the developers got better idea with regard to required tests and able to translate the customers natural languages to the computer language as well. © 2019 IEEE.		Iqbal H.	Proceeding of 2019 International Conference on Digitization: Landscaping Artificial Intelligence, ICD 2019					Included	Included	new_screen			2						
122	Behave	Notice of Violation of IEEE Publication Principles: Mobile Application Development: Automated Test Input Generation Via Model Inference based on User Story and Acceptance Criteria	In the past few years, there has been observed explosive growth in the development of Mobile Applications across Android and iOS operating system which has led to the direct impact towards mobile app development. In order to design and propose quality-oriented apps, it is the primary responsibility of the developers to devote time and sufficient efforts towards testing to make the Apps bug free and operational in the hands of end users without any hiccup. In order to test the mobile apps, manual testing procedures takes prolonged amount of time in writing test cases and even the full testing requirements are not met. In addition to this, lack of sufficient knowledge by the tester also impacts overall quality and assurance that app is bug free. To overcome all the issues of testing, and to assure that apps designed by developers are almost bug free, we propose a new testing methodology cum tool “AgileUATM” which works primarily towards white-box and black-box testing. With this tool, all the test cases are generated automatically based on user stories and acceptance criteria by using formal specification and Z3 SMT solvers. To test the validity of the proposed tool, we applied the tool in real-time operational environment with regard to test Mobile apps. Using this tool, all the acceptance criteria is determined via user stories. The testers/developers specify requirements with formal specifications based on programs properties, predicates, invariants, and constraints. From the results, it is observed that the proposed tool i.e. AgileUATM generated effective and accurate test cases, test input, and expected output was generated in a unified fashion from the user stories to meet acceptance criteria. In addition to this, the tool also reduced the development time to identify test data as compared to manual Behavior Driven Development (BDD) methodologies. With this tool, the developers got better idea with regard to required tests and able to translate the customers natural languages to the computer language as well.;Notice of Violation of IEEE Publication Principles <br><br> “Mobile Application Development: Automated Test Input Generation Via Model Inference based on User Story and Acceptance Criteria” <br> by Hena Iqbal <br> in the Proceedings of the International Conference on Digitization (ICD), November 2019, pp. 92-103 <br><br> After careful and considered review of the content and authorship of this paper by a duly constituted expert committee, this paper has been found to be in violation of IEEE’s Publication Principles. <br><br> This paper is a near duplication of the original text from the paper cited below. The original text was copied without attribution (including appropriate references to the original author(s) and/or paper title) and without permission. <br><br> Due to the nature of this violation, reasonable effort should be made to remove all past references to this paper, and future references should be made to the following article: <br><br> “Automated Test Input Generation via Model Inference Based on User Story and Acceptance Criteria for Mobile Application Development” <br> by Duc-Man Nguyen, Quyet-Thang Huynh, Nhu-Hang Ha and Thanh-Hung Nguyen <br> in the International Journal of Software Engineering and Knowledge Engineering, Vol. 30, No. 3 2020, pp. 399-425 <br><br>		H. Iqbal	2019 International Conference on Digitization (ICD)					Excluded	Excluded	new_screen			2						
123	Behave	Combination of Test-Driven Development and Behavior-Driven Development for Improving Backend Testing Performance	In the process of software development, a testing phase is an important step for detecting the errors. In order to produce a reliable application, this paper discusses the utilization of a combination from two different testing methods, Test- Driven Development (TDD) and Behavior Driven Development (BDD). TDD testing method is a process with a high percentage of code which is tested automatically. However, it could lead to an error when the parameters of the features are changed. Meanwhile, the BDD testing method is a testing method that could perform successfully despite changes to the parameters of the features. This paper discusses the combination of TDD and BDD testing methods, which is called as T-BDD method. By implementing T-BDD into the Vixio backend system, this paper successfully shows that it could be performed to achieve a high percentage of test-coverage while it could also adapt when the parameters of the features were changed. This paper also shows that the T-BDD testing method performed better compared to using the TDD testing method only.	Unit Test, Test-Driven Development (TDD), Behavior-Driven Development(BDD), Backend, Web Application	Kerthyayana Manuaba, Ida Bagus	Procedia Computer Science					Included	Included	new_screen			2						
124	Behave	Requirements behaviour analysis for ontology testing	In the software engineering field, every software product is delivered with its pertinent associated tests which verify its correct behaviour. Besides, there are several approaches which, integrated in the software development process, deal with software testing, such as unit testing or behaviour-driven development. However, in the ontology engineering field there is a lack of clearly defined testing processes that can be integrated into the ontology development process. In this paper we propose a testing framework composed by a set of activities (i.e., test design, implementation and execution), with the goal of checking whether the requirements identified are satisfied by the formalization and analysis of their expected behaviour. This testing framework can be used in different types of ontology development life-cycles, or concerning other goals such as conformance testing between ontologies. In addition to this, we propose an RDF vocabulary to store, publish and reuse these test cases and their results, in order to allow traceability between the ontology, the test cases and their requirements. We validate our approach by integrating the testing framework into an ontology engineering process where an ontology network has been developed following agile principles. © Springer Nature Switzerland AG 2018.		Fernández-Izquierdo A., García-Castro R.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)					Excluded	Excluded	new_screen			2						
125	Behave	Skyfire: Model-Based Testing with Cucumber	In the software industry, a Behavior-Driven Development (BDD) tool, Cucumber, has been widely used by practitioners. Usually product analysts, developers, and testers manually write BDD test scenarios that describe system behaviors. Testers write implementation for the BDD scenarios by hand and execute the Cucumber tests. Cucumber provides transparency about what test scenarios are covered and how the test scenarios are mapped to executable tests. One drawback of the Cucumber BDD approach is that test scenarios are generated manually. Thus, the test scenarios are usually weak. More importantly, practitioners do not have a metric to measure test coverage. In this paper, we present a Model-Based Testing (MBT) tool, skyfire. Skyfire can automatically generate effective Cucumber test scenarios to replace manually generated test scenarios. Skyfire reads a behavioral UML diagram (e.g., a state machine diagram), identifies all necessary elements (e.g., transitions) of the diagram, generates effective tests to satisfy various graph coverage criteria, and converts the tests into Cucumber scenarios. Then testers write Cucumber mappings for the generated scenarios. Skyfire does not only generate effective tests but is also completely compatible with the existing agile development and continuous integration (CI) rhythm. We present the design architecture and implementation of skyfire, as well as an industrial case study to show how skyfire is used in practice.		N. Li; A. Escalona; T. Kamal	2016 IEEE International Conference on Software Testing, Verification and Validation (ICST)					Included	Included	new_screen			2						
126	Behave	Systematic verification and testing	In this chapter, we present a process pattern for model based specification, verification and testing. It combines concepts of behaviour driven development (BDD), graphical and formal, mathematical modelling, formal verification techniques, acceptance testing and model based testing. The rigorous approach helps to ensure that for highly dependable systems, dependability (e.g. safety) requirements are fulfilled and both the specified and the implemented behaviour are as desired. It helps bridging the gap between natural language or semi-formal requirements and mathematical abstraction. Furthermore, it addresses the issue that formal modelling expertise and domain knowledge are rarely held by the same set of people. © Springer Nature Switzerland AG 2020.		Dghaym D., Fischer T., Hoang T.S., Reichl K., Snook C., Schlick R., Tummeltshammer P.	Validation and Verification of Automated Systems: Results of the ENABLE-S3 Project					Excluded	Excluded	new_screen			2						
127	Behave	BDD by Example: Russian Bylina Written in Gherkin Language	"In this paper is presented the User Stories technique within the Behaviour-Driven Development process by example of the famous Russian bylina (epic poem) ""Three trips of Ilya Muromets"" written in Gherkin language. In the first part are given explanations about the choice of the bylina as a good example for presentation of this technique and about the choice of GitHub as a good environment for this presentation. In the second part is placed the text of the presentation divided by the stages of the Story development and fitted with the links to the corresponding commits and file versions in the educational repository. A distinct advantage of this presentation is that it reflects a Story in its evolution, as a process. It reflects a more complex and changeable behaviour than in static trivial examples, which are usually used. Also, there are presented the main features of using the User Stories technique in Russian language, which have not been previously covered nowhere. Besides that, the using of the educational repository can significantly increase the possibilities for further spreading and development of the example."	behaviour-driven development; Gherkin; Agile; user stories; byliny; cucumber; epic poetry; examples; extreme programming; GitHub; JBehave; Scrum	Mustyatsa, Vadim	Proceedings of the 11th Central &amp; Eastern European Software Engineering Conference in Russia					Excluded	Excluded	new_screen			2						
128	Behave	Satisfaction and its correlates in agile software development	In this paper we address the topic of software development team members satisfaction with their development process. We present an in-depth analysis of the results of a nationwide survey about software development in Switzerland. We wanted to find out if satisfaction relates to the applied development method, and to the use of various practices, and impacts on business, team and software issues. We found that higher satisfaction is reported more by those using Agile development than with plan-driven processes. We explored the different perspectives of developers and those with a management role and found a high consistency of satisfaction between Agile developers and Agile management, and differences with those using working plan-driven methods. We found that certain practices and impacts have high correlations to satisfaction, and that collaborative processes are closely related to satisfaction. We then explored the relationship between satisfaction and various other perspectives. Our results in this analysis are principally descriptive, but we think they can be a relevant contribution to understand the challenges for everyone involved in Agile development.		Kropp, Martin; Meier, Andreas; Anslow, Craig; Biddle, Robert	Journal of Systems and Software					Excluded	Excluded	new_screen			2						
129	Behave	Compliance checking on building models with the gherkin language and continuous integration	In this paper we document our approach on applying Behaviour-Driven Development (BDD) and Continuous Integration (CI) from the software industry to the construction sector. We have provided a freely available open software toolset for the application of rules in the Gherkin syntax to an IFC building model. A prominent aspect of BDD and contrary to mvdXML, the formalization of rules in plain-test human-readable scenarios provides a basis for collaborative formalization of rules among stakeholders. At the same time our approach includes imperative program code that is fully extensible to incorporate for example external data sources and geometrical reasoning. Runnings test on every model revision (the CI concept) as opposed to, for example, upon model delivery ensures a proactive approach to compliance. Reusing existing open source frameworks allowed us to build a comprehensive solution for continuous and automated model checking, visualization and reporting in several hundred lines of program code. © EG-ICE 2020 Workshop on Intelligent Computing in Engineering, Proceedings. All rights reserved.		Moult D., Krijnen T.	EG-ICE 2020 Workshop on Intelligent Computing in Engineering, Proceedings					Included	Included	new_screen			2						
130	Behave	Improving Agile Software Development with Domain Ontologies	In this paper we propose to apply domain ontologies in agile software development to reduce the ambiguity caused by using natural language as ubiquitous language to report user stories. To justify and demonstrate our approach, we present a case study that combines Scrum and Behaviour-Driven Development (BDD) in the development of an educational support system, which was built to support the activities of the Medicine Programme of Federal University of São Carlos (UFSCar) in Brazil. Starting from a reference ontology for the Higher Education domain, we gradually specialized this ontology for this programme. Since we selected the Evaluation Management module of this system for our case study, we applied the Evaluation Process Ontology to that programme, and defined user stories to identify the feature set to be implemented. For evaluation and validation purposes, we assessed the quality of all ontologies used in this work according to structural and functional dimensions. © 2018, Springer International Publishing AG, part of Springer Nature.		de Souza P.L., do Prado A.F., de Souza W.L., dos Santos Forghieri Pereira S.M., Pires L.F.	Advances in Intelligent Systems and Computing					Included	Included	new_screen			2						
131	Behave	Agile testing practices in software quality: State of the art review	In this paper you can find a review of articles related to agile testing practices in software quality, looking for theoretical information and real cases applied to testing inside a modern context, comparing them with the standard procedures taking into account their advantages and relevant features. As final result, we determine that agile practices in software quality have wide acceptance and many companies have chosen their use for all their benefits and impact on development software processes in several real applications, not necessarily IT governance ones, since other kind of technical applications have shown excellent results on testing. © 2005 - 2016 JATIT & LLS. All rights reserved.		Gil C., Diaz J., Orozco M., de la Hoz A., de la Hoz E., Morales R.	Journal of Theoretical and Applied Information Technology					Excluded	Excluded	new_screen			2						
132	Behave	Consistency Reflection for Automatic Update of Testing Environment	In this paper, we present an approach for maintaining consistency among design models, system under test, and test components. Our approach provides an automatic updating technique to deal with changes that happen frequently in agile software development. Consistency reflection by automatic updating allows us to cut off manual tasks required in maintaining automated tests and speed up testing process which is a bottleneck in service development lifecycle. We introduce the use of metadata, the data structure that describes structural behavior of the system, in our automatic updating technique. Metadata is used as a common medium for communicating changes to keep consistency among design, system under test, and test components. We present an example of testing process to show how we apply this approach in practice.	behavior-driven development; agile software development; automated software testing; automatic update; consistency reflection; design models; metadata	Sathawornwichit, Chaiwat; Hosono, Shigeru	Proceedings of the 2012 IEEE Asia-Pacific Services Computing Conference)					Included	Included	new_screen			2						
133	Behave	Generation of behavior-driven development C++ tests from abstract state machine scenarios	In this paper, we present the AsmetaVBDD tool that automatically translates the scenarios written in the AValLa language (used by the asmeta validator (AsmetaV)) into Behavior-Driven Development scenarios for C++. © Springer Nature Switzerland AG 2018.		Bonfanti S., Gargantini A., Mashkoor A.	Communications in Computer and Information Science					Included	Included	new_screen			2						
134	Behave	Behaviour-Driven Development for Computer-Interpretable Clinical Guidelines	In this paper, we propose an approach for specification and analysis of Computer-Interpretable Clinical Guidelines (CIGs) that was inspired by Behaviour-Driven Development. The expected behaviour of a CIG is specified by requirements in natural language. On the one hand, those requirements are used as design input for guideline development. On the other hand, they can be checked against time-oriented data recorded during testing sessions of the implemented CIG.		Hatko, Reinhard; Mersmann, Stefan; Puppe, Prank	Proceedings of the 10th International Conference on Knowledge Engineering and Software Engineering - Volume 1289					Included	Included	new_screen			2						
135	Behave	A preliminary study on using acceptance tests for representing business requirements of smart contracts	"In this work, we address the following question: ""Which acceptance testing techniques are being used for representing business requirements of smart contracts?"" To answer this question we performed a systematic mapping to determine whether acceptance tests for smart contracts and blockchain are being utilized to represent requirements and which acceptance testing techniques are being applied. This systematic mapping shows that, in fact, acceptance testing techniques are still not commonly used to represent the business requirements of smart contracts. We only found two studies using acceptance testing techniques with smart contracts. Moreover, only one of them uses an acceptance testing technique, the BDD (Behavior-Driven Development) notation, to represent the business requirements. In order to confirm that it is possible to represent business requirements of smart contracts, we developed an example that uses the BDD notation to represent requirements of a smart contract deployed in the Hyperledger blockchain. Preliminary results show that it is possible to use acceptance tests to represent business requirements."	acceptance testing;acceptance test;smart contract;business requirement;blockchain	P. Vilain; J. Mylopoulos; H. -A. Jacobsen	2020 IEEE International Conference on Blockchain and Cryptocurrency (ICBC)					Excluded	Excluded	new_screen			2						
136	Behave	Behavior-Driven Development as an Approach to Improve Software Quality and Communication across Remote Business Stakeholders, Developers and QA: Two Case Studies	In this work, we describe two of our experiences applying BDD: one at a large publisher of financial information and business news, and the other in a secure collaboration platform vendor. The team composition involves both a local team and an external service provider. We analyze two adoption processes, one driven by the product team, and the other driven by the development team. We cover the communication benefits and impacts on areas such as stakeholder alignment, software design, code refactoring, and bug fixing. We also discuss lessons learned, caveats and how we plan to expand this practice in the future.	distributed agile teams; industrial offshoring and outsourcing experiences; methods and processes; social and human aspects of software development	Scandaroli, André; Leite, Rodrigo; Kiosia, Aléxis H.; Coelho, Sandro A.	Proceedings of the 14th International Conference on Global Software Engineering					Excluded	Excluded	new_screen			2						
137	Behave	Behavior-Driven Development as an Approach to Improve Software Quality and Communication Across Remote Business Stakeholders, Developers and QA: Two Case Studies	In this work, we describe two of our experiences applying BDD: one at a large publisher of financial information and business news, and the other in a secure collaboration platform vendor. The team composition involves both a local team and an external service provider. We analyze two adoption processes, one driven by the product team, and the other driven by the development team. We cover the communication benefits and impacts on areas such as stakeholder alignment, software design, code refactoring, and bug fixing. We also discuss lessons learned, caveats and how we plan to expand this practice in the future. © 2019 IEEE.		Scandaroli A., Leite R., Kiosia A.H., Coelho S.A.	Proceedings - 2019 ACM/IEEE 14th International Conference on Global Software Engineering, ICGSE 2019					Included	Included	new_screen			2						
138	Behave	Towards a Behavior-Oriented Specification and Testing Language for Multimodal Applications	Initiated by the ubiquity of mobile devices, human computer interaction has evolved beyond the classic PCs' mouse and keyboard setup. Smartphones and tablets introduced new interaction modalities to the mass market and created the need for specialized software engineering methods. While more and more powerful SDKs are released to develop interactive applications, specifying user interaction is still ambiguous and error-prone, causing software defects as well as misunderstandings and frustration among project team members and stakeholders. We present an approach addressing this problems by demonstrating how to incorporate multimodal interaction into user acceptance tests written in near-natural language using Gherkin and formal gesture descriptions.	software engineering; multimodal user interfaces; specification	Hesenius, Marc; Griebe, Tobias; Gruhn, Volker	Proceedings of the 2014 ACM SIGCHI Symposium on Engineering Interactive Computing Systems					Included	Included	new_screen			2						
139	Behave	Improving the Prediction of Files Changed by Programming Tasks	Integration conflicts often damage software quality and developers' productivity in a collaborative development environment. For reducing merge conflicts, we could avoid asking developers to execute potentially conflicting tasks in parallel, as long as we can predict the files to be changed by each task. As manually predicting that is hard, the TAITI tool tries to do that in the context of BDD (Behaviour-Driven Development) projects, by statically analysing the automated acceptance tests that validate each task. TAITI computes the set of files that might be executed by the tests of a task (a so called test-based task interface), approximating the files that developers will change when performing the task. Although TAITI performs better than a random task interface, there is space for accuracy improvements. In this paper, we extend the interfaces computed by TAITI by including the dependences of the application files reached by the task tests. To understand the potential benefits of our extension, we evaluate precision and recall of 60 task interfaces from 8 Rails GitHub projects. The results bring evidence that the extended interface improves recall by slightly compromising precision.	Collaborative development; File change prediction; Behaviour-Driven Development	Santos, João Pedro; Rocha, Thaís; Borba, Paulo	Proceedings of the XIII Brazilian Symposium on Software Components, Architectures, and Reuse					Included	Included	new_screen			2						
140	Behave	Test-Driven Java Development	Invoke TDD principles for end-to-end application development with JavaAbout This BookExplore the most popular TDD tools and frameworks and become more proficient in building applicationsCreate applications with better code design, fewer bugs, and higher test coverage, enabling you to get them to market quicklyImplement test-driven programming methods into your development workflowsWho This Book Is ForIf you're an experienced Java developer and want to implement more effective methods of programming systems and applications, then this book is for you.What You Will LearnExplore the tools and frameworks required for effective TDD developmentPerform the Red-Green-Refactor process efficiently, the pillar around which all other TDD procedures are basedMaster effective unit testing in isolation from the rest of your codeDesign simple and easily maintainable codes by implementing different techniquesUse mocking frameworks and techniques to easily write and quickly execute testsDevelop an application to implement behaviour-driven development in conjunction with unit testingEnable and disable features using Feature TogglesIn DetailTest-driven development (TDD) is a development approach that relies on a test-first procedure that emphasises writing a test before writing the necessary code, and then refactoring the code to optimize it.The value of performing TDD with Java, one of the most established programming languages, is to improve the productivity of programmers, the maintainability and performance of code, and develop a deeper understanding of the language and how to employ it effectively.Starting with the basics of TDD and reasons why its adoption is beneficial, this book will take you from the first steps of TDD with Java until you are confident enough to embrace the practice in your day-to-day routine.You'll be guided through setting up tools, frameworks, and the environment you need, and will dive right in to hands-on exercises with the goal of mastering one practice, tool, or framework at a time. You'll learn about the Red-Green-Refactor procedure, how to write unit tests, and how to use them as executable documentation.With this book you'll also discover how to design simple and easily maintainable code, work with mocks, utilise behaviour-driven development, refactor old legacy code, and release a half-finished feature to production with feature toggles.You will finish this book with a deep understanding of the test-driven development methodology and the confidence to apply it to application programming with Java.Style and approachAn easy-to-follow, hands-on guide to building applications through effective coding practices. This book covers practical examples by introducing different problems, each one designed as a learning exercise to help you understand each aspect of TDD.		Farcic, Viktor; Garcia, Alex						Excluded	Excluded	new_screen			2						
141	Behave	An industrial case study on test cases as requirements	It is a conundrum that agile projects can succeed ‘without requirements’ when weak requirements engineering is a known cause for project failures. While Agile development projects often manage well without extensive requirements documentation, test cases are commonly used as requirements. We have investigated this agile practice at three companies in order to understand how test cases can fill the role of requirements. We performed a case study based on twelve interviews performed in a previous study. The findings include a range of benefits and challenges in using test cases for eliciting, validating, verifying, tracing and managing requirements. In addition, we identified three scenarios for applying the practice, namely as a mature practice, as a de facto practice and as part of an agile transition. The findings provide insights into how the role of requirements may be met in agile development including challenges to consider. © Springer International Publishing Switzerland 2015.		Bjarnason E., Unterkalmsteiner M., Engström E., Borg M.	Lecture Notes in Business Information Processing					Included	Included	new_screen			2						
142	Behave	Chapter Five - Advances in Testing JavaScript-Based Web Applications	JavaScript is a flexible and expressive prototype-based scripting language that is used by developers to create interactive web applications. The language is interpreted, dynamic, weakly typed, and has first-class functions. It also interacts extensively with other web languages such as CSS and HTML at runtime. All these characteristics make JavaScript code particularly error-prone and challenging to analyze and test. In this chapter, we explore recent advances made in analysis and testing techniques geared toward JavaScript-based web applications. In particular, we look at recent empirical studies, testing techniques, test oracle automation approaches, test adequacy assessment methods, fault localization and repair, and Integrated Development Environment support to help programmers write better JavaScript code.	JavaScript, Testing, Dynamic analysis, Web applications, Test adequacy, Oracles	Mesbah, Ali						Excluded	Excluded	new_screen			2						
143	Behave	Mastering Symfony	Key FeaturesCreate a robust and reliable Symfony development pipeline using Amazon's cloud platformCut development and maintenance costs by defining crystal clear features and possible scenarios for each feature before implementationFollow detailed examples provided in each chapter to create a task management applicationBook DescriptionIn this book, you will learn some lesser known aspects of development with Symfony, and you will see how to use Symfony as a framework to create reliable and effective applications. You might have developed some impressive PHP libraries in other projects, but what is the point when your library is tied to one particular project? With Symfony, you can turn your code into a service and reuse it in other projects.This book starts with Symfony concepts such as bundles, routing, twig, doctrine, and more, taking you through the request/response life cycle. You will then proceed to set up development, test, and deployment environments in AWS. Then you will create reliable projects using Behat and Mink, and design business logic, cover authentication, and authorization steps in a security checking process. You will be walked through concepts such as DependencyInjection, service containers, and services, and go through steps to create customized commands for Symfony's console. Finally, the book covers performance optimization and the use of Varnish and Memcached in our project, and you are treated with the creation of database agnostic bundles and best practices.What you will learnInstall and configure Symfony and required third-party bundles to develop a task management applicationSet up a continuous integration server to orchestrate automatic builds every time you add a new feature to your projectReduce maintenance costs dramatically using Behaviour Driven Development (BDD)Create a slick user interface using the Bootstrap frameworkDesign robust business logic using DoctrineBuild a comprehensive dashboard and secure your project using the Sonata projectImprove performance using Redis, Memcache, and VarnishCreate customized Symfony commands and add them to your consoleAbout the AuthorSohail Salehi is a full stack web developer who is constantly seeking creative solutions for complex problems. He believes that what has been taught as universalities should be considered as a basic stepping stone to real-life challenges. They cannot be used as practical solutions. He learned that a one-size-fits-all solution does not work in the IT world. Every business, every coding challenge, and every environment setup has its own signature and requires some tweaking on basic principals to make sure that it receives a reliable cost-effective solution.When he is not staring at his computer screen, he is watching sunsets and sunrises, swimming and surfing in the ocean, and putting his subconscious mind at work by asking creative questions while facing life's ups and downs on a daily basis.Table of ContentsInstalling and Configuring SymfonyThe Request and Response Life CycleSetting Up the EnvironmentUsing Behavior-Driven Development in SymfonyBusiness LogicDashboard and SecurityThe Presentation LayerProject ReviewServices and Service ContainersCustom User CommandsMore about Dev, Test and Prod EnvironmentsCaching in Symfony		Salehi, Sohail						Excluded	Excluded	new_screen			2						
144	Behave	RSpec Essentials	Key FeaturesExplore the concept of testability and how to implement tests that deliver the most valueMaximize the quality of your Ruby code through a wide variety of testsMaster the real-world tradeoffs of testing through detailed examples supported by in-depth discussionBook DescriptionThis book will teach you how to use RSpec to write high-value tests for real-world code. We start with the key concepts of the unit and testability, followed by hands-on exploration of key features. From the beginning, we learn how to integrate tests into the overall development process to help create high-quality code, avoiding the dangers of testing for its own sake.We build up sample applications and their corresponding tests step by step, from simple beginnings to more sophisticated versions that include databases and external web services. We devote three chapters to web applications with rich JavaScript user interfaces, building one from the ground up using behavior-driven development (BDD) and test-driven development (TDD).The code examples are detailed enough to be realistic while simple enough to be easily understood. Testing concepts, development methodologies, and engineering tradeoffs are discussed in detail as they arise. This approach is designed to foster the reader's ability to make well-informed decisions on their own.What you will learnIdentify a unit of software for the purposes of testingManage test states with hooks, fixtures, and mocksHandle external web services in tests using various techniquesConfigure RSpec flexibly and cleanly using support code and environment variablesInteract with rich web apps in tests using CapybaraBuild the right feature with behavior-driven developmentCustomize matchers and failure messagesVerify correct development and production environmentsAbout the AuthorMani Tadayon first learned to program as a shy 7th grader on an Apple IIe using BASIC. He went on to learn Pascal, C++, Java, JavaScript, Visual Basic, and PHP before becoming a Ruby developer in 2008. With 15 years of experience in the software industry, he has developed expertise in web development, infrastructure, and testing. Mani's interests and education are broad, with degrees in foreign languages, computer science, and geography. He lives just far enough from Silicon Valley with his family and their many, many Shiba Inus.Table of ContentsExploring Testability from Unit Tests to Behavior-Driven DevelopmentSpecifying Behavior with Examples and MatchersTaking Control of State with Doubles and HooksSetting Up and Cleaning UpSimulating External ServicesDriving a Web Browser with CapybaraBuilding an App from the Outside In with Behavior-Driven DevelopmentTackling the Challenges of End-to-end TestingConfigurabilityOdds and Ends		Tadayon, Mani						Excluded	Excluded	new_screen			2						
145	Behave	Crowdsourced Behavior-Driven Development	Key to the effectiveness of crowdsourcing approaches for software engineering is workflow design, describing how complex work is organized into small, relatively independent microtasks. This paper, we introduce a Behavior-Driven Development (BDD) workflow for accomplishing programming work through self-contained microtasks, implemented as a preconfigured environment called CrowdMicroservices. In our approach, a client, acting on behalf of a software team, describes a microservice as a set of endpoints with paths, requests, and responses. A crowd then implements the endpoints, identifying individual endpoint behaviors that they test, implement, debug, create new functions, and interact with persistence APIs as needed. To evaluate our approach, we conducted a feasibility study in which a small crowd worked to implement a small ToDo microservice. The crowd created an implementation with only four defects, completing 350 microtasks and implementing 13 functions. We discuss the implications of these findings for incorporating crowdsourced programming contributions into traditional software projects.	Microtask programming, Programming environments, Behavior-Driven Development, Crowdsourcing, Workflow, Microservices	Aghayi, Emad; LaToza, Thomas D.; Surendra, Paurav; Abolghasemi, Seyedmeysam	Journal of Systems and Software					Included	Included	new_screen			2						
146	Behave	Using Language Workbenches and Domain-Specific Languages for Safety-Critical Software Development	Language workbenches support the efficient creation, integration, and use of domain-specific languages. Typically, they execute models by code generation to programming language code. This can lead to increased productivity and higher quality. However, in safety-/mission-critical environments, generated code may not be considered trustworthy, because of the lack of trust in the generation mechanisms. This makes it harder to justify the use of language workbenches in such an environment. In this paper, we demonstrate an approach to use such tools in critical environments. We argue that models created with domain-specific languages are easier to validate and that the additional risk resulting from the transformation to code can be mitigated by a suitably designed transformation and verification architecture. We validate the approach with an industrial case study from the healthcare domain. We also discuss the degree to which the approach is appropriate for critical software in space, automotive, and robotics systems.	Case study; Domain-specific languages; Language workbenches; Safety-critical software development	Voelter, Markus; Kolb, Bernd; Birken, Klaus; Tomassetti, Federico; Alff, Patrick; Wiart, Laurent; Wortmann, Andreas; Nordmann, Arne	Softw. Syst. Model.					Excluded	Excluded	new_screen			2						
147	Behave	Instant RSpec Test - Driven Development How-To	Learn RSpec and redefine your approach towards software development Overview Learn something new in an Instant! A short, fast, focused guide delivering immediate results Learn how to use RSpec with Rails Easy to read and grok examples Write idiomatic specifications In Detail RSpec is a behaviour driven development framework for Ruby programmers. It comes integrated with its own mocking framework based on Jmock. This book introduces you to RSpec helping you to write idiomatic specifications for Ruby code in a test first approach. Instant RSpec Test-Driven Development How-to is filled with examples of actual code accompanied by explanations and covers general Ruby, Rails, and RSpec use cases plus a few of the more advanced topics. RSpec Test Driven Development is written on the premise that you will need no experience with RSpec and limited experience with Ruby, Rails, and TDD fundamentals. Youll begin by writing a very simple Ruby library in true TDD fashion and and use the red, green, refactor tools to migrate this library into a Rails application. Instant RSpec Test-Driven Development How-to will teach you the actual steps performed in writing an idiomatic specification. You will be able to write a test for the code you wish you had, and learn to write only the minimum code necessary to pass a test, and write more specifications to drive out the production functionality your application will need. Through the course of the book, you will convert a Ruby program into a new Rails application, test Rails specifics such as file uploads, cookies, and model validation and even learn how to use Capybara. RSpec Test Driven Development will help you build confidence in the code they you write and spend less time dealing with bugs and maintenance headaches. What you will learn from this book RSpec fundamentals How to use RSpec and Rails together Modify your behavior to create tests first and run your specs with every code change How to work with the rspec command line tool Using mocks and stubs to decouple tests from the database How to refactor code to improve readability Approach Filled with practical, step-by-step instructions and clear explanations for the most important and useful tasks. A concise guide that delivers immediate results with practical recipes on learning practical hints. Who this book is written for This book is aimed at Ruby developers with beginner level expertise who want to use RSpec and test driven development methodology to improve the code they write. Experienced programmers new to Ruby will also benefit from this book which also covers creating testable, idiomatic Ruby code.		Feduke, Charles						Excluded	Excluded	new_screen			2						
148	Behave	Behavior-Driven Load Testing Using Contextual Knowledge - Approach and Experiences	Load testing is widely considered a meaningful technique for performance quality assurance. However, empirical studies reveal that in practice, load testing is not applied systematically, due to the sound expert knowledge required to specify, implement, and execute load tests.Our Behavior-driven Load Testing (BDLT) approach eases load test specification and execution for users with no or little expert knowledge. It allows a user to describe a load test in a template-based natural language and to rely on an automated framework to execute the test. Utilizing the system's contextual knowledge such as workload-influencing events, the framework automatically determines the workload and test configuration. We investigated the applicability of our approach in an industrial case study, where we were able to express four load test concerns using BDLT and received positive feedback from our industrial partner. They understood the BDLT definitions well and proposed further applications, such as the usage for software quality acceptance criteria.	behavior-driven testing; declarative performance engineering; load testing	Schulz, Henning; Okanović, Dušan; van Hoorn, André; Ferme, Vincenzo; Pautasso, Cesare	Proceedings of the 2019 ACM/SPEC International Conference on Performance Engineering					Included	Included	new_screen			2						
149	Behave	Challenges &amp; Opportunities in Low-Code Testing	Low-code is a growing development approach supported by many platforms. It fills the gap between business and IT by supporting the active involvement of non-technical domain experts, named Citizen Developer, in the application development lifecycle.Low-code introduces new concepts and characteristics. However, it is not investigated yet in academic research to point out the existing challenges and opportunities when testing low-code software. This shortage of resources motivates this research to provide an explicit definition to this area that we call it Low-Code Testing.In this paper, we initially conduct an analysis of the testing components of five commercial Low-Code Development Platforms (LCDP) to present low-code testing advancements from a business point of view. Based on the low-code principles as well as the result of our analysis, we propose a feature list for low-code testing along with possible values for them. This feature list can be used as a baseline for comparing low-code testing components and as a guideline for building new ones. Accordingly, we specify the status of the testing components of investigated LCDPs based on the proposed features. Finally, the challenges of low-code testing are introduced considering three concerns: the role of citizen developer in testing, the need for high-level test automation, and cloud testing. We provide references to the state-of-the-art to specify the difficulties and opportunities from an academic perspective. The results of this research can be used as a starting point for future research in low-code testing area.	testing; citizen developer; low-code; low-code development platform	Khorram, Faezeh; Mottu, Jean-Marie; Sunyé, Gerson	Proceedings of the 23rd ACM/IEEE International Conference on Model Driven Engineering Languages and Systems: Companion Proceedings					Excluded	Excluded	new_screen			2						
150	Behave	Toward leveraging Gherkin Controlled Natural Language and Machine Translation for Global Product Information Development	Machine Translation (MT) already plays an important part in software development process at McAfee where the technology can be leveraged to provide early builds for localization and internationalization testing teams. Behavior Driven Development (BDD) has been growing in usage as a development methodology in McAfee. Within BDD, the Gherkin Controlled Natural Language (CNL) is a syntax and common terminology set that is used to describe the software or business process in a User Story. Given there exists this control on the language to describe User Stories for software features using Gherkin, we seek to use Machine Translation to Globalize it at high accuracy and without Post-Editing and reuse it as Product Information. This enables global product information development to happen as part of the Software Development Life Cycle (SDLC) and at low cost. © 2018 Morgan O’Brien, McAfee LLC.		O’Brien M.	EAMT 2018 - Proceedings of the 21st Annual Conference of the European Association for Machine Translation					Included	Included	new_screen			2						
151	Behave	Automating test oracles from restricted natural language agile requirements	Manual testing of software requirements written in natural language for agile or any other methodology requires more time and human resources. This leaves the testing process error prone and time consuming. For satisfied end users with bug-free software delivered on time, there is a need to automate the test oracle process for natural language or informal requirements. The automation of the test oracle is relatively easier with formal requirements, but this task is difficult to achieve with natural language requirements. This study proposes an approach called Restricted Natural Language Agile Requirements Testing (ReNaLART) to automate the test oracle from restricted natural language agile requirements. For this purpose, it uses an existing user story template with some modifications for writing user stories. This helps in identifying test input and expected output for a user story. For comparison of expected and observed outputs it makes use of a regex pattern and string distance functions. It is capable of assigning different types of verdicts automatically depending upon the similarity/dissimilarity between observed and expected outputs of user stories. ReNaLART is validated using several case studies of different domains, namely, OLX Pakistan, Mental Health Tests, McDelivery Pakistan, BlueStacks, Power Searching with Google, TensorFlow Playground, w3Schools 2018 offline and Touch'D. It revealed several faults in five of the above listed eight applications. Plus, the proposed test oracle on an average took 0.02 s for test data generation, expected output generation and verdict assignment. Both these facts show the fault revealing effectiveness and efficiency of ReNaLART. © 2020 John Wiley & Sons, Ltd		Malik M.I., Sindhu M.A., Khattak A.S., Abbasi R.A., Saleem K.	Expert Systems					Included	Included	new_screen			2						
152	Behave	Scenario-Based Microservice Retrieval Using Word2Vec	Microservice architecture (MSA) is an emerging software architectural style, which differs fundamentally from the monolithic, layered architecture. During the development and maintenance of microservice systems, how to provide an effective service retrieval mechanism is a critical challenge to avoid the problems of rework and duplicate code. Meanwhile, nowadays, using the BDD (Behavior-Driven Development) method to develop microservices becomes more and more popular due to its agility and domain-driven characteristics. BDD is an agile software development approach emphasizing that test cases are written in a common language to include scenarios that describe the features of a target system. In this paper, we propose an approach, referred to as SMSR (Scenario-based MicroService Retrieval), to recommend appropriate microservices to users based on the user-written BDD test scenarios. The proposed service retrieval algorithm is based on word2vec, a widely-used machine learning method in NLP (Natural Language Processing), to perform service filtering and service similarity calculation. Experiment results show that SMSR is able to effectively retrieve appropriate microservices from the service repository.	Microservice, Microservice Retrieval, Requirement Scenario, Behavior-Driven Development, word2vec	S. Ma; Y. Chuang; C. Lan; H. Chen; C. Huang; C. Li	2018 IEEE 15th International Conference on e-Business Engineering (ICEBE)					Included	Included	new_screen			2						
153	Behave	Agile development cycle: Approach to design an effective Model Based Testing with Behaviour driven automation framework	Model Based Testing (MBT) is a relatively an approach widely discussed in software testing. It extends test automation from test design to test execution using automatic test generation from models. The effective use of this approach requires new skills, technology and knowledge, such as test modelling skills, but also good programs and tool support. This paper explores a design of a Behaviour driven test automation framework using MBT and how it can be effectively used during Agile Development. The automation framework is experimented upon the integration of the Graphwalker, a Model Based Graphical User Interface test generator with behaviour driven development framework and Robot Framework. © 2014 IEEE.		Sivanandan S., Yogeesha C.B.	2014 20th Annual International Conference on Advanced Computing and Communications, ADCOM 2014 - Proceedings					Included	Included	new_screen			2						
154	Behave	Automated Test Case Generation from Domain Specific Models of High-Level Requirements	Model-based software development has been shown to improve productivity and quality of software through automation. This involves using abstractions or models at several stages of development. This work reports on preliminary attempts to automate the generation of test cases from software requirement models using an industrial case study. The requirements are represented using a modeling notation and test cases are automatically generated using model to text transformation techniques.	domain specific languages; model-based testing	Olajubu, Oyindamola; Ajit, Suraj; Johnson, Mark; Turner, Scott; Thomson, Scott; Edwards, Mark	Proceedings of the 2015 Conference on Research in Adaptive and Convergent Systems					Excluded	Excluded	new_screen			2						
155	Behave	Towards a Workflow for Model-Based Testing of Embedded Systems	Model-based testing (MBT) has been previously used to validate embedded systems. However, (i) creation of a model conforming to the behavioural aspects of an embedded system, (ii) generation of executable test scripts and (iii) assessment of test verdict, re-quires a systematic process. In this paper, we have presented a three-phase tool-supported MBT workflow for the testing of an embedded system, that spans from requirements specification to test verdict assessment. The workflow starts with a simplistic, yet practical, application of a Domain-Specific Language (DSL) based on Gherkin-like style, which allows the requirements engineer to specify requirements and to extract information about model elements(i.e. states and transitions). This is done to assist the graphical modelling of the complete system under test (SUT). Later stages of the workflow generates an executable test script that runs on a domain-specific simulation platform. We have evaluated this tool-supported workflow by specifying the requirements, extracting information from the DSL and developing a model of a subsystem of the train control management system developed at Alstom Transport AB in Sweden. The C# test script generated from the SUT model is successfully executed at the Software-in-the-Loop (SIL) execution platform and test verdicts are visualized as a sequence of passed and failed test steps.	Domain-Specific Language; Model-Based Testing; Software-in-the-Loop	Zafar, Muhammad Nouman; Afzal, Wasif; Enoiu, Eduard	Proceedings of the 12th International Workshop on Automating TEST Case Design, Selection, and Evaluation					Included	Included	new_screen			2						
156	Behave	Model-Based Testing in Practice: An Industrial Case Study Using GraphWalker	Model-based testing (MBT) is a test design technique that supports the automation of software testing processes and generates test artefacts based on a system model representing behavioural aspects of the system under test (SUT). Previous research has shown some positive aspects of MBT such as low-cost test case generation and fault detection effectiveness. However, it is still a challenge for both practitioners and researchers to evaluate MBT tools and techniques in real, industrial settings. Consequently, the empirical evidence regarding the mainstream use, including the modelling and test case generation using MBT tools, is limited. In this paper, we report the results of a case study on applying GraphWalker, an open-source tool for MBT, on an industrial cyber-physical system (i.e., a Train Control Management System developed by Bombardier Transportation in Sweden), from modelling of real-world requirements and test specifications to test case generation. We evaluate the models of the SUT for completeness and representativeness, compare MBT with manual test cases written by practitioners using multiple attributes as well as share our experiences of selecting and using GraphWalker for industrial application. The results show that a model of the SUT created using both requirements and test specifications provides better understanding of the SUT from testers’ perspective, making it more complete and representative than the model created based only on the requirements specification alone. The generated model-based test cases are longer in terms of the number of test steps, achieve better edge coverage and can cover requirements more frequently in different orders while achieving the same level of requirements coverage as manually created test cases.		Zafar, Muhammad Nouman; Afzal, Wasif; Enoiu, Eduard; Stratis, Athanasios; Arrieta, Aitor; Sagardui, Goiuria	14th Innovations in Software Engineering Conference (Formerly Known as India Software Engineering Conference)					Excluded	Excluded	new_screen			2						
157	Behave	Towards behavior driven operations (BDOps)	Modern Enterprise Software Systems entail many challenges such as availability, scalability, complexity and providing business agility. Ensuring the systems to be up and running for 24 × 7 has become a mandate for operations. Agile development has been adopted to keep pace with the demands of business and IT. Test Driven Development (TDD) and Behavior Driven Development (BDD) are practices, which enable agile development. So far the agile approach has been limited to development. For ensuring business to be truly agile, we need to take forward the agile approach to operations. In this paper, we discuss the behavior driven approach for operations specifically on the core sub-systems like infrastructure provisioning, deployment and monitoring. We share our explorations and experiments with Behavior Driven Monitoring (BDM) and how the same can be adopted for infrastructure provisioning and deployment. We used Cucumber-Nagios to detect behavior of an enterprise application. We close this paper with a note on the benefits to busmess and IT showing its relevance to DevOps, Continuous Delivery and Cloud Computing.	Behavior Driven Development;Behavior Driven Operations;Behavior Driven Monitoring;Cucumber-Nagios;Behavior Driven Infrastructure	K. Gohil; N. Alapati; S. Joglekar	3rd International Conference on Advances in Recent Technologies in Communication and Computing (ARTCom 2011)					Included	Included	new_screen			2						
158	Behave	Combining behaviour-driven development with scrum for software development in the education domain	Most of the Brazilian universities employ teaching-learning methodologies based on classic frontal lectures. The Medicine Programme of the Federal University of São Carlos (UFSCar) is an exception, since it employs active learning methodologies. The Educational and Academic Management System for Courses Based on Active Learning Methodologies (EAMS-CBALM) was built and it is currently used to support this programme, and has been made available for other programmes as well. This system was developed using Scrum, but during its development project it was often necessary to reconsider system behaviour scenarios, and consequently the product backlog items, mainly due to poor communication between the Product Owner (PO) and the development team. This paper discusses a case study in which Behaviour-Driven Development (BDD) has been used in combination with Scrum to redesign some EAMS-CBALM components. The paper demonstrates that the communication between the PO and the development team can be improved by using BDD as a communication platform to unambiguously define system requirements and automatically generate test suites. ©2017 by SCITEPRESS - Science and Technology Publications, Lda. All rights reserved.		De Souza P.L., Do Prado A.F., De Souza W.L., Dos Santos Forghieri Pereira S.M., Pires L.F.	ICEIS 2017 - Proceedings of the 19th International Conference on Enterprise Information Systems					Included	Included	new_screen			2						
159	Behave	Enterprise ontology-driven development	Most of the current techniques and approaches for user requirements specification have problems with capturing the appropriate context for development of enterprise information systems. Primarily, they are designed to capture the functional aspects of software rather than its relevancy to an enterprise. Transactions defined in the DEMO (Design & Engineering Methodology for Organizations) represent business activities in their existential essence without implementation details. Therefore, they are great candidates to be utilized for the initial development phase of enterprise information systems. The paper exemplifies how to specify software specification the using the DEMO transaction pattern and BDD (Behaviour-Driven Development) technique. This proposal resulted from a significant lack of direct utilization of ontology for enterprise information systems development. The major part of the paper gives a step-by-step explanation of how to integrate DEMO transaction patterns into initial BDD scenarios for the development of enterprise information systems. Such created scenarios provide a perfect guideline in the initial phase of information system development for enterprises. The created scenarios were verified using the domain specific language Gherkin and BDD framework Behat. © Springer Nature Switzerland AG 2018.		Matula J., Hunka F.	Lecture Notes in Business Information Processing					Included	Included	new_screen			2						
160	Behave	A Behavior-Based Ontology for Supporting Automated Assessment of Interactive Systems	Nowadays many software development frameworks implement Behavior-Driven Development (BDD) as a mean of automating the test of interactive systems under construction. Automated testing helps to simulate user's action on the User Interface and therefore check if the system behaves properly and in accordance to Scenarios that describe functional requirements. However, most of tools supporting BDD requires that tests should be written using low-level events and components that only exist when the system is already implemented. As a consequence of such low-level of abstraction, BDD tests can hardly be reused with diverse artifacts and with versions of the system. To address this problem, this paper proposes to raise the abstraction level by the means of a behavior-based ontology that is aimed at supporting test automation. The paper presents an ontology and an ontology-based approach for automating the test of functional requirements of interactive systems. With the help of a case study for the flight tickets e-commerce domain, we demonstrate how tests written using our ontology can be used to assess functional requirements using different artifacts, from low-fidelity to full-fledged UI Prototypes.	Automated Requirements Assessment;Behavior-Driven Development;Ontological Modeling;Testing of Interactive Systems	T. R. Silva; J. Hak; M. Winckler	2017 IEEE 11th International Conference on Semantic Computing (ICSC)					Included	Included	new_screen			2						
161	Behave	A Formal Ontology for Describing Interactive Behaviors and Supporting Automated Testing on User Interfaces	Nowadays many software development frameworks implement Behavior-Driven Development (BDD) as a mean of automating the test of interactive systems under construction. Automated testing helps to simulate user's actions on the User Interface and therefore check if the system behaves properly and in accordance to scenarios that describe functional requirements. However, tools supporting BDD run tests on implemented User Interfaces and are a suitable alternative for assessing functional requirements in later phases of the development process. However, even when BDD tests can be written in early phases of the development process they can hardly be used with specifications of User Interfaces such as prototypes. To address this problem, this paper proposes to raise the abstraction level of both system interactive behaviors and User Interfaces by means of a formal ontology that is aimed at supporting test automation using BDD. The paper presents an ontology and an ontology-based approach for automating the test of functional requirements of interactive systems. We demonstrate the feasibility of this ontology-based approach to assess functional requirements in prototypes and full-fledge applications through an illustrative case study of e-commerce applications for buying flight tickets. © 2017 World Scientific Publishing Company.		Silva T.R., Hak J.-L., Winckler M.	International Journal of Semantic Computing					Included	Included	new_screen			2						
162	Behave	Behavior Driven Development: Tools and Challenges	Nowadays testing usually applies Test Driven Development (TDD) which is an approach to software development in which developers write tests first which initially fail and by adding more application codes tests pass. However, the latest development in this field is an extension to Test Driven Development (TDD) which usually referred as Behavior Driven Development (BDD). As being a modified version of TDD, both the technologies have various similarities. Nevertheless, the differences are also not unnoticeable. Where BDD is more about communication and collaboration TDD is more about coders and coding. This paper focuses on the advantages and glitches of TDD which led to the development of along with the method of working of BDD and several tools along with their features and a comparison of their functionalities.	Manual Testing;Test Driven Development (TDD);Behavior Driven Development (BDD);Collaboration	R. K. Lenka; S. Kumar; S. Mamgain	2018 International Conference on Advances in Computing, Communication Control and Networking (ICACCCN)					Included	Included	new_screen			2						
163	Behave	Behavior Driven Development Approach in the Modern Quality Control Process	Nowadays usually the Behavior Driven Development is the approach of choice for the quality control engineers, especially for the long-term projects with the big amount of the audits, because of its main advantage - clear test scenarios visualization and understanding for the not involved persons. However, this approach could not reach its maximum efficiency without proper usage, but the documentation covers only the high-level practices which are not always enough to write the good test scenarios. That is why it is needed to describe the best practices and techniques of the usage of behavior-driven development, formed with the experience of its use. These practices would help to create correct and well understandable behavior scenarios, with the ability to use them as part of the technical documentation. Behavior-driven development would be considered in the comparison with the test-driven development and the domain-driven design approaches - the other important strategies in the quality assurance process.	behaviour driven development;test driven development;quality control;gherkin;practice;technique;scenario;feature;keyword;step	O. Bezsmertnyi; N. Golian; V. Golian; I. Afanasieva	2020 IEEE International Conference on Problems of Infocommunications. Science and Technology (PIC S&T)					Included	Included	new_screen			2						
164	Behave	Behavior driven development for tests and verification	Nowadays, hardware is usually tested and verified at postdesign time. The bottom line is that more effort is spend in the validation phases than in the implementation, because it is harder to fix bugs in later design stages than during the implementation of the design. In contrast, test-first approaches such as test driven development (TDD) have become increasingly important for software development. Behavior driven development (BDD) extends TDD by using natural language style scenarios to describe tests. But both approaches miss formal verification methods which are very important in hardware design. This research project presents a new approach based on BDD that combines testing and verification seamlessly. © Springer Fachmedien Wiesbaden 2015. All rights reserved.		Diepenbeck M.	Formal Modeling and Verification of Cyber-Physical Systems: 1st International Summer School on Methods and Tools for the Design of Digital Systems, Bremen, Germany, September 2015					Excluded	Excluded	new_screen			2						
165	Behave	Towards Automatic Scenario Generation from Coverage Information	Nowadays, the design of software systems is pushed towards agile development practices. One of its most fundamental approaches is Test Driven Development (TDD). This procedure is based on test cases which are incrementally written prior to the implementation. Recently, Behavior Driven Development (BDD) has been introduced as an extension of TDD, in which natural language scenarios are the starting point for the test cases. This description offers a ubiquitous communication mean for both the software developers and stakeholders.Following the BDD methodology thoroughly, one would expect 100% code coverage, since code is only written to make the test cases pass. However, as we show in an empirical study this expectation is not valid in practice. It becomes even worse in the process of development, i.e. the coverage decreases over time. To close the coverage gap, we sketch an algorithm that generates BDD-style scenarios based on uncovered code.		Diepenbeck, Melanie; Soeken, Mathias; Große, Daniel; Drechsler, Rolf	Proceedings of the 8th International Workshop on Automation of Software Test					Included	Included	new_screen			2						
166	Behave	Towards automatic scenario generation from coverage information	Nowadays, the design of software systems is pushed towards agile development practices. One of its most fundamental approaches is Test Driven Development (TDD). This procedure is based on test cases which are incrementally written prior to the implementation. Recently, Behavior Driven Development (BDD) has been introduced as an extension of TDD, in which natural language scenarios are the starting point for the test cases. This description offers a ubiquitous communication mean for both the software developers and stakeholders. Following the BDD methodology thoroughly, one would expect 100 % code coverage, since code is only written to make the test cases pass. However, as we show in an empirical study this expectation is not valid in practice. It becomes even worse in the process of development, i.e. the coverage decreases over time. To close the coverage gap, we sketch an algorithm that generates BDD-style scenarios based on uncovered code.		M. Diepenbeck; M. Soeken; D. Grobe; R. Drechsler	2013 8th International Workshop on Automation of Software Test (AST)					Excluded	Excluded	new_screen			2						
167	Behave	Using Gherkin to Extract Tests and Monitors for Safer Medical Device Interaction Design	Number entry systems on medical devices are safety critical and it is important to get them right. Interaction design teams can be multidisciplinary, and in this work we present a process where the requirements of the system are drawn up using a Controlled Natural Language (CNL) that is understandable by non-technical experts or clients. These CNL requirements can also be directly used by the Quality Assurance (QA) team to test the system and monitor whether or not the system runs as it should once deployed. Since commonly, systems are too complex to test all possible execution paths before deployment, monitoring the system at runtime is useful in order to check that the system is running correctly. If at runtime, it is discovered that an anomaly is detected, the relevant personnel is notified through a report in natural language.	testing; medical devices; runtime verification; user interfaces	Cauchi, Abigail; Colombo, Christian; Francalanza, Adrian; Micallef, Mark; Pace, Gordon	Proceedings of the 8th ACM SIGCHI Symposium on Engineering Interactive Computing Systems					Included	Included	new_screen			2						
168	Behave	A Behavior-Driven Approach to Intent Specification for Software-Defined Infrastructure Management	"One of the goals of Software-Defined Networking (SDN) is to allow users to specify high-level policies into lower level network rules. Managing a network and decide what policy set is appropriate requires, however, expertise and low level know-how. An emerging SDN paradigm is to allow higher-level network level decisions wishes in the form of ""intents"". Despite its importance in simplifying network management, intent specification is not yet standardized. In this work, we propose a northbound interface (NBI) for intent declaration, based on Behavior-Driven Development. In our approach, intents are specified in plain English and translated by our system into pre-compiled network policies, that are in turn, converted into low-level rules by the software-defined infrastructure e.g. an SDN controller. We demonstrated our behavior-driven approach with two practical use cases: service function chaining deployed on OpenStack, supported by both ONOS and Ryu controllers, and dynamic firewall programming. We also measured the overhead and response time of our NBI. We believe that our approach is far more general and paves the way for a more expressive and simplified northbound interface for intent-driven networking."		F. Esposito; J. Wang; C. Contoli; G. Davoli; W. Cerroni; F. Callegati	2018 IEEE Conference on Network Function Virtualization and Software Defined Networks (NFV-SDN)					Included	Included	new_screen			2						
169	Behave	Feature-Trace: Generating Operational Profile and Supporting Testing Prioritization from BDD Features	Operational Profiles provide quantitative information about how the software will be used, which supports highlighting those software components more sensitive to reliability based on their profile usage. However, the generation of Operational Profiles usually requires a considerable team effort to liaise requirements specification until their reification into expected software artifacts. In this sense, it becomes paramount in the software life cycle the ability to seamlessly or efficiently perform traceability from requirement to code, embracing the testing process as a means to ensure that the requirements are satisfiably covered and addressed. In this work, we propose the Feature-Trace approach which merges the advantages of the Operational Profile and the benefits of the requirements-to-code traceability present in the BDD (Behavior-Driven Development) approach. The primary goal of our work is to use the BDD approach as an information source for the semi-automated generation of the Operational Profile. The proposed approach was evaluated on the Diaspora software, on a GitHub open source software. The case study revealed that the Feature-Trace approach is capable of extracting the operational profile seamlessly from the specified Diaspora's BDD features as well as obtaining and presenting vital information to guide the process of test cases prioritization.	behavior-driven development; operational profile; requirements traceability; testing	Fazzolino, Rafael; Rodrigues, Genaína Nunes	Proceedings of the XXXIII Brazilian Symposium on Software Engineering					Included	Included	new_screen			2						
170	Behave	Cucumber Cookbook	"Over 35 hands-on recipes to efficiently master the art of behaviour-driven development using Cucumber-JVM About This BookCreate a test automation framework to handle web, REST, and native mobile application automationDiscover Glue code, Hooks, Tags, and Cucumber's integration with Maven, Jenkins, and GitComprehensive recipes in Cucumber for behaviour-driven development and test automationWho This Book Is ForThis book is intended for business and development personnel who want to use Cucumber for behavior-driven development and test automation. Readers with some familiarity with Cucumber will find this book of most benefit.Since the main objective of this book is to create test automation frameworks, previous experience in automation will be helpful.What You Will Learn Explore the usage of the Gherkin Language to write meaningful and smart Feature files Understand Scenario, Steps, Backgrounds, Scenario Outlines, and Data Tables Discover the concepts of Glue Code and Step Definitions in detail Gain insights into the different types of Step Definitions, Regular Expressions, Doc Strings, Data Table transformations, and Capture Groups Master the advanced concepts of implementing Tags and Hooks Override default Cucumber options and settings along with different output report formats Run Jenkins and Cucumber from Terminal while running various Cucumber Scenarios in parallel In DetailToday, behaviour-driven development (BDD) is gaining popularity around the world. Cucumber-JVM is one of the fastest growing tools and offers a cutting-edge platform for conceptualizing and implementing BDD. The variety of features available within Cucumber enhances the experience of implementing BDD for both business and development teams.This book provides you with the skills you need to successfully create, customize, and configure the Cucumber framework. You will discover how to create Feature files, and Step Definitions, and enable various configurations, such as ""Before"" and ""After"" functions, with fun exercises. You'll round off your learning by creating automation frameworks to automate Web, REST, and Mobile apps."		Garg, Shankar						Excluded	Excluded	new_screen			2						
171	Behave	A semantic wiki approach to enable behaviour driven requirements management	Poorly managed requirements are considered as one of the principal causes of projects failure and consequently companies struggle to find an effective solution for requirements elicitation and further management. The adoption of such solution becomes even more difficult when the collaboration between different departments (e.g. marketing and development) is necessary. To address this challenge, the authors propose a methodology for requirements management based on Semantic Wiki and Behaviour Driven Development (BDD). BDD allows developers and end-users to interoperate and encourages seamless collaboration between all project participants. It also certifies that requirements are treated properly by their associated developments through the connection of textual descriptions to functional tests. Semantic wikis can be an added value in requirements management due to their enhanced browser interface and collaborative knowledge sharing capability. They allow stakeholders to participate in requirements management independently of their location. This is of major importance to reduce the problem of lack of inputs from interested parties. Moreover, with semantic wikis adoption, end-users and ontologies can coexist in one system since wiki pages are presented in a human-readable format in parallel to their formal representation in ontologies. This knowledge representation supports companies' decision-making by allowing managers to prioritize implementations, to keep a trace of requirements evolution, and reuse implementations when new requirements enter the system.		Marques-Lucena C., Agostinho C., Sarraipa J., Jardim-Goncalves R.	Control Engineering and Applied Informatics					Included	Included	new_screen			2						
172	Behave	Dynamic signal driving strategy based high speed and low powered dual edge triggered flip flop design used memory applications	Power utilization assumes a massive part in any of the integrated circuits, and it’s rundown as a standout amongst essential difficulties in the universal innovation guide into semiconductors. Generally in integrated circuit, flip-flop and clock distribution system consume a lot of energy since they make and utilize the most extreme number of internal transitions. In the clock distribution system, the clock signal circulates from a typical point to every one of the components that required for the circuit. However this capacity is more important to the synchronous framework, much consideration needs to provide for the attributes of these clock signals. In the sequential circuits, a clock distribution system spends a lot of power given the high operating frequency of high capacitance. An existing approach to reducing the limits of a clock signal is based on the quantity of clocked transistors. In this, an advanced procedure is proposed and evaluated by utilizing Dual-Edge Triggered Flip-Flop (DETFF) depends on the Dynamic Signal Driving (DSD) strategy. This DETFF is executed in sequential circuits that have been ordered using Tanner Electronic Design Automation (EDA) tool which is used to simulate and examine control by using Dynamic Signal Driving (DSD) strategy. The outcomes demonstrate that the total power utilization is decreased in sequential benchmark circuit design. A number of Flip flops have been designed by various technologies such as reducing area, delay, and power, but this proposed dynamic signal driving scheme can be used for any integrated circuit- that can be reduced to all these three parameters to give the best trade-off for a particular ASIC platform.	Flip flop, Clock distribution system, Clocked transistor, Tanner, ASIC	Prithivi Raj, M.; Kavithaa, G.	Microprocessors and Microsystems					Excluded	Excluded	new_screen			2						
173	Behave	Pro Agile .NET Development with SCRUM	Pro Agile .NET Development with SCRUMguides youthrough a real-world ASP.NET project and shows how agile methodology is put into practice. There is plenty of literature on the theory behind agile methodologies, but no book on the market takes the concepts of agile practices and applies these in a practical manner to an end-to-end ASP.NET project, especially the estimating, requirements and management aspects of a project. Pro Agile .NET Development with SCRUM takes you through the initial stages of a project–gathering requirementsand setting up an environment–through to the development and deployment stages using an agile iterative approach: namely, Scrum. In the book,you'll focuson delivering an enterprise-level ASP.NET project. Each chapter is in iterations or sprints, putting into practice the features of agile–user stories, test-driven development (TDD), behavior-driven development (BDD), continuous integration, user acceptance testing, extreme programming, Scrum, design patterns and principles, inside-out development, lean developent, KanBan boards, and more. An appendix features code katas designed for the reader to get up-to-speed with some of the features of extreme programming, while also showcasing popular open-source frameworks to assist in automated testing and mocking. What you'll learn Gain practical knowledge on employing the Scrum project methodology using a real-world ASP.NET project Seehow extreme programming features in real world .NET projects Learnbest-practice tools foruser interfaceanduser acceptance testing, such as waitiN Discoverdetails on how to capture requirements and drive development using user stories Learnhow to estimate and plan agile projects and work with business stakeholders through a practical example Uncover tips for developing using the outside-in, TDD and BDD methodologies Gain information on tracking the progress of a project through burn down charts, iterations and retrospectives Who this book is for Experienced .NET developers who are looking to see how the Scrum agile project methodology and extreme programming features are employed in a real-world .NET application.		Blankenship, Jerrel; Bussa, Matthew; Millett, Scott						Excluded	Excluded	new_screen			2						
174	Behave	Behavior-driven development in product configuration systems	Product Configuration Systems (PCS) are increasingly used by companies to automate the performance of the sales and engineering processes. Since the benefits from such projects have huge variations, it is crucial to make the right decisions when scoping and developing PCSs. The development of PCS is influenced by both business interests and technical insights. Developers of PCS face various challenges while working in team, including different stakeholders such as business owners, developers, project managers, and product experts. The more diverse the team is, the more significant are the challenges. This paper suggests that Behavior-driven Development (BDD) may provide configuration teams with a specific structure to express scenarios (and thus constraints) on PCS in natural language. BDD may yield benefits such as a better expression of PCS constraints, more efficient communication of requirements and incorporation of the expressed rules in a software transformation process. In other words, applying BDD may eliminate unnecessary tasks when gathering knowledge, developing, and testing PCS projects. In this paper, we present a novel approach from an ongoing project on how to relate BDD to the development process of PCS while using Scrum-based methods. © 2018 CEUR-WS. All rights reserved.		Shafiee S., Hvam L., Haug A., Wautelet Y.	CEUR Workshop Proceedings					Included	Included	new_screen			2						
175	Behave	Light-Weight Software Product Lines for Small and Medium-Sized Enterprises (SMEs)	Product line engineering practices promote the idea of systematic reuse of core assets and have been reported to decrease time-to-market and development costs for new products. However, our recent efforts to transfer our product line engineering knowledge to several of our small and medium-size enterprise industrial partner showed that there are challenges that need to be addressed before core product line engineering ideas can be deployed in SME context. These challenges include upfront investment costs, business traceability, levels of abstraction of functional features and semantic distinction between functional and non-functional software aspects. In order to address these challenges within the context of SMEs, we adopt and extend the behavior-driven development methodology in a way to not only offer agility in practice but also to equip software developers with the means to capture and manage software variability within the behavior-driven development process. We introduce the details of the extended methodology and discuss its advantages and disadvantages in detail.		Bagheri, Ebrahim; Ensan, Faezeh	Proceedings of the 2013 Conference of the Center for Advanced Studies on Collaborative Research					Included	Included	new_screen			2						
176	Behave	Chapter 8 - Integrating Automation into Your Development Process	Publisher Summary The concept of continuous integration has been around for quite a while now. There are many tools to provide continuous integration and surprisingly, some even work together. Any investment in continuous integration will pay off but it requires discipline that few developers, QA resources, or management actually have at the start of the process. The challenge is to train the development staff and the QA to use continuous integration to work smarter, not harder. There is much interest in continuous integration, and many organizations are implementing continuous integration tools as part of their move to agile development. Difficulty surrounds this move because not only do developers have to change some working habits, but also there typically is a large investment required matching the capabilities of the tool to the organization itself and for that reason alone it is daunting. Many tools, whether they are open source or commercial products, exist for performing automation. The platform in use for development, including the operating system or the development environment platform, as well as the delivery platform of the end product, may restrict the selection of tools. Additionally, the software development language in use may dictate a narrow selection of tools. Some development shops may have restrictions regarding what software can be brought in due to security concerns.		Holtsnider, Bill; Wheeler, Tom; Stragand, George; Gee, Joseph						Excluded	Excluded	new_screen			2						
177	Behave	Chapter 4.1 - The Psychology of Programming in the Large: Team and Organizational Behaviour	Publisher Summary This chapter focuses on the psychology of programming in relation to team and organizational behavior. Software development must be studied at several behavioural levels. Organizing programmers into teams superimposes a layer of social behavior on the cognitive requirements of programming tasks. Two structures have been proposed for programming teams based on the centralized versus decentralized team organizations often studied in group dynamics research. A hybrid approach to structuring programming teams might be taken on large projects that have characteristics favourable to different types of programming teams. Programming team activities offer many opportunities for peer review activities that may be formal or informal components of the development process. On the other hand, team methodologies must focus on coordinating the tasks and product concept. The structure of programming teams should reflect the nature of the task rather than the organization, allow members to speak as if with one mind, and determine the tasks the team can effectively handle.		Curtis, Bill; Walz, Diane						Excluded	Excluded	new_screen			2						
178	Behave	Intuitive design: framing a software test system as a status reporting tool for business	Purpose: This paper aims to present a conceptual framework of how software teams can leverage the implicit information of implemented acceptance tests to cater to the needs of decision makers. The research questions on this framework were how business stakeholders can receive project status information in an intuitive way and how this framework can guarantee the traceability of tests to requirements. Design/methodology/approach: The conceptual framework delineates the design of an acceptance test framework in three aspects: how the requirements model reflects the evolving states of requirement maturity over a project, how the acceptance test model becomes synchronized with the requirements model without a traceability matrix and how the acceptance test model communicates business value to the decision makers. Findings: In an industrial case study, the presented framework yielded the positive effects of intuitive understanding by business stakeholders, high test coverage of requirements and distinctly reduced manual quality assurance (QA) work by automated testing for browsers and mobile devices. Practical implications: The presented framework can help to convince business stakeholders to approve the budget for building a testing framework because it delivers them value as a status reporting tool. Originality/value: This paper is the first to describe a step-by-step approach to solving a critical problem that IT departments frequently face. The solution consists in a new way of transforming the perception of a technical framework into a reporting tool for business information by intuitive design. The idea of mapping hierarchically corresponding abstraction layers can be transferred to other engineering domains. © 2017, © Emerald Publishing Limited.		So C.	Journal of Engineering, Design and Technology					Included	Included	new_screen			2						
179	Behave	IOS Code Testing: Test-Driven Development and Behavior-Driven Development with Swift	Put into motion practical examples to master Test-Driven Development (TDD) and acceptance testing in Swift. This book uses a pragmatic approach to writing well-tested code and provides techniques that can be used to retrofit tests to legacy code bases. You'll be introduced to basic principles of TDD, such as Test First, Red-Green-Refactor, Remove Duplicate code, Dependency Injection, and Single Responsibility. Approaches covered include TDD, behavior-driven development (BDD), UI, and acceptance testing with common standard/open source frameworks. iOS Code Testing offers helpful instruction to teach iOS developers to retrospectively fit tests to legacy code, refactor legacy code so as to make the code more testable, install and configure a popular Swift BDD framework, practice BDD with Xcode, and create automated UI tests with Xcode. Additionally, many projects have legacy code bases. Legacy code is often seen as a blocker when it comes to implementing any kind of testing. What You Will Learn Fit test to legacy code retrospectively Install and configure popular Swift BDD frameworks Practice BDD with Xcode Who This Book Is For Software practitioners, such as Swift developers and mobile app testers.		Mishra, Abhishek						Excluded	Excluded	new_screen			2						
180	Behave	Modern and Responsive Mobile-enabled Web Applications	Rapid web technology improvements in the last few years have powered software developers to quickly write responsive mobile-friendly applications. The innovative web frameworks and libraries make it easy to have same software code base for desktop and mobile devices. Single-page applications offer a more-native-app-like experience to the user. This also means a web application can easily be converted to a native mobile application if desired. This allows software products to be evolved continuously at a much faster pace with features added on daily basis. The software companies who can adopt these technologies will most likely see the benefit in the long run as they can offer new and modified products faster than their competitors. In this paper, we review some of the state-of-the-art web technologies, third-party libraries, and frameworks for quick interactive web development. Finally, we present a simple interactive browser-based, mobile friendly web application which was developed using one of the latest web development framework.	Web-based Applications, JavaScript, Web Framework, Mobile-friendly Application, Single-Page Applications	Shahzad, Farrukh	Procedia Computer Science					Excluded	Excluded	new_screen			2						
181	Behave	Reengineering legacy systems with transaction model	Reengineering of legacy systems is one of trickiest challenges in software development. The paper addresses methodologies applicable to re-engineering legacy information systems. Specifically, it points out a possibility to couple ontological descriptions of the enterprise with information systems features. Such interconnection verifies whether a functionality implemented in the information system relates to business tasks or not. Business processes formulated as DEMO transaction patterns together with Behavior-Driven Development technique enable to link existing businesses processes to production codebase. © 2018 Author(s).		Matula J., Zacek J.	AIP Conference Proceedings					Included	Included	new_screen			2						
182	Behave	A Requirement-based Regression Test Selection Technique in Behavior-Driven Development	Regression testing is an essential software maintenance activity before the release of a new version implementing a bug fix or a new feature. A regression test selection (RTS) technique chooses a subset of existing test cases to ensure that the system will not be adversely affected by the latest modifications. With the rise of DevOps, behavior-driven development (BDD) is growing in popularity as it is in close alignment with agile practices, for example, continuous integration. Hence, it is necessary to propose a novel and effective RTS technique for BDD specifically to accelerate the development process while ensuring software quality. Since most existing techniques for RTS are code-based and thus subject to some limitations, we present a requirement-based technique which uses the requirements in BDD to select test cases in both high-level (acceptance testing) and low-level (unit testing). Our technique firstly illustrates the new requirement with a scenario, and subsequently computes the semantic similarity of the new scenario and all existing scenarios with the vector space model. According to the results, the modification-traversing regression test cases can be selected in a semi-automated way. We also conduct an experimental study to evaluate our technique in terms of inclusiveness, precision, efficiency and generality. The study shows that our technique is applicable for BDD and effective in practice.	regression test selection;behavior-driven development;requirement-based technique;vector space model	J. Xu; Q. Du; X. Li	2021 IEEE 45th Annual Computers, Software, and Applications Conference (COMPSAC)					Included	Included	new_screen			2						
183	Behave	Interface Responsibility Patterns: Processing Resources and Operation Responsibilities	Remote Application Programming Interfaces (APIs), as for instance offered in microservices architectures, are used in almost any distributed system today and are thus enablers for many digitalization efforts. It is hard to design such APIs so that they are easy and effective to use; maintaining their runtime qualities while preserving backward compatibility is equally challenging. Finding well suited granularities in terms of the architectural capabilities of endpoints and the read-write semantics of their operations are particularly important design concerns. Existing pattern languages have dealt with local APIs in object-oriented programming, with remote objects, with queue-based messaging and with service-oriented computing platforms. However, patterns or equivalent guidances for the architectural design of API endpoints, operations and their request and response message structures are still missing. In this paper, we extend our microservice API pattern language (MAP) and introduce endpoint role and operation responsibility patterns, namely Processing Resource, Computation Function, State Creation Operation, Retrieval Operation, and State Transition Operation. Known uses and examples of the patterns are drawn from public Web APIs, as well as application development and system integration projects the authors have been involved in.		Zimmermann, Olaf; Lübke, Daniel; Zdun, Uwe; Pautasso, Cesare; Stocker, Mirko	Proceedings of the European Conference on Pattern Languages of Programs 2020					Excluded	Excluded	new_screen			2						
184	Behave	A Conceptual Metamodel to Bridging Requirement Patterns to Test Patterns	Requirement patterns represent an abstraction of an application's behaviors and services that, in turn, may be replicated in similar applications. However, there has been a lack of efforts exploiting the benefits of requirement patterns in other phases of the software development life cycle, besides the requirements engineering itself. To address this gap, we propose the Software Pattern MetaModel (SoPaMM) that bridges requirement patterns to groups of scenarios with similar behaviors in the form of test patterns. SoPaMM allows the description of the behavior of a requirement pattern through a time executable and easy-to-use language aiming at the automatic generation of test patterns. Using SoPaMM, we model and implement a behavior-driven functional requirement pattern for a web-based user authentication application. Our preliminary results point out that a requirement pattern can be an executable specification capable of generating automated tests.	behavior; metamodeling; requirement pattern; reuse; test pattern	Kudo, Taciana Novo; Bulcão-Neto, Renato F.; Vincenzi, Auri M. R.	Proceedings of the XXXIII Brazilian Symposium on Software Engineering					Included	Included	new_screen			2						
185	Behave	A Framework to Diminish the Gap between the Business Specialist and the Software Designer	"Requirements Engineering establishes the process for defining requirements as one in which elicitation, modeling and analysis are tasks which must be carried out. This process should involve different stakeholders and their different viewpoints. Among these stakeholders, there is the software designer, responsible for creating models based on the information gathered by business specialists. However, this communication channel may create some ""noise"" that leads to information being lost. This loss produces a semantic gap between what is desired and what will be developed. The semantic gap is characterized by inconsistencies in the requirements represented by scenarios–user stories in a behavior-driven context–and by the conceptual model. This paper presents an interactive approach to the agile requirements modeling, thus fostering greater consistency between the artifacts of the scenarios and the conceptual model. This consistency is ensured by using a mind model specification which will serve as a basis for transforming the definitions of the scenario and generating a conceptual model represented by a UML class diagram. The mind model represents the main role of this approach, and functions as a bond that represents the business entities, thus enabling the requirements to be more consistent with the reality of the business."	Behaviour Driven Development; Agile Modeling Requirements; Domain Model; Mind Map Modeling; UML	Wanderley, Fernando; da Silveria, Denis Silva	Proceedings of the 2012 Eighth International Conference on the Quality of Information and Communications Technology					Included	Included	new_screen			2						
186	Behave	Using Behaviour-driven Requirements Engineering for Establishing and Managing Agile Product Lines: An Observational Study	Requirements engineering in agile product line engineering refers to both common and variability components establishing a software. Although it is conventional for the requirements engineering to take place in a dedicated upfront domain analysis phase, agile-based environments denounce such a proactive behaviour. This paper provides an observational study examining a reactive incremental requirement engineering approach called behaviour-driven requirements engineering. The proposed approach uses behaviour-driven development to establish and maintain agile product lines. The findings of the study are very promising and suggest the following: the approach is easy to understand and quick to learn; the approach supports the constantly changing nature of software development; and using behaviour-driven requirements engineering produces reliable and coherent requirements. In practice, the observational study showed that using the proposed approach saved time for development team and customers, decreased costs, improved the software quality, and shortened the time-to-market. © 2021. All Rights Reserved.		Elshandidy H., Mazen S., Hassanein E., Nasr E.	International Journal of Advanced Computer Science and Applications					Included	Included	new_screen			2						
187	Behave	Towards Automated Testing of RPA Implementations	Robotic Process Automation (RPA) is a technology that has grown tremendously in the last years, due to its usability in the area of process automation. An essential part of any software development process is quality assurance, so testing will be very important for RPA processes. However, the classical software techniques are not always suitable for the RPA software robots due to the mix of the graphical description of the robots and their implementations. In this short paper, we describe the state of the practice for testing of software robots and propose some ideas of test automation using model-based testing.	Test automation; Model-based testing; Robotic Process Automation (RPA); RPA testing	Cernat, Marina; Staicu, Adelina Nicoleta; Stefanescu, Alin	Proceedings of the 11th ACM SIGSOFT International Workshop on Automating TEST Case Design, Selection, and Evaluation					Excluded	Excluded	new_screen			2						
188	Behave	Agent-oriented software patterns for rapid and affordable robot programming	Robotic systems are often quite complex to develop; they are huge, heavily constrained from the non-functional point of view and they implement challenging algorithms. The lack of integrated methods with reuse approaches leads robotic developers to reinvent the wheel each time a new project starts. This paper proposes to reuse the experience done when building robotic applications, by catching it into design patterns. These represent a general mean for (i) reusing proved solutions increasing the final quality, (ii) communicating the knowledge about a domain and (iii) reducing the development time and effort. Despite of this generality, the proposed repository of patterns is specific for multi-agent robotic systems. These patterns are documented by a set of design diagrams and the corresponding implementing code is obtained through a series of automatic transformations. Some patterns extracted from an existing and freely available repository are presented. The paper also discusses an experimental set-up based on the construction of a complete robotic application obtained by composing some highly reusable patterns.	Multi-agent systems, Design patterns, Pattern oriented design, Robotics systems	Chella, Antonio; Cossentino, Massimo; Gaglio, Salvatore; Sabatucci, Luca; Seidita, Valeria	Journal of Systems and Software					Excluded	Excluded	new_screen			2						
189	Behave	Ruby on Rails Tutorial: Learn Web Development with Rails	Ruby on Rails Tutorial by Michael Hartl has become a must-read for developers learning how to build Rails apps. Peter Cooper, Editor of Ruby Inside Using Rails, developers can build web applications of exceptional elegance and power. Although its remarkable capabilities have made Ruby on Rails one of the worlds most popular web development frameworks, it can be challenging to learn and use. Ruby on Rails Tutorial, Second Edition, is the solution. Best-selling author and leading Rails developer Michael Hartl teaches Rails by guiding you through the development of your own complete sample application using the latest techniques in Rails web development. The updates to this edition include all-new site design using Twitters Bootstrap; coverage of the new asset pipeline, including Sprockets and Sass; behavior-driven development (BDD) with Capybara and RSpec; better automated testing with Guard and Spork; roll your own authentication with has_secure_password; and an introduction to Gherkin and Cucumber. Youll find integrated tutorials not only for Rails, but also for the essential Ruby, HTML, CSS, JavaScript, and SQL skills youll need when developing web applications. Hartl explains how each new technique solves a real-world problem, and he demonstrates this with bite-sized code thats simple enough to understand, yet novel enough to be useful. Whatever your previous web development experience, this book will guide you to true Rails mastery. This book will help you Install and set up your Rails development environment Go beyond generated code to truly understand how to build Rails applications from scratch Learn test-driven development (TDD) with RSpec Effectively use the Model-View-Controller (MVC) pattern Structure applications using the REST architecture Build static pages and transform them into dynamic ones Master the Ruby programming skills all Rails developers need Define high-quality site layouts and data models Implement registration and authentication systems, including validation and secure passwords Update, display, and delete users Add social features and microblogging, including an introduction to Ajax Record version changes with Git and share code at GitHub Simplify application deployment with Heroku		Hartl, Michael						Excluded	Excluded	new_screen			2						
190	Behave	Offshore Development Center Management in Action	Serving as a virtual extension of the Customer's IT Department, the Offshore Development Center (ODC) model provides certain benefits in comparison with in-house teams including reduced development complexity, reduced operating expense, and access to a larger pool of talents. Nevertheless, ODCs are prone to problems in Scope, Schedule, Quality, Human Resources, and Communication. From the experiences of Project Managers who have worked in Offshore Development Centers set up by FPT Software- a leading IT Outsourcing Service provider, this paper offers a look at actual problems encountered in ODCs. We then provide a reference ODC Management Framework, which consists of Best Practices that we have applied into an ODC serving a Media Industry customer over the last 4 years. The results of applying the model are discussed to prove its effectiveness.	Offshore; Offshore development center; Outsourcing	Hung, Phan Duy; Cuong, Le Gia; Bach, Nguyen Luu	Proceedings of the 2020 5th International Conference on Intelligent Information Technology					Excluded	Excluded	new_screen			2						
191	Behave	Test-Driven Infrastructure with Chef: Bring Behavior-Driven Development to Infrastructure as Code	Since Test-Driven Infrastructure with Chef first appeared in mid-2011, infrastructure testing has begun to flourish in the web ops world. In this revised and expanded edition, author Stephen Nelson-Smith brings you up to date on this rapidly evolving discipline, including the philosophy driving it and a growing array of tools. Youll get a hands-on introduction to the Chef framework, and a recommended toolchain and workflow for developing your own test-driven production infrastructure. Several exercises and examples throughout the book help you gain experience with Chef and the entire infrastructure-testing ecosystem. Learn how this test-first approach provides increased security, code quality, and peace of mind.Explore the underpinning philosophy that infrastructure can and should be treated as code Become familiar with the MASCOT approach to test-driven infrastructure Understand the basics of test-driven and behavior-driven development for managing change Dive into Chef fundamentals by building an infrastructure with real examples Discover how Chef works with tools such as Virtualbox and Vagrant Get a deeper understanding of Chef by learning Ruby language basics Learn the tools and workflow necessary to conduct unit, integration, and acceptance tests		Nelson-Smith, Stephen						Excluded	Excluded	new_screen			2						
192	Behave	A permissioned blockchain-based implementation of LMSR prediction markets	Since the seminal work by Hanson (2003), the Logarithmic Market Scoring Rule (LMSR) has become the de facto market-maker mechanism for prediction markets. We suggest in this paper three potential issues with centralized implementations of LMSR, which we refer to as the availability, security, and privacy problems. We also explain how a permissioned blockchain-based implementation of LMSR effectively solves all the above problems. Following the design science research framework (Peffers et al., 2007), our main contribution is a fully functional permissioned blockchain-based implementation of LMSR that is ready to be deployed. We believe our results are of great value not only to prediction market researchers and practitioners looking for LMSR implementations, but also to blockchain professionals looking for fully developed solutions as well as applications of suitable research frameworks to guide blockchain research and development.	Blockchain, Design science, Logarithmic Market Scoring Rule, Prediction markets	Carvalho, Arthur	Decision Support Systems					Excluded	Excluded	new_screen			2						
193	Behave	Introducing continuous experimentation in large software-intensive product and service organisations	Software development in highly dynamic environments imposes high risks to development organizations. One such risk is that the developed software may be of only little or no value to customers, wasting the invested development efforts. Continuous experimentation, as an experiment-driven development approach, may reduce such development risks by iteratively testing product and service assumptions that are critical to the success of the software. Although several experiment-driven development approaches are available, there is little guidance available on how to introduce continuous experimentation into an organization. This article presents a multiple-case study that aims at better understanding the process of introducing continuous experimentation into an organization with an already established development process. The results from the study show that companies are open to adopting such an approach and learning throughout the introduction process. Several benefits were obtained, such as reduced development efforts, deeper customer insights, and better support for development decisions. Challenges included complex stakeholder structures, difficulties in defining success criteria, and building experimentation skills. Our findings indicate that organizational factors may limit the benefits of experimentation. Moreover, introducing continuous experimentation requires fundamental changes in how companies operate, and a systematic introduction process can increase the chances of a successful start.	Continuous experimentation, Experiment-driven software development, Product management, Agile software development, Lean software development, Lean startup	Yaman, Sezin Gizem; Munezero, Myriam; Münch, Jürgen; Fagerholm, Fabian; Syd, Ossi; Aaltola, Mika; Palmu, Christina; Männistö, Tomi	Journal of Systems and Software					Excluded	Excluded	new_screen			2						
194	Behave	Investigating Agile Practices in Software Startups	Software development practices have smoothly shifted from traditional software development to new approaches that fit better to the real and unpredictable world. Agile practices might help practitioners respond quickly to customer change requests and deliver a working software on-schedule. Software startups are companies that develop innovative and software-intensive products and services in a dynamic and fast-growing market. This study aims to investigate the use of agile practices in software startups. We conducted 14 in-depth semi-structured interviews with the CEO and CTO from early-stage software startups. The results indicate that DevOps, Fundamentals, Design and Extreme Programming are the most used agile practice areas. Our results open up an opportunity to improve software engineering practices in early-stage software startups.	Software engineering; Agile practices; Interview; Software startups	Souza, Renata; Rocha, Larissa; Silva, Franklin; Machado, Ivan	Proceedings of the XXXIII Brazilian Symposium on Software Engineering					Excluded	Excluded	new_screen			2						
195	Behave	Behavior-Driven Development: A Case Study on Its Impacts on Agile Development Teams	Software development practices which enhance software quality and help teams better develop collaboratively have received attention by the academic community. Among these techniques is Behavior-Driven Development (BDD), a development method which proposes software to be developed focusing primarily on its expected behavior. In this context, this paper investigates how BDD impacts agile software development teams. In order to achieve this, we have conducted a case study on a mobile application development environment which develops software using agile. In total, 42 interviews were performed. Our results indicate that BDD can have positive impacts, increasing collaboration among team members, and negative impacts, like difficulties in writing unit tests. We concluded that BDD has more positive than negative outcomes.	Behavior-Driven Development; Agile Development; Challenge Based Learning; Software Engineering	Nascimento, Nicolas; Santos, Alan R.; Sales, Afonso; Chanin, Rafael	Proceedings of the IEEE/ACM 42nd International Conference on Software Engineering Workshops					Included	Included	new_screen			2						
196	Behave	Using grounded theory to understand software process improvement: A study of Irish software product companies	Software process improvement (SPI) aims to understand the software process as it is used within an organisation and thus drive the implementation of changes to that process to achieve specific goals such as increasing development speed, achieving higher product quality or reducing costs. Accordingly, SPI researchers must be equipped with the methodologies and tools to enable them to look within organisations and understand the state of practice with respect to software process and process improvement initiatives, in addition to investigating the relevant literature. Having examined a number of potentially suitable research methodologies, we have chosen Grounded Theory as a suitable approach to determine what was happening in actual practice in relation to software process and SPI, using the indigenous Irish software product industry as a test-bed. The outcome of this study is a theory, grounded in the field data, that explains when and why SPI is undertaken by the software industry. The objective of this paper is to describe both the selection and usage of grounded theory in this study and evaluate its effectiveness as a research methodology for software process researchers. Accordingly, this paper will focus on the selection and usage of grounded theory, rather than results of the SPI study itself.	Software engineering, Software process improvement, Qualitative research methods, Grounded theory	Coleman, Gerry; O’Connor, Rory	Information and Software Technology					Excluded	Excluded	new_screen			2						
197	Behave	Using Spring Roo for the Test-Driven Development of Web Applications	Software should be developed in a way that achieves high external and internal quality. Most programs have to be maintained or are extended. They should not only adhere to their requirements but allow to be efficiently changed. Model-driven software development (MDSD) and test-driven development (TDD) are techniques that help to satisfy this demand. We present a novel approach combining MDSD and TDD while using the Spring Roo Web development framework. Besides discussing existing work and the background, we sketch a test-driven Web development process. We then evaluate its feasibility in an exemplary scenario. Thereby, we contribute to the body of scientific knowledge on Web development frameworks in the field of MDSD and TDD.	test-driven development; TDD; spring; spring roo; web application; web development	Majchrzak, Tim A.; Simon, Andreas	Proceedings of the 27th Annual ACM Symposium on Applied Computing					Excluded	Excluded	new_screen			2						
198	Behave	A Survey of Software Testing Practices in Canada	Software testing is an important activity in the software development life-cycle. In an earlier study in 2009, we reported the results of a regional survey of software testing practices among practitioners in the Canadian province of Alberta. To get a larger nationwide view on this topic (across Canada), we conducted a newer survey with a revised list of questions in 2010. Compared to our previous Alberta-wide survey (53 software practitioners), the nation-wide survey had larger number of participants (246 practitioners). We report the survey design, execution and results in this article. The survey results reveal important and interesting findings about software testing practices in Canada. Whenever possible, we also compare the results of this survey to other similar studies, such as the ones conducted in the US, Sweden and Australia, and also two previous Alberta-wide surveys, including our 2009 survey. The results of our survey will be of interest to testing professionals both in Canada and world-wide. It will also benefit researchers in observing the latest trends in software testing industry identifying the areas of strength and weakness, which would then hopefully encourage further industry-academia collaborations in this area. Among the findings are the followings: (1) the importance of testing-related training is increasing, (2) functional and unit testing are two common test types that receive the most attention and efforts spent on them, (3) usage of the mutation testing approach is getting attention among Canadian firms, (4) traditional Test-last Development (TLD) style is still dominating and a few companies are attempting the new development approaches such as Test-Driven Development (TDD), and Behavior-Driven Development (BDD), (5) in terms of the most popular test tools, NUnit and Web application testing tools overtook JUnit and IBM Rational tools, (6) most Canadian companies use a combination of two coverage metrics: decision (branch) and condition coverage, (7) number of passing user acceptance tests and number of defects found per day (week or month) are regarded as the most important quality assurance metrics and decision factors to release, (8) in most Canadian companies, testers are out-numbered by developers, with ratios ranging from 1:2 to 1:5, (9) the majority of Canadian firms spent less than 40% of their efforts (budget and time) on testing during development, and (10) more than 70% of respondents participated in online discussion forums related to testing on a regular basis.	Software testing; Survey; Canada; Industry practices	Garousi, Vahid; Zhi, Junji	J. Syst. Softw.					Excluded	Excluded	new_screen			2						
199	Behave	Software Testing: High-Impact Strategies - What You Need to Know Definitions, Adoptions, Impact, Benefits, Maturity, Vendors	Software testing is an investigation conducted to provide stakeholders with information about the quality of the product or service under test. Software testing also provides an objective, independent view of the software to allow the business to appreciate and understand the risks of software implementation. Test techniques include, but are not limited to, the process of executing a program or application with the intent of finding software bugs (errors or other defects). This book is your ultimate resource for Software Testing. Here you will find the most up-to-date information, analysis, background and everything you need to know. In easy to read chapters, with extensive references and links to get you to know all there is to know about Software Testing right away, covering: Software testing, Acceptance testing, Ad hoc testing, Agile testing, All-pairs testing, American Software Testing Qualifications Board, Api Sanity Autotest, Association for Software Testing, Attack patterns, Augmented Reality-based testing, Australian and New Zealand Testing Board, Automated Testing Framework, Avalanche (dynamic analysis tool), Bebugging, Behavior Driven Development, Black-box testing, Block design, Boundary case, Boundary testing, Boundary-value analysis, Browser speed test, Bs 7925-1, Bs 7925-2, Bug bash, Build verification test, Ca/Eztest, Cause-effect graph, Centercode, Characterization test, Cloud testing, Code coverage, Code integrity, Codenomicon, Compatibility testing, Component-Based Usability Testing, Conference Room Pilot, Conformance testing, Core Security, Corner case, Daikon (system), Data-driven testing, Decision table, Decision-to-decision path, Design predicates, Development, testing, acceptance and production, DeviceAnywhere, Dry run (testing), Dynamic program analysis, Dynamic testing, Edge case, Endeavour Software Project Management,		Roebuck, Kevin						Excluded	Excluded	new_screen			2						
200	Behave	The implementation of ATDD and BDD from Testing Perspectives	Software testing is one of the stages in software development that aims to ensure that the software is built to meet the specifications. Selection of selective test cases has a great chance of finding failure. Black box testing approach is done based on the requirement specification where this approach does not pay attention to the program code but the specification of a software. This approach can be used for testing a software using ATDD (Acceptance Test Driven Development) and BDD (Behavior Driven Development) methods. ATDD is a method of building a software created based on agile principle, acceptance test created by customer, developer and tester. BDD is a growing agile development approach in recent years. Behavior Driven Development (BDD) is built on Test-Driven Development (TDD). This Final Project focuses on the application of ATDD and BDD methods to testing the final three projects of IT Del students tested using the Roboy Framework and Cucumber Framework to find out whether these two methods are effective and be able to improve the software development process. The results obtained are that the application of ATDD and BDD methods are effective and helping to remove the error as soon as possible. © Published under licence by IOP Publishing Ltd.		Christy Barus A.	Journal of Physics: Conference Series					Included	Included	new_screen			2						
201	Behave	Impacts of behavioral driven development in the improvement of quality software deliverables	Sometimes, the software deliverables do not exactly match with the requirements. This mismatch requirement can be captured during the testing. Even then if it is missing it is because of non-coverage of the testing and test cases. This could be resolved by creating the unit test cases / Integration test cases from the requirements. This paper focuses on BDD requirements which generates the test cases as well as report executed. With aid of automation testing, the test cases of BDD can be explained. This paper deals with such test cases, the next version binaries to get the proper deliverables.	BDD - Behavior Driven Development;TDD – Test Driven Development;QA – Quality Assurance;BD – Behavior Driven	A. Sheshasaayee; P. Banumathi	2018 3rd International Conference on Inventive Computation Technologies (ICICT)					Excluded	Excluded	new_screen			2						
202	Behave	A Natural Language Driven Approach for Automated Web API Development: Gherkin2OAS	"Speeding up the development process of Web Services, while adhering to high quality software standards is a typical requirement in the software industry. This is why industry specialists usually suggest ""driven by"" development approaches to tackle this problem. In this paper, we propose such a methodology that employs Specification Driven Development and Behavior Driven Development in order to facilitate the phases of Web Service requirements elicitation and specification. Furthermore, we introduce gherkin2OAS, a software tool that aspires to bridge the aforementioned development approaches. Through the suggested methodology and tool, one may design and build RESTful services fast, while ensuring proper functionality."	behavior driven development; gherkin; open API specification; restful API	Dimanidis, Anastasios; Chatzidimitriou, Kyriakos C.; Symeonidis, Andreas L.	Companion Proceedings of the The Web Conference 2018					Included	Included	new_screen			2						
203	Behave	Sismic—A Python library for statechart execution and testing	Statecharts are a well-known visual modelling language for representing the executable behaviour of complex reactive event-based systems. The essential complexity of statechart models solicits the need for advanced model testing and validation techniques, such as test-driven development, behaviour-driven development, design by contract, and property statecharts for monitoring of violations of behavioural properties during statechart execution. Sismic is an open-source Python library providing a tool suite to define, simulate, execute and test statecharts with all of the aforementioned techniques.	Statechart, Executable modelling, Behaviour-driven development, Design by contract, Runtime verification	Decan, Alexandre; Mens, Tom	SoftwareX					Excluded	Excluded	new_screen			2						
204	Behave	A Method for Testing and Validating Executable Statechart Models	Statecharts constitute an executable language for modelling event-based reactive systems. The essential complexity of statechart models solicits the need for advanced model testing and validation techniques. In this article, we propose a method aimed at enhancing statechart design with a range of techniques that have proven their usefulness to increase the quality and reliability of source code. The method is accompanied by a process that flexibly accommodates testing and validation techniques such as test-driven development, behaviour-driven development, design by contract, and property statecharts that check for violations of behavioural properties during statechart execution. The method is supported by the Sismic tool, an open-source statechart interpreter library in Python, which supports all the aforementioned techniques. Based on this tooling, we carry out a controlled user study to evaluate the feasibility, usefulness and adequacy of the proposed techniques for statechart testing and validation.	Behaviour-driven development; Design by contract; Runtime verification; Statechart; Executable modeling	Mens, Tom; Decan, Alexandre; Spanoudakis, Nikolaos I.	Softw. Syst. Model.					Excluded	Excluded	new_screen			2						
205	Behave	A method for testing and validating executable statechart models	Statecharts constitute an executable language for modelling event-based reactive systems. The essential complexity of statechart models solicits the need for advanced model testing and validation techniques. In this article, we propose a method aimed at enhancing statechart design with a range of techniques that have proven their usefulness to increase the quality and reliability of source code. The method is accompanied by a process that flexibly accommodates testing and validation techniques such as test-driven development, behaviour-driven development, design by contract, and property statecharts that check for violations of behavioural properties during statechart execution. The method is supported by the Sismic tool, an open-source statechart interpreter library in Python, which supports all the aforementioned techniques. Based on this tooling, we carry out a controlled user study to evaluate the feasibility, usefulness and adequacy of the proposed techniques for statechart testing and validation. © 2018, Springer-Verlag GmbH Germany, part of Springer Nature.		Mens T., Decan A., Spanoudakis N.I.	Software and Systems Modeling					Included	Included	new_screen			2						
206	Behave	Rails 3 in Action	Summary Rails 3 in Action is a collaboration between Rails community leaders, Ryan Bigg and Yehuda Katz, that covers Rails 3.1 making it the most up-to-date resource available. But it's much more than just a Rails 3 reference book. You'll learn to do Rails the right way, so you can build stable, scalable, and maintainable apps that will satisfy even the most demanding clients. About the BookRails 3 is a full stack, open source web framework powered by Ruby and this book is an introduction to it. Whether you're just starting or you have a few cycles under your belt, you'll appreciate the book's guru's-eye-view of idiomatic Rails programming.You'll master Rails 3.1 by developing a ticket tracking application that includes RESTful routing, authentication and authorization, state maintenance, file uploads, email, and more. You'll also explore powerful features like designing your own APIs and building a Rails engine. You will see Test Driven Development and Behavior Driven Development in action throughout the book, just like you would in a top Rails shop.It is helpful for readers to have a background in Ruby, but no prior Rails experience is needed. What's InsideCovers Rails 3.1 from the ground up Testing and BDD using RSpec and Cucumber Working with Rack=============================================== Table of ContentsRuby on Rails, the framework Testing saves your bacon Developing a real Rails application Oh CRUD! Nested resources Authentication and basic authorization Basic access control More authorization File uploading Tracking state Tagging Sending email Designing an API Deployment Alternative authentication Basic performance enhancements Engines Rack-based applications		Bigg, Ryan; Katz, Yehuda						Excluded	Excluded	new_screen			2						
207	Behave	BeSoS: A Tool for Behavior-driven and Scenario-based Requirements Modeling for Systems of Systems	Systems of Systems (SoS), like connected vehicle systems, provide their functionality by the interaction of several constituent systems (CSs). [Problem] Due to the managerial, operational and evolutionary independence of the CSs in an SoS, requirements constantly change over time and linear, top-down requirements engineering methods cannot be applied without significant adaptations. New tools are needed that support the continuous and iterative specification and alignment of requirements across different levels of abstraction. [Principal Ideas] We propose to integrate the behavior-driven development (BDD) approach with an intuitive and executable scenario-based modeling of functional requirements. In this way, stakeholder expectations can be structured via features and documented in natural language as usage scenarios. Based on usage scenarios, the modeling of functional requirements can be driven by tests, allowing for the automated testing and analysis of requirements. This in turn supports the iterative specification of requirements and the alignment of stakeholder needs. [Contribution] In this paper we showcase the tool BeSoS that supports the iterative and behavior-driven specification of requirements in an SoS context. We propose a method and describe its tool components using an example. The tool is available here: https://vimeo.com/512739942. © 2021 CEUR-WS. All rights reserved.		Wiecher C., Greenyer J.	CEUR Workshop Proceedings					Included	Included	new_screen			2						
208	Behave	Behavior-Driven Development: An Expert Panel to Evaluate Benefits and Challenges	"Teaching modern software techniques is a challenging task as these practices tend to be collaborative and require a lot of preparation and environment setup. Among these techniques is Behavior-Driven Development (BDD), a development method which proposes software to be develop focusing primarily on its expected behavior. In this context, this paper investigates the perception of active-learning experts regarding the potential benefits and challenges of teaching BDD in active learning environments to software engineering students. To achieve this goal, we have conducted an expert panel with 28 active-learning experts from four countries. Our preliminary results indicate that experts perceive both benefits, like improvement in specification, and challenges to embrace the BDD ""culture"" when teaching BDD to software engineering students. Based in these findings, we found indicatives that BDD should benefit software engineering students in active learning environments, however it may require more setup, teacher preparation and engagement during the learning process."	Behavior-Driven Development; Agile Development; Challenge Based Learning; Software Engineering	Nascimento, Nicolas; Santos, Alan R.; Sales, Afonso; Chanin, Rafael	Proceedings of the 34th Brazilian Symposium on Software Engineering					Included	Included	new_screen			2						
209	Behave	Testing Meets Static and Runtime Verification	Test driven development (TDD) is a technique where test cases are used to guide the development of a system. This technique introduces several advantages at the time of developing a system, e.g. writing clean code, good coverage for the features of the system, and evolutionary development. In this paper we show how the capabilities of a testing focused development methodology based on TDD and model-based testing, can be enhanced by integrating static and runtime verification into its workflow. Considering that the desired system properties capture data- as well as control-oriented aspects, we integrate TDD with (static) deductive verification as an aid in the development of the data-oriented aspects, and we integrate model-based testing with runtime verification as an aid in the development of the control-oriented aspects. As a result of this integration, the proposed development methodology features the benefits of TDD and model-based testing, enhanced with, for instance, early detection of bugs which may be missed by TDD, regarding data aspects, and the validation of the overall system with respect to the model, regarding the control aspects.	runtime verification; Java; static verification; test driven development	Chimento, Jesús Mauricio; Ahrendt, Wolfgang; Schneider, Gerardo	Proceedings of the 6th Conference on Formal Methods in Software Engineering					Excluded	Excluded	new_screen			2						
210	Behave	Jasmine JavaScript Testing Update	Test your JavaScript applications efficiently using Jasmine and React.js About This BookLeverage the power of unit testing React.js to develop full-fledged JavaScript applicationsLearn the best practices of modularization and code organization while scaling your applicationEnhance your practical skills required to develop applications using the Jasmine framework in a step-by-step mannerWho This Book Is ForThis book is for web developers and designers who work with React.js and JavaScript and who are new to unit testing and automation. It's assumed that you have a basic knowledge of JavaScript and HTML. In Detail Take your testing of JavaScript applications to a new level of efficiency and reliability with the help of this book. Starting with the fundamentals of Jasmine and behavior-driven development (BDD), you will learn about tooling and automation. You will learn how to create a sustainable code base with the help of Jasmine. You will also take a look at integrated testing with React.js and Karma, and how you can speed this process up by faking AJAX requests. As you progress through the book, you will learn about the challenges of testing an application built on top of a framework and how you can prevent your application from suffering from dependency management. You will understand the concept of client-side and server-side rendering and test applications using React.js. You will also learn to automate using webpack and work with JavaScript module systems using ECMA Script 6 (ES6) modules.By the end of this book, you will be a competent web developer with good knowledge and a strong understanding of how to efficiently use the Jasmine framework for testing purposes.		Ragonha, Paulo						Excluded	Excluded	new_screen			2						
211	Behave	TestBox: Behavior Driven Development	TestBox is a testing framework for ColdFusion (CFML) that is based on BDD (Behavior Driven Development) for providing a clean obvious syntax for writing tests. It also includes MockBox for mocking and stubbing.		Majano, Luis Fernando; Reyes, Jorge Emilio						Excluded	Excluded	new_screen			2						
212	Behave	Assessing Agile Testing Practices for Enterprise Systems: A Survey Approach	"Testing enterprise systems is a challenging task. In this context, besides considering user requirements and business rules, there are several concerns that must also be considered when designing a test suite, including user interaction, integration with legacy systems, and access to relational or non-relational databases. In addition, test engineers often have to decide whether to test in the different levels (e.g., unit, integration, and system testing) or not, whether to use mock objects or not, and so on. Sadly, these decisions often conflict to each other. In this paper, we report an 18-month experience on using different approaches and tools to test two enterprise systems (SISBOL and SISDOT) from the Brazilian Army. SISBOL is an enterprise system based on the REST architectural style, using JEE (Java Enterprise Edition) in the business and integration tiers and AngularJS in the presentation tier. On the other hand, SISDOT is a ""pure"" Java enterprise system, using Java Server Faces on the presentation tier. We found that using executable specifications (as recommended in approaches based on Behavior Driven Development) is not only valid in test first scenarios as well as giving confidence on the system requirements validation, but they also help to identify new execution paths when the source code had been already implemented—suggesting that it is also promising to introduce a BDD approach in later stages of the development than testing pure JEE systems at the integration level."	Software Testing; Test Driven Development; Behavior Driven Development; Specification by Example	Fazzolino, Rafael; de Faria, Henrique Medrado; Amaral, Luis Henrique Vieira; Canedo, Edna Dias; Rodrigues, Genaína Nunes; Bonifácio, Rodrigo	Proceedings of the III Brazilian Symposium on Systematic and Automated Software Testing					Included	Included	new_screen			2						
213	Behave	Distributed agile: Component-based user acceptance testing	Testing is conducted at multiple levels during the development of software. User Acceptance Testing conforms that the software meets user's criteria. In this paper, User Acceptance Testing is automatically conducted based on acceptance criteria. The acceptance criteria are written in the form of Given-When-Then Template. These acceptance criteria are broken down into steps and numbered. The dependencies among the steps are determined as Given->When->Then. Henceforth, the steps are arranged in a dependency graph. This graph further leads to the creation of a decision table in which the outcome of one step leads to the outcomes of its dependent steps. The decision table forms the basis of generation of a binary weighted dependency tree. This tree becomes the means to form test coverage (number of combinations to test) which forms the basis of generation of acceptance test cases.		P. Pandit; S. Tahiliani; M. Sharma	2016 Symposium on Colossal Data Analysis and Networking (CDAN)					Included	Included	new_screen			2						
214	Behave	Modeling Test Cases in BPMN for Behavior-Driven Development	Testing large-scale process integration solutions is complex and cumbersome. To tackle this problem, researchers employed behavior-driven development. They used the Business Process Model and Notation language to model domain-specific test cases. These test cases can be understood by both developers and business stakeholders and can be executed automatically.		Lübke, Daniel; van Lessen, Tammo	IEEE Softw.					Included	Included	new_screen			2						
215	Behave	A study of value in agile software development organizations	The Agile manifesto focuses on the delivery of valuable software. In Lean, the principles emphasise value, where every activity that does not add value is seen as waste. Despite the strong focus on value, and that the primary critical success factor for software intensive product development lies in the value domain, no empirical study has investigated specifically what value is. This paper presents an empirical study that investigates how value is interpreted and prioritised, and how value is assured and measured. Data was collected through semi-structured interviews with 23 participants from 14 agile software development organisations. The contribution of this study is fourfold. First, it examines how value is perceived amongst agile software development organisations. Second, it compares the perceptions and priorities of the perceived values by domains and roles. Third, it includes an examination of what practices are used to achieve value in industry, and what hinders the achievement of value. Fourth, it characterises what measurements are used to assure, and evaluate value-creation activities.	Value, Agile software development, Empirical	Alahyari, Hiva; Berntsson Svensson, Richard; Gorschek, Tony	Journal of Systems and Software					Excluded	Excluded	new_screen			2						
216	Behave	User and System Stories: An Agile Approach for Managing Requirements in AOSE	The agile software development life cycle is widely used in industry today due to its highly flexible and iterative processes that facilitate rapid prototyping. There has been recent work in bringing concepts and processes from agile methodologies to agent-oriented software engineering (AOSE). We contribute to this effort by presenting in this paper a novel approach to capturing requirements of agent systems in AOSE using and extending agile concepts. In this paper, we propose to adopt and extend the well-known concept of User Stories to facilitate the development of agent systems. We introduce a novel concept, System Story, that defines requirements from the perspective of the system. These System Stories are refinements of User Stories and provide more intuitive mappings to agent concepts in the design and implementation. We show how our approach allows better traceability of requirements between stories and the different software development artifacts. We validate our proposal with a feature-based comparison to recent related work, and a preliminary user evaluation based on a drone simulation of a simple search and rescue case study.		Rodriguez, Sebastian; Thangarajah, John; Winikoff, Michael	Proceedings of the 20th International Conference on Autonomous Agents and MultiAgent Systems					Excluded	Excluded	new_screen			2						
217	Behave	The Art of Rails (Programmer to Programmer)	The Art of Rails(r) Any programmer knows that an API is only half the story, and with Ruby on Rails(r) this is especially true. Good Rails development, like good web development, is much more about the design choices you make than the framework you have at your disposal. Written by an experienced web application developer, this book picks up where the API leaves off and explains how to take good Rails code and turn it into beautiful Rails code: simple, effective, reusable, evolvable code. In a blend of design and programming, this book identifies and describes the very latest in design patterns, programming abstractions, and development methodologies that have emerged for the modern web. Ruby on Rails offers a completely new way of thinking about and using these emerging techniques, and learning to think like a Rails developer will enable you to rapidly design and write high-quality code with elegance and maintainability. With each design technique, you will discover how Rails incorporates it into its domain-specific language, and you will learn how to weave it seamlessly into your own Rails applications. Then you will learn how to take the next step and transform yourself from user into creator, making your own additions to Rails and crafting a development environment tailored to your specific needs. What you will learn from this book * Techniques for organizing your code between and within Model, View, and Controller to eliminate code repetition and maximize your effectiveness * How to think like a REST-based developer and use Rails 2.0 to translate these thoughts into your code * Advanced Ruby and meta-programming: how to use features such as block-based development, monkey patching, and dynamic APIs to build your own additions to the Rails framework * Design patterns for AJAX, web APIs, HTML decomposition, schema development, meta-programming, and more * Behavior-driven development: A new style of testing and development centered arou nd stories and behaviors instead of method calls and assertions * Ways to make your development both productive and fun in the software you write Who this book is for This book is for developers familiar with Ruby on Rails who are looking to advance their skills by learning the design and coding techniques that enable a mastery of web application development with Rails. Wrox guides are crafted to make learning programming languages and technologies easier than you think. Written by programmers for programmers, they provide a structured, tutorial format that will guide you through all the techniques involved.		Benson, Edward						Excluded	Excluded	new_screen			2						
218	Behave	The blockchain: State-of-the-art and research challenges	The blockchain revolutionizes the creation of both scalable information technology systems and diversified applications by integrating the increasingly popular artificial intelligence, cloud computing, and big data. Various industries have recently begun to implement the exploration of blockchain. It will not take long for the blockchain to spread all over the world. In order to identify and further the development of the blockchain technology, this paper reviews the extant studies on the blockchain and its key components, blockchain-based IoT, blockchain-based security, blockchain-based data management, and the main applications based on the blockchain, and it delineates potential trends and challenges. This study provides a comprehensive overview of state-of-the-art blockchain and describes a forward-looking direction.	Blockchain, Decentralization, Smart contract, Security, Privacy	Lu, Yang	Journal of Industrial Information Integration					Excluded	Excluded	new_screen			2						
219	Behave	A User‐Centered Behavioral Software Development Model	The concept of usability, which affects the quality and cost of the software projects, has become essential in recent years. There is a need to integrate usability testing activities and techniques into the development processes; however, integration is difficult. Therefore, this study proposes user‐centered behavioral (UCB) software development model, which aims to bridge the gap between human–computer interaction (HCI) and software engineering (SE) disciplines. A triangulation methodology of mixed methods is used to understand the current situation in software development companies in terms of usability and user‐centered software development by survey and interviews. Their results are then used to inform the development of the proposed model. The UCB software development model proposes a process in which several tools and techniques from SE and HCI are integrated to facilitate the production of highly usable software. In essence, the model proposes an iterative process that combines behavior‐driven development (BDD)—an agile approach that enables a better understanding and analysis of the requirements—with the style guides, usability tests, heuristic evaluation, and Wizard of Oz techniques of HCI. The model was evaluated in a pilot project and then is improved based on feedback gathered. Participants' feedback supported the effectiveness of the proposed model.The UCB software development model proposes a process in which several tools and techniques from SE and HCI are integrated to create a model that will facilitate the production of highly usable software. In essence, the model proposes an iterative process that combines behavior‐driven development (BDD)—an agile approach that enables a better understanding and analysis of the requirements—with the style guides, usability tests, heuristic evaluation, and Wizard of Oz techniques of HCI. image	software engineering; agile methodology; behavior‐driven development (BDD); human–computer interaction (HCI); user‐centered design; user‐centered software development model	Güncan, Damla; Onay Durdu, Pınar	J. Softw. Evol. Process					Excluded	Excluded	new_screen			2						
220	Behave	Behavior Driven Development for circuit design and verification	The design of hardware systems is a challenging and erroneous task where about 70% of the effort in designing these systems is spent on verification. In general, testing and verification are usually tasks that are being applied as a post-process to the implementation. In this paper, we propose a new design flow based on Behavior Driven Development (BDD), an agile technique for the development of software in which acceptance tests written in natural language play a central role and are the starting point in the design flow. We advance the flow such that the specifics that arise when modeling hardware are taken into account. Furthermore, we present a technique that allows for the automatic generalization of test cases to properties that are suitable for formal verification. This allows the designer to apply formal verification techniques based on test cases without specifying properties. We implemented our approach and evaluated the flow for an illustrative example that successfully demonstrates the advantages of the proposed flow.		M. Diepenbeck; M. Soeken; D. Große; R. Drechsler	2012 IEEE International High Level Design Validation and Test Workshop (HLDVT)					Included	Included	new_screen			2						
221	Behave	Behavior driven development for circuit design and verification	The design of hardware systems is a challenging and erroneous task where about 70% of the effort in designing these systems is spent on verification. In general, testing and verification are usually tasks that are being applied as a post-process to the implementation. In this paper, we propose a new design flow based on Behavior Driven Development (BDD), an agile technique for the development of software in which acceptance tests written in natural language play a central role and are the starting point in the design flow. We advance the flow such that the specifics that arise when modeling hardware are taken into account. Furthermore, we present a technique that allows for the automatic generalization of test cases to properties that are suitable for formal verification. This allows the designer to apply formal verification techniques based on test cases without specifying properties. We implemented our approach and evaluated the flow for an illustrative example that successfully demonstrates the advantages of the proposed flow. © 2012 IEEE.		Diepenbeck M., Soeken M., Große D., Drechsler R.	Proceedings - IEEE International High-Level Design Validation and Test Workshop, HLDVT					Excluded	Excluded	new_screen			2						
222	Behave	Behaviour driven development for tests and verification	The design of hardware systems is a challenging and error-prone task, where a signifcant portion of the effort is spent for testing and verification. Usually testing and verification are applied as a post-process to the implementation. Meanwhile, for the development of software, test-first approaches such as test driven development (TDD) have become increasingly important. In this paper, we propose a new design flow based on behaviour driven development (BDD), an extension of TDD, where acceptance tests written in natural language drive the implementation. We extend this idea by allowing the specification of properties in natural language and use them as a starting point in the design flow. The flow also includes an automatic generalisation of test cases to properties that are used for formal verification. In this way, testing and formal verification are combined in a seamless manner, while keeping the requirements - from which both tests and formal properties are derived - in a single consistent document. The approach has been implemented and evaluated on several examples to demonstrate the advantages of the proposed flow. © 2014 Springer International Publishing Switzerland.		Diepenbeck M., Kühne U., Soeken M., Drechsler R.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)					Included	Included	new_screen			2						
223	Behave	The ASSERT Virtual Machine: A Predictable Platform for Real-Time Systems	The development of real-time control systems is a complex process which has to face often conflicting requirements, especially those related to the performance of the control methods and the real-time behaviour of the system. The ASSERT Virtual Machine provides a reliable execution platform for such systems, which allows developers to cope with functional and real-time aspects separately. In order to guarantee the required real-time properties, the virtual machine only accepts software components which have a predictable temporal behaviour which can be analysed at system design time. Such components can be automatically generated from a high-level description of a system which embodies the functional components (e.g. control algorithms) into a set of containers providing the appropriate concurrent and realtime behaviour. The ASSERT Virtual Machine has been implemented in Ada 2005, using a predictable tasking subset of the language known as the Ravenscar profile. A prototype has been validated on several pilot-scale spacecraft control systems, with good results.	Computers for control, real-time systems, programming environments, software engineering, model-driven development	de la Puente, Juan A.; Zamorano, Juan; Pulido, José A.; Urueña, Santiago	IFAC Proceedings Volumes					Excluded	Excluded	new_screen			2						
224	Behave	Scenarios in the Loop: Integrated Requirements Analysis and Automotive System Validation	The development of safety-relevant systems in the automotive industry requires the definition of high-quality requirements and tests for the coordination and monitoring of development activities in an agile development environment. In this paper we describe a Scenarios in the Loop (SCIL) approach. SCIL combines (1) natural language requirements specification based on Behavior-Driven Development (BDD) with (2) formal and test-driven requirements modeling and analysis, and (3) integrates discipline-specific tools for software and system validation during development. A central element of SCIL is a flexible and executable scenario-based modeling language, the Scenario Modeling Language for Kotlin (SMLK). SMLK allows for an intuitive requirements formalization, and supports engineers to move iteratively, and continuously aided by automated checks, from stakeholder requirements to the validation of the implemented system. We evaluated the approach using a real example from the field of e-mobility.	automotive systems engineering; BizDevOps; requirements analysis; system validation	Wiecher, Carsten; Japs, Sergej; Kaiser, Lydia; Greenyer, Joel; Dumitrescu, Roman; Wolff, Carsten	Proceedings of the 23rd ACM/IEEE International Conference on Model Driven Engineering Languages and Systems: Companion Proceedings					Included	Included	new_screen			2						
225	Behave	Continuous Security through Integration Testing in an Electronic Health Records System	The estimated average cost of a healthcare data breach in 2019 was $6.45 million, which is the highest among all industries. Yet, security remains an afterthought in many digital health applications. Formal methods for testing for bugs are commonplace in software development through the use of unit testing, integration testing, system testing, and acceptance testing. More so, in modern software engineering, continuous integration is a well-known concept to run automated tests soon after any code change, when the system builds and notifies the development team of the test results. In this paper, we describe the use of a popular Python unit testing framework to implement a formal method of security testing. Common Vulnerability Scoring System (CVSS) is used to calculate metrics that represent the state of security of a deployed system. We developed a series of Pytest Behavioral Driven Development (BDD) scripts to test the Authentication and Availability of a widely used Electronic Health Records System called OpenMRS. The advantage of using the BDD approach is that testing scripts, called Gherkin files, can be read, and understood by the developers as well as the non-developer stakeholders. The use of Gherkin serves two purposes: firstly, it serves as the project’s documentation, and secondly, it automates the tests. The use of the CVSS score between 0 to 10 becomes an objective metric to compare every code change, thus achieving continuous security. We plan to expand BDD scripts to attacks like Denial of Service, Session Hijacking, SQL Injection, and other privilege escalation attacks.	Behavior Driven Development;Common Vulnerability Scoring System;Continuous Security;Electronic Health Records;Integration testing;OpenMRS	S. Purkayastha; S. Goyal; T. Phillips; H. Wu; B. Haakenson; X. Zou	2020 International Conference on Software Security and Assurance (ICSSA)					Included	Included	new_screen			2						
226	Behave	Design Driven Testing: Test Smarter, Not Harder	The groundbreaking book Design Driven Testing brings sanity back to the software development process by flipping around the concept of Test Driven Development (TDD)restoring the concept of using testing to verify a design instead of pretending that unit tests are a replacement for design. Anyone who feels that TDD is Too Damn Difficult will appreciate this book. Design Driven Testing shows that, by combining a forward-thinking development process with cutting-edge automation, testing can be a finely targeted, business-driven, rewarding effort. In other words, youll learn how to test smarter, not harder. Applies a feedback-driven approach to each stage of the project lifecycle. Illustrates a lightweight and effective approach using a core subset of UML. Follows a real-life example project using Java and Flex/ActionScript. Presents bonus chapters for advanced DDTers covering unit-test antipatterns (and their opposite, test-conscious design patterns), and showing how to create your own test transformation templates in Enterprise Architect. What youll learn Create unit and behavioral tests using JUnit, NUnit, FlexUnit. Generate acceptance tests for all usage paths through use case thread expansion. Generate requirement tests for functional requirements. Run complex acceptance tests across the enterprise. Isolate individual control points for self-contained unit/behavioral tests. Apply Behavior Driven Development frameworks like JBehave and NBehave Design Driven Testing should appeal to developers, project managers, testers, business analysts, architectsin fact anyone who builds software that needs to be tested. While equally applicable on both large and small projects, Design Driven Testing is especially helpful to those developers who need to verify their software against formal requirements. Such developers will benefit greatly from the rational and disciplined approach espoused by the authors.		Stephens, Matt; Rosenberg, Doug						Excluded	Excluded	new_screen			2						
227	Behave	Development of health software using behaviour driven development - BDD	The health software industry is facing an immense challenge of managing quality and preventing software failures. Poorly defined requirements are one of the significant cause of health software failures. Agile practices are being increasingly used by the software industry to develop systems on time and within budget with improved software quality and user acceptance. Behaviour-driven development (BDD) is an agile software engineering practice that can help to improve health software quality vastly. BDD achieves this by prioritising the illustration of software's behaviour using ubiquitous language, followed by automated acceptance testing to assess if the illustrated behaviour was achieved. This paper presents a review of BDD literature, including the characteristics of BDD and examines how BDD can benefit health software quality. The paper reviews health software standards and guidelines, to examine their compatibility with a BDD approach. Finally, the paper details future plans for the development of a framework that provides health software companies with a detailed step by step guideline on how to use BDD to develop safer health software. Copyright © 2020 by SCITEPRESS - Science and Technology Publications, Lda. All rights reserved.		Anjum M.Z., Mahon S.T.M., MahonMcCaffery F.	MODELSWARD 2020 - Proceedings of the 8th International Conference on Model-Driven Engineering and Software Development					Excluded	Excluded	new_screen			2						
228	Behave	Behaviour-driven development applied to the conformance testing of INSPIRE web services	The implementation of the INSPIRE directive requires to check the conformity of a large number of network services with the implementing rules of INSPIRE. The evaluation whether a service is fully conformant with INSPIRE is complex and requires the use of specialized testing tools that should report how verification has been made and should identify non-conformances. The use of these tools requires a high degree of technical knowledge. This fact makes very difficult for non-technical stakeholders (end users, managers, domain experts, etc.) to participate effectively in conformance testing, hinders stakeholders understanding of the causes and consequences of non-conformant results and may cause in some stakeholders disinterest in conformance testing. This work explores the suitability of a behaviour-driven development (BDD) approach to the conformance testing of OGC Web services in the context of the INSPIRE directive. BDD emphasizes the participation of non-technical parties in the design of acceptance tests by means of automatable abstract tests expressed in a human readable format. Using this idea as base, this work describes a BDD based workflow to derive abstract test suites and executable test suites from INSPIRE implementation requirements that can be written in the language used by non-technical stakeholders. This work also analyses if BDD and popular BDD tools, such as Gherkin and Cucumber, are compatible with ISO 19105:2000 testing methodology. As demonstration, we present an online conformance tool for INSPIRE View and Discovery services that executes BDD test suites. © Springer International Publishing Switzerland 2014.		Lopez-Pellicer F.J., Latre M.Á., Nogueras-Iso J., Javier Zarazaga-Soria F., Barrera J.	Lecture Notes in Geoinformation and Cartography					Included	Included	new_screen			2						
229	Behave	Towards a Thing-In-the-Loop Approach for the Verification and Validation of IoT Systems	The Internet of Things (IoT) is rapidly increasing its diffusion, posing great challenges to the research community. IoT systems are composed by smart objects (Things) that are interconnected in order to provide new products and services. The interaction of heterogeneous and distributed smart things guided by software with the physical world brings new sources of safety issues. To this reason, providing valuable and effective solutions to support the verification and validation of such systems is needed. In this paper we introduce a model-driven Thing-In-the-Loop verification and validation approach that transfers the best practices adopted in different embedded system domains towards the IoT world. Starting from models and scenarios representing the structure and behaviors of the IoT system as well as models of its context our approach generates appropriate test cases that are executed in accordance with Model-in-the-Loop, Software-in-the-Loop and Hardware-in-the-Loop techniques. We preliminarily evaluated the feasibility of our approach by applying it in the context of a Smart Mobility case study.	Internet of Things; Model-driven engineering; Thing-In-the-loop; verification and validation	Amalfitano, Domenico; Amatucci, Nicola; De Simone, Vincenzo; Riccio, Vincenzo; Rita, Fasolino Anna	Proceedings of the 1st ACM Workshop on the Internet of Safe Things					Excluded	Excluded	new_screen			2						
230	Behave	Supporting smart construction with dependable edge computing infrastructures and applications	The Internet of Things (IoT) such as the use of robots, sensors, actuators, electronic signalization and a variety of other Internet enabled physical devices may provide for new advanced smart applications to be used in construction in the very near future. Such applications require real-time responses and are therefore time-critical. Therefore, in order to support collaboration, control, monitoring, supply management, safety and other construction processes, they have to meet dependability requirements, including requirements for high Quality of Service (QoS). Dependability and high QoS can be achieved by using adequate number and quality of computing resources, such as processing, memory and networking elements, geographically close to the smart environments. The goal of this study is to develop a practical edge computing architecture and design, which can be used to support smart construction environments with high QoS. This study gives particular attention to the solution design, which relies on latest cloud and software engineering approaches and technologies, and provides elasticity, interoperability and adaptation to companies' specific needs. Two edge computing applications supporting video communications and construction process documentation are developed and demonstrate a viable edge computing design for smart construction.	Smart construction, Dependability, Internet of Things, Container-based systems, Edge computing	Kochovski, Petar; Stankovski, Vlado	Automation in Construction					Excluded	Excluded	new_screen			2						
231	Behave	Towards Behavior-Driven Graphical User Interface Testing	The majority of users interacts with an application through its graphical user interface (GUI). To ensure high quality and expected behavior, those graphical user interfaces have to be tested thoroughly. Yet, creating graphical user interface test cases is considered expensive in comparison to unit or integration tests. In addition, test cases are perceived to be expensive to run and brittle, therefore causing a lot of false negative test results. Behavior-driven test case design addresses this challenges by bringing requirement specifications and test cases closer together. Although industry-proven tools map test specifications automatically, test methods making test scripts executable need to be implemented manually. The specification language Slang introduced by this paper generates automatically executable test cases from BDD-like feature descriptions that integrate low-fidelity prototypes in form of wireframesketcher models. To quantify the economic advantage of our approach an AB/BA crossover designed experiment was conducted. The experiment showed that creating automatically executable test cases utilizing Slang takes 63% less time compared to the industry-proven tool JBehave. In addition to presenting the experiment's results, the paper elaborates on first experience from applying the approach in a large Swiss bank. The findings of our experiments are supported by results from applying our approach in real-world scenarios. In addition, experiment as well as case study participants appreciated the sophisticated editor support of Slang.	behavior-driven development; domain-specific language; GUI test case generation; model-driven engineering; case study	Bünder, Hendrik; Kuchen, Herbert	SIGAPP Appl. Comput. Rev.					Included	Included	new_screen			2						
232	Behave	The behavior driven development applied to the software quality test: A case study applied to the promotion of sports financing in Brazil	The mechanisms of private investment in Brazilian sport are one of the main sources of resources that athletes hold to promote participation in high-performance competitions. In order to improve this flow, softwares are designed to shorten the path between donors and recipients. These tools, such as 'Meu Campeãu' used in this paper, require efficient analysis of the quality of the product offered. Concepts known as agile methodologies have brought a new style to the analysis of the software developed, and one of them has gained considerable prominence, known such as BDD (Behavior Driven Development), so this paper aims to analyze the implementation of Behavior Driven Development in the software quality verification process 'Meu Campeãu'. © 2019 AISTI.		Cavalcante M.G., Sales J.I.	Iberian Conference on Information Systems and Technologies, CISTI					Included	Included	new_screen			2						
233	Behave	Graph-based and scenario-driven microservice analysis, retrieval, and testing	The microservice architecture (MSA) differs fundamentally from the monolithic, layered architecture. The use of microservices provides a high degree of autonomy, composability, scalability, and fault-tolerance. MSA is regarded by many as a promising architecture for smart-city applications; however, a number of issues remain, including (1) the management of complex call relationships among microservices; (2) ensuring the quality of the overall software system even as new microservices are added and existing ones are modified, and (3) locating existing microservices that satisfy new requirements. In this paper, we propose a novel approach to the development of microservice-based systems, referred to as GSMART (Graph-based and Scenario-driven Microservice Analysis, Retrieval and Testing). GSMART enables the automatic generation of a “Service Dependency Graph (SDG)” by which to visualize and analyze dependency relationships between microservices as well as between services and scenarios. It also enables the automatic retrieval of test cases required for system changes to reduce the time and costs associated with regression testing. A microservice retrieval method using VSM and word2vec accelerates the development of new microservices tailored specifically to the needs of users based on user-provided scenarios. Experiment results demonstrate the feasibility, effectiveness, and efficiency of all of the main features of GSMART.	Microservice retrieval, Microservice testing, Microservice analysis, Service dependency graph, Behavior-driven development	Ma, Shang-Pin; Fan, Chen-Yuan; Chuang, Yen; Liu, I.-Hsiu; Lan, Ci-Wei	Future Generation Computer Systems					Included	Included	new_screen			2						
234	Behave	CEUR Workshop Proceedings	The proceedings contain 10 papers. The topics discussed include: pattern-driven knowledge systems engineering; an ontology debugger for the semantic Wiki KnowWE; behaviour-driven development for computer-interpretable clinical guidelines; ensuring the semantic correctness of workflow processes: an ontological approach; integration of activity modeller with Bayesian network based recommender for business processes; towards an ontological analysis of BPMN; CAPJA - a connector architecture for prolog and Java; migration of rule inference engine to mobile platform. challenges and case study; knowledge modeling with the open source tool myCBR; and SBVRwiki.		[No author name available]	CEUR Workshop Proceedings					Excluded	Excluded	new_screen			2						
235	Behave	Proceedings - 34th Brazilian Symposium on Software Engineering, SBES 2020	The proceedings contain 101 papers. The topics discussed include: on the influence of different perspectives on evaluating the quality of teamwork in the context of agile software development; challenges in agile transformation journey - a qualitative study; agile global software development: a systematic literature review; behavior-driven development: an expert panel to evaluate benefits and challenges [insightful ideas and emerging results; adaptations of scrum roles in software projects: survey and representation tentative with feature models; are code smell co-occurrences harmful to internal quality attributes? a mixed-method study; recommending composite refactorings for smell removal: heuristics and evaluation; a catalog of object-relational mapping code smells for java; and probabilistic model-based analysis to improve software energy efficiency.		[No author name available]	ACM International Conference Proceeding Series					Excluded	Excluded	new_screen			2						
236	Behave	Proceedings - 2021 IEEE/ACM 6th International Workshop on Metamorphic Testing, MET 2021	The proceedings contain 11 papers. The topics discussed include: robustness evaluation of stacked generative adversarial networks using metamorphic testing; metamorphic detection of repackaged malware; applying metamorphic testing to homomorphic cryptography; BMT: behavior driven development-based metamorphic testing for autonomous driving models; enhancing Euro NCAP standards with metamorphic testing for verification of advanced driver-assistance systems; towards automated metamorphic test identification for ocean system models; metamorphic testing on the continuum of verification and validation of simulation models; and metamorphic testing for image-based calcium imaging analysis pipelines.		[No author name available]	Proceedings - 2021 IEEE/ACM 6th International Workshop on Metamorphic Testing, MET 2021					Excluded	Excluded	new_screen			2						
237	Behave	21st International Conference on Agile Software Development, XP 2020	The proceedings contain 16 papers. The special focus in this conference is on Agile Software Development. The topics include: “When in Rome, Do as the Romans Do”: Cultural Barriers to Being Agile in Distributed Teams; a Quantitative Exploration of the 9-Factor Theory: Distribution of Leadership Roles Between Scrum Master and Agile Team; what an Agile Leader Does: The Group Dynamics Perspective; “This is Just a Prototype”: How Ethics Are Ignored in Software Startup-Like Environments; hypotheses Elicitation in Early-Stage Software Startups Based on Cognitive Mapping; results from a Replicated Experiment on the Affective Reactions of Novice Developers When Applying Test-Driven Development; examining the Current State of System Testing Methodologies in Quality Assurance; onboarding: How Newcomers Integrate into an Agile Project Team; combining User-Centered Design and Lean Startup with Agile Software Development: A Case Study of Two Agile Teams; agile Software Development Practices and Success in Outsourced Projects: The Moderating Role of Requirements Risk; on the Use of Design Thinking: A Survey of the Brazilian Agile Software Development Community; characterising the Quality of Behaviour Driven Development Specifications; “I Don’t Understand!”: Toward a Model to Evaluate the Role of User Story Quality; large-Scale Agile Transformation: A Case Study of Transforming Business, Development and Operations.		[No author name available]	Lecture Notes in Business Information Processing					Excluded	Excluded	new_screen			2						
238	Behave	2020 IEEE International Conference on Problems of Infocommunications Science and Technology, PIC S and T 2020 - Proceedings	The proceedings contain 171 papers. The topics discussed include: last mile technique for wireless delivery system using an accelerating lens; compact polarizers for satellite information systems; highly-distributed systems: what is inside?; behavior driven development approach in the modern quality control process; analysis of influence of UDP parameters on QoS in IP network; categorical analysis of logical networks in application to intelligent radar systems; models and information technology for reliable design of the functioning processes of flexible production systems as complex human-machine systems; advanced code-based electronic digital signature scheme; required safety component of automotive cyber-physical systems; and structure optimization of the multi-channel on-board radar with antenna aperture synthesis and algorithm for power line selection on the background of the earth surface.		[No author name available]	2020 IEEE International Conference on Problems of Infocommunications Science and Technology, PIC S and T 2020 - Proceedings					Excluded	Excluded	new_screen			2						
239	Behave	CEUR Workshop Proceedings	The proceedings contain 19 papers. The topics discussed include: product configuration in the wild: strategies for conflicting decisions in web configurators; configuring release plans; insights for configuration in natural language; group decision support for requirements management processes; Chatbot-based tourist recommendations using model-based reasoning; the effect of default options on consumer decisions in the product configuration process; cost benefit analysis in product configuration systems; do you read me? on the limits of manufacturing part numbers for communicating product variety; behavior-driven development in product configuration systems; integrating semantic web technologies and ASP for product configuration; measuring the complexity of product configuration systems; generating configuration models from requirements to assist in product management - dependency engine and its performance assessment; quasi-finite domains: dealing with the infinite in mass customization; software configuration diagnosis - a survey of existing methods and open challenges; knowledge retrieval for configuring risks when answering calls to tenders or direct customer demands; how to deal with engineering-to-order product/system configuration?; towards knowledge infrastructure for highly variant voltage transmission systems; and configuration lifecycle management - an assessment of the benefits based on maturity.		[No author name available]	CEUR Workshop Proceedings					Excluded	Excluded	new_screen			2						
240	Behave	8th International Conference on Model and Data Engineering, MEDI 2018, International Workshop on Modeling, Verification and Testing of Dependable Critical Systems, DETECT 2018, Model and Data Engineering for Social Good Workshop, MEDI4SG 2018, 2nd International Workshop on Cybersecurity and Functional Safety in Cyber-Physical Systems, IWCFS 2018, International Workshop on Formal Model for Mastering Multifaceted Systems, REMEDY 2018	The proceedings contain 21 papers. The special focus in this conference is on Model and Data Engineering. The topics include: Towards a requirements engineering approach for capturing uncertainty in cyber-physical systems environment; assessment of emerging standards for safety and security co-design on a railway case study; generation of behavior-driven development C++ tests from abstract state machine scenarios; hybrid systems and event-B: A formal approach to signalised left-turn assist; handling reparation in incremental construction of realizable conversation protocols; Analyzing a ROS based architecture for its cross reuse in ISO26262 settings; reliability in fully probabilistic event-B: How to bound the enabling of events; systematic construction of critical embedded systems using event-B; component design and adaptation based on behavioral contracts; An MDA approach for the specification of relay-based diagrams; Towards real-time semantics for a distributed event-based MOP language; Automatic planning: From event-B to PDDL; a problem-oriented approach to critical system design and diagnosis support; formal specification and verification of cloud resource allocation using timed petri-nets; Petri nets to event-B: Handling mathematical sequences through an ERTMS L3 Case; model-based verification and testing methodology for safety-critical airborne systems; gamification and serious games based learning for early childhood in rural areas; context-based sentiment analysis: A survey; a multi-agent system-based distributed intrusion detection system for a cloud computing.		[No author name available]	Communications in Computer and Information Science					Excluded	Excluded	new_screen			2						
241	Behave	17th AGILE Conference on Geographic Information Science, AGILE 2014	The proceedings contain 22 papers. The special focus in this conference is on Geographic Information Science. The topics include: Estimating completeness of vgi datasets by analyzing community activity over time periods; estimation of building types on openstreetmap based on urban morphology analysis; qualitative representations of extended spatial objects in sketch maps; exploring the geographical relations between social media and flood phenomena to improve situational awareness; event identification from georeferenced images; a recursive bayesian filter for anomalous behavior detection in trajectory data; using GPS logs to identify agronomical activities; assessing the influence of preprocessing methods on raw GPS-Data for automated change point detection; mining frequent spatio-temporal patterns in wind speed and direction; the text encoding algorithm for latitude/longitude/time; fast SNN-Based clustering approach for large geospatial data sets; RSS and sensor fusion algorithms for indoor location systems on Smartphones; an image segmentation process enhancement for land cover mapping from very high resolution remote sensing data application in a rural area; line matching for integration of photographic and geographic databases; encoding and querying historic map content; an area merge operation for smooth zooming; point labeling with sliding labels in interactive maps; comparing verbal instructions and sketch maps.; behaviour-driven development applied to the conformance testing of INSPIRE web services; making the web of data available via web feature services; a geospatial exploration of comparable cities and a gis-based process for calculating visibility impact from buildings during transmission line routing.		[No author name available]	Lecture Notes in Geoinformation and Cartography					Excluded	Excluded	new_screen			2						
242	Behave	CEUR Workshop Proceedings	The proceedings contain 24 papers. The topics discussed include: modeling test cases in BPMN for behavior-driven development; automating data exchange in process choreographies; gameful business process modeling; a game theoretic perspective on business processes; elastic process optimization and scheduling in the cloud; learning from quality issues of BPMN models from industry; the process of creating a domain specific modeling method; requirements catalog for business process modeling recommender systems; evaluating wiki collaborative features in ontology authoring; a visual language for modeling multiple perspectives of business process compliance rules; detecting flight trajectory anomalies and predicting diversions in freight transportation; and plausibility checking of formal business process specifications in linear temporal logic.		[No author name available]	CEUR Workshop Proceedings					Excluded	Excluded	new_screen			2						
243	Behave	2012 IEEE International High Level Design Validation and Test Workshop, HLDVT 2012	The proceedings contain 24 papers. The topics discussed include: sequential equivalence checking of hard instances with targeted inductive invariants and efficient filtering strategies; behavior driven development for circuit design and verification; using decision diagrams to compactly represent the state space for explicit model checking; automatic generation of deadlock detection algorithms for a family of micro-architecture description languages of communication fabrics; automatic generation of Verilog bus transactors from natural language protocol specifications; single-source hardware modeling of different abstraction levels with state charts; using haloes in mixed-signal assertion based verification; a formal method to improve SystemVerilog functional coverage; a functional test generation technique for RTL datapaths; constrained signal selection for post-silicon validation; and monitoring distributed reactive systems.		[No author name available]	Proceedings - IEEE International High-Level Design Validation and Test Workshop, HLDVT					Excluded	Excluded	new_screen			2						
244	Behave	Objects, Models, Components, Patterns - 50th International Conference, TOOLS 2012, Proceedings	The proceedings contain 24 papers. The topics discussed include: supporting compile-time debugging and precise error reporting in meta-programs; identifying a unifying mechanism for the implementation of concurrency abstractions on multi-language virtual machines; verification of snapshotable trees using access permissions and typestate; multiparty session C: safe parallel programming with message optimisation; non-interference on UMI state-charts; representing uniqueness constraints in object-relational mapping; detection of seed methods for quantification of feature confinement; assisted behavior driven development using natural language processing; learning to classify bug reports into components; incremental dynamic updates with first-class contexts; and elucidative development for model-based documentation.		[No author name available]	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)					Excluded	Excluded	new_screen			2						
245	Behave	IFIP WG 13.2/13.5 Joint 6th International Conference on Human-Centered Software Engineering, HCSE 2016 and 8th International Conference on Human Error, Safety, and System Development, HESSD 2016	The proceedings contain 25 papers. The special focus in this conference is on Agile, Human-Centered Software Engineering, Usability Evaluation, Testing, Socio-Technical, Ethical Considerations, Human Error, Safety-Critical Systems, User, Developer Experience, Models, Methods, Adopting Tools, Demos and Posters. The topics include: Supporting the HCI aspect of agile software development by tool support for UI-pattern transformations; usability problems experienced by different groups of skilled internet users; user-test results injection into task-based design process for the assessment and improvement of both usability and user experience; framework for relative web usability evaluation on usability features in MDD; testing prototypes and final user interfaces through an ontological perspective for behavior-driven development; complementary tools and techniques for supporting fitness-for-purpose of interactive critical systems; a conceptual ux-aware model of requirements; audio guidance for runner training; enterprise model-driven agile human-centered software engineering; collaborative task modelling on the web and declarative prototyping with data; a first prototype integrated in HAMSTERS.		[No author name available]	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)					Excluded	Excluded	new_screen			2						
246	Behave	Enterprise Information Systems of the Future - 6th IFIP WG 8.9 Working Conference, CONFENIS 2012, Revised Selected Papers	The proceedings contain 25 papers. The topics discussed include: process innovation: redesigning an enterprise backbone system; sub-process discovery: opportunities for process diagnostics; measuring the impact of suspension on the process enactment environment during process evolution; user perceptions, motivations and implications on ERP usage: an Indian higher education context; a decision support system based on RCM approach to define maintenance strategies; towards more flexible enterprise information systems; a proposal of a process model for requirements elicitation in information mining projects; a financial perspective on improving ICT service delivery: a case at the Belgian railways; looking for a fit for purpose: business process maturity models from a user's perspective; enterprise information systems security: a case study in the banking sector; and implementing behavior driven development in an open source ERP.		[No author name available]	Lecture Notes in Business Information Processing					Excluded	Excluded	new_screen			2						
247	Behave	2017 8th International Conference on Information and Communication Systems, ICICS 2017	The proceedings contain 65 papers. The topics discussed include: using behavior-driven development with hardware-software co-design for autonomous load management; dealing with decisional natural language why-question in business intelligence; sentence-aligned parallel corpus Amazigh-English; corpora for sentiment analysis of Arabic text in social media; ALIF editor for generating Arabic normalized lexicons; a brain friendly tool to facilitate research-teaching nexus: mind maps; adaptive e-learning web-based English tutor using data mining techniques and Jackson's learning styles; and towards a model-based approach for developing and QA of online business processes.		[No author name available]	2017 8th International Conference on Information and Communication Systems, ICICS 2017					Excluded	Excluded	new_screen			2						
248	Behave	4th International Conference on Computer Science and Computational Intelligence: Enabling Collaboration to Escalate Impact of Research Results for Society, ICCSCI 2019	The proceedings contain 87 papers. The topics discussed include: comparative performance of filtering methods for reducing noise in ischemic posterior Fossa CT images; gender demography classification on instagram based on user's comments section; automotive security with authorization and tracking via gps; combination of test-driven development and behavior-driven development for improving backend testing performance; modeling of the acute lymphoblastic leukemia detection based on the principal object characteristics of the color image; music recommender system based on genre using convolutional recurrent neural networks; MobileNet convolutional neural networks and support vector machines for palmprint recognition; MVC architecture: a comparative study between laravel framework and slim framework in freelancer project monitoring system web based; and recommendation of scheduling tourism routes using tabu search method (case study Bandung).		[No author name available]	Procedia Computer Science					Excluded	Excluded	new_screen			2						
249	Behave	CLOSER 2016 - Proceedings of the 6th International Conference on Cloud Computing and Services Science	The proceedings contain 88 papers. The topics discussed include: native cloud applications; SemNaaS: semantic web for network as a service; design time validation for the correct execution of BPMN collaborations; evidence collection in cloud provider chains; decision support system for adoption of cloud-based services; towards auditing of cloud provider chains using CloudTrust protocol; testing of web services using behavior-driven development; from architecture modeling to application provisioning for the cloud by combining UML and TOSCA; a scalable architecture for distributed OSGi in the cloud; LADY: dynamic resolution of assemblies for extensible and distributed .NET applications; and toward cloud-based classification and annotation support.		[No author name available]	CLOSER 2016 - Proceedings of the 6th International Conference on Cloud Computing and Services Science					Excluded	Excluded	new_screen			2						
250	Behave	A Service Framework for Parallel Test Execution on a Developer's Local Development Workstation	The proliferation of distributed microservices driven by service oriented architecture and the effectiveness of agile software development processes such as Test Driven Development (TDD), Behavior Driven Development (BDD), inspired by extreme programming (XP), have driven the challenging necessity to receive prompt test feedback during software development iteratively. Although few test frameworks can execute unit tests in memory in parallel, no existing test frameworks can reliably perform parallel execution for the tests that rely on file system access, database fixtures and network communication. Isolated test execution environment with dedicated resources is a prerequisite to address these challenges. No previous research addresses this need to run groups of tests in parallel on the same development host. In this paper, to cut down test execution time, we present a service framework for parallel tests execution in a developer's containerized sandbox using operating system level virtualization provided by Docker, the new hot driver for Platform as a Service (PaaS).	agile development; cloud testing; Docker; parallel testing; test execution environment	Rahman, Mazedur; Chen, Zehua; Gao, Jerry	Proceedings of the 2015 IEEE Symposium on Service-Oriented System Engineering					Excluded	Excluded	new_screen			2						
251	Behave	A Systematic Literature Review on Quality Criteria for Agile Requirements Specifications	The quality of requirements is typically considered as an important factor for the quality of the end product. For traditional up-front requirements specifications, a number of standards have been defined on what constitutes good quality : Requirements should be complete, unambiguous, specific, time-bounded, consistent, etc. For agile requirements specifications, no new standards have been defined yet, and it is not clear yet whether traditional quality criteria still apply. To investigate what quality criteria for assessing the correctness of written agile requirements exist, we have conducted a systematic literature review. The review resulted in a list of 16 selected papers on this topic. These selected papers describe 28 different quality criteria for agile requirements specifications. We categorize and analyze these criteria and compare them with those from traditional requirements engineering. We discuss findings from the 16 papers in the form of recommendations for practitioners on quality assessment of agile requirements. At the same time, we indicate the open points in the form of a research agenda for researchers working on this topic .	Systematic literature review; Agile requirement; Correctness; Just-in-time; Quality assessment; Quality criteria	Heck, Petra; Zaidman, Andy	Software Quality Journal					Excluded	Excluded	new_screen			2						
252	Behave	The Rails 3 Way	The Rails 3 Way is a comprehensive resource that digs into the new features in Rails 3 and perhaps more importantly, the rationale behind them.Yehuda Katz, Rails Core The Bible for Ruby on Rails Application Development Ruby on Rails strips complexity from the development process, enabling professional developers to focus on what matters most: delivering business value via clean and maintainable code. The Rails 3 Way is the only comprehensive, authoritative guide to delivering production-quality code with Rails 3. Pioneering Rails expert Obie Fernandez and a team of leading experts illuminate the entire Rails 3 API, along with the idioms, design approaches, and libraries that make developing applications with Rails so powerful. Drawing on their unsurpassed experience and track record, they address the real challenges development teams face, showing how to use Rails 3 to maximize your productivity. Using numerous detailed code examples, the author systematically covers Rails 3 key capabilities and subsystems, making this book a reference that you will turn to again and again. He presents advanced Rails programming techniques that have been proven effective in day-to-day usage on dozens of production Rails systems and offers important insights into behavior-driven development and production considerations such as scalability. Dive deep into the Rails 3 codebase and discover why Rails is designed the way it isand how to make it do what you want it to do. This book will help you Learn whats new in Rails 3 Increase your productivity as a web application developer Realize the overall joy in programming with Rails Leverage Rails powerful capabilities for building REST-compliant APIs Drive implementation and protect long-term maintainability using RSpec Design and manipulate your domain layer using Active Record Understand and program complex program flows using Action Controller Master sophisticated URL routing concepts Use Ajax techniques via Rails 3 support for unobtrusive JavaScript Learn to extend Rails with popular gems and plugins, and how to write your own Extend Rails with the best third-party plug-ins and write your own Integrate email services into your applications with Action Mailer Improve application responsiveness with background processing Create your own non-Active Record domain classes using Active Model Master Rails utility classes and extensions in Active Support		Fernandez, Obie						Excluded	Excluded	new_screen			2						
253	Behave	Using executable specification and regression testing for broadcast mechanism of visual programming language on smartphones	The rapid advancement of mobile computing technology and the rising usage of mobile apps made our daily life more productive. The mobile app should operate all the time bug-free in order to improve user satisfaction and offers great business value to the end user. At the same time, smartphones are full of special features that make testing of apps more challenging. Actually, the quality is a must for successful applications and it cannot be achieved without testing and verification. In this paper, we present the behavior driven development methodology and Cucumber framework to automate regression testing for Android apps. Particularly, the proposed methods use the visual programming language for smartphones (Catrobat) as a reference. The Catrobat program scripts communicate via a broadcast mechanism. The objective is to test the broadcast mechanism from different angles and track regression errors as well as specify and diagnose bugs with the help of executable specifications. The results show that the methods are able to effectively reveal deficiencies in the broadcast mechanism, and ensure that the app meets end users' expectations and needs. © 2018, International Association of Online Engineering.		Ali Z., Ayyal Awwad A.M., Slany W.	International Journal of Interactive Mobile Technologies					Included	Included	new_screen			2						
254	Behave	Reconciling requirements and continuous integration in an agile context	The RE'18 theme is: 'Crossing Boundaries and Increasing Impact'. In this context we propose a tutorial on Requirements in an Agile context that aims at exploring the boundaries between requirements, specifications, stories, scenarios and tests. It follows the recent work started in the RE community about agility, from a practical point of view. © 2018 IEEE.		Mosser S., Bruel J.-M.	Proceedings - 2018 IEEE 26th International Requirements Engineering Conference, RE 2018					Excluded	Excluded	new_screen			2						
255	Behave	The impact of tailoring criteria on agile practices adoption: A survey with novice agile practitioners in Brazil	The software development industry adopts agile methods in different ways by considering contextual requirements. To fulfill organizational needs, adoption strategies consider agile methods tailoring. However, tailoring according to the context of the organization remains a problem to be solved. Literature on criteria for adopting software development methods exists, but not specifically for agile methods. Given this scenario, the following research question arises: what is the impact of software method tailoring criteria on the adoption of agile practices? To answer this question, we conducted a survey among agile practitioners in Brazil to gather data about importance of the tailoring criteria and agile practices adopted. A model for agile practices adoption based on the tailoring criteria is proposed using the results of the survey with a majority of novice agile practitioners. The proposed model was validated using PLS-SEM (partial least squares structural equation modeling) and the survey data. Results show that adoption of agile practices was influenced by criteria such as external environment, previous knowledge and internal environment. Results also indicate that organizations tend to use hybrid/custom software methods and select agile practices according to their needs.	Agile method tailoring, Tailoring criteria, Agile practices selection, Agile practices adoption, PLS-SEM, Software method tailoring	Campanelli, Amadeu Silveira; Camilo, Ronaldo Darwich; Parreiras, Fernando Silva	Journal of Systems and Software					Excluded	Excluded	new_screen			2						
256	Behave	Rules of thumb to increase the software quality through testing	The software maintenance typically requires 40-80% of the overall project costs, and this considerable variability mostly depends on the software internal quality: the more the software is designed and implemented to constantly welcome new changes, the lower will be the maintenance costs. The internal quality is typically enforced through testing, which in turn also affects the development and maintenance costs. This is the reason why testing methodologies have become a major concern for any company that builds - or is involved in building - software. Although there is no testing approach that suits all contexts, we infer some general guidelines learned during the Development of the Italian Single-dish COntrol System (DISCOS), which is a project aimed at producing the control software for the three INAF radio telescopes (the Medicina and Noto dishes, and the newly-built SRT). These guidelines concern both the development and the maintenance phases, and their ultimate goal is to maximize the DISCOS software quality through a Behavior-Driven Development (BDD) workflow beside a continuous delivery pipeline. We consider different topics and patterns; they involve the proper apportion of the tests (from end-to-end to low-level tests), the choice between hardware simulators and mockers, why and how to apply TDD and the dependency injection to increase the test coverage, the emerging technologies available for test isolation, bug fixing, how to protect the system from the external resources changes (firmware updating, hardware substitution, etc.) and, eventually, how to accomplish BDD starting from functional tests and going through integration and unit tests. We discuss pros and cons of each solution and point out the motivations of our choices either as a general rule or narrowed in the context of the DISCOS project. © COPYRIGHT SPIE. Downloading of the abstract is permitted for personal use only.		Buttu M., Bartolini M., Migoni C., Orlati A., Poppi S., Righini S.	Proceedings of SPIE - The International Society for Optical Engineering					Excluded	Excluded	new_screen			2						
257	Behave	Automated testing framework development based on social interaction and communication principles	The speed of development of the IT industry as well as the computational power which are increasing exponentially, create great competitiveness in the process of development but also in the launching of software products on the market. Automated testing comes to help with these challenges by trying to increase the speed of development by offering fast feedback and trustworthy quality by means of repeated runs of the implemented tests. This isn't a problem just on a technical level, but also on a social level, especially in the area of communication and understanding the requirements of the client. This work presents the implementation of an automated testing framework which also addresses the social problems. BDD or “Behavior Driven Development” includes an approach which would like to line up the area of client requests to the technical area, offering a uniform platform of collaboration and development. The implementation of this principle is applied in an MVP (Minimum Viable Product) type project which is meant to demonstrate the technical solution which may draw together, both socially and communication wise, the business teams and the technical implementation teams.	testing process;BDD;automated testing;Gherkin language	A. Contan; L. Miclea; C. Dehelean	2017 14th International Conference on Engineering of Modern Electric Systems (EMES)					Included	Included	new_screen			2						
258	Behave	Enabling faith-inspired education on the sustainable development goals through e-learning	The Sustainable Development Goals (SDGs) are composed from a variety of universal goals. They come with a heavy load on ethical demands while they do not provide any ethical guidance. One possibility to fill this void is to teach the SDGs with a faith-based narrative. Grown out of a workshop by Bread for World we will present our approach of Ownership-inspired Behavior-driven development, which is a strategy for an e-learning governance to introduce an Android app to support e-learning on the SDGs in theological education in remote areas in the Global South. Our goal is to develop a governance strategy for higher theological education to fill the SDGs with a faith-based narrative by using e-learning technology. Based on the staircase curriculum for the education of future church leaders developed by the British FBO Relay Trust we introduce the theoretical framework for this goal, which makes the transfer from a hierarchical governance structure found in many African societies into a dynamic e-learning framework. © Springer International Publishing AG 2018.		Gottschalk J., Winther-Nielsen N.	World Sustainability Series					Excluded	Excluded	new_screen			2						
259	Behave	Using BDD and SBVR to Refine Business Goals into an Event-B Model: A Research Idea	The transition from a requirements document to a formal specification in Event-B is usually manual and ad-hoc. In order to bridge this gap, we propose a method based on Behavior-Driven Development, an agile approach, and that uses a structured natural language conformant to the formalism of the Semantics of Business Vocabulary and Business Rules (SBVR) standard. This method will successively refine a list of high-level business goals into an Event-B model using transformations. In this paper we present our research idea, describing the steps of this method and showing an example based on the Train System scenario described by Abrial.	BDD; event-B; formal methods; method; requirements; SBVR	Siqueira, Fabio Levy; de Sousa, Thiago C.; Silva, Paulo S. Muniz	Proceedings of the 5th International FME Workshop on Formal Methods in Software Engineering					Included	Included	new_screen			2						
260	Behave	Using behaviour-driven development with hardware-software co-design for autonomous load management	The typical approach to designing embedded systems manages the specification and design of the hardware and software separately. HW/SW Co-design is used, in embedded computing, to allow the hardware and the software to be designed and implemented together and make sure that the non-functional properties are met. Behavior-driven development (BDD) is an agile software development approach that spurs collaboration of project stakeholders to ensure the right software is developed to meet their needs. BDD describes the behavior of the system as executable user stories and focuses on how the system behaves for users interact with the system. In this paper, we introduce an approach that integrates BDD with HW/SW Co-design. The approach provides the ability to describe the behavior of the software as executable user stories in a HW/SW Co-design environment. The approach is evaluated using a renewable energy project in collaboration with a private company in Canada to build a system for autonomous load management of self-forming renewable energy nanogrids.	Embedded Systems;Behaviour-Driven Development;Hardware-Software Co-Design;Test-driven development;Nanogrid systems;Agile software	M. Alhaj; G. Arbez; L. Peyton	2017 8th International Conference on Information and Communication Systems (ICICS)					Included	Included	new_screen			2						
261	Behave	Towards automated requirements checking throughout development processes of interactive systems	The user-centered development process of interactive systems is iterative and, during multiple iterations, users have the opportunity to bring new requirements that are very likely to have an impact, not only in future development, but also affect previously developed artifacts. Manual testing of all artifacts when new requirements are introduced can be cumbersome and time consuming. For that, we need flexible methods to ensure continuous consistency and accuracy among the various artifacts employed to build interactive systems. The ultimate goal of this position paper is to briefly present our vision on an approach for automating the requirements assessment using a Behavior-Driven Development perspective. Thereby, automated tests can run early in the design process, providing a continuous quality assurance of requirements, and helping clients and teams to identify potential problems and inconsistencies before commitments with software implementation.		Silva T.R., Winckler M.A.A.	CEUR Workshop Proceedings					Excluded	Excluded	new_screen			2						
262	Behave	Automated Test Input Generation via Model Inference Based on User Story and Acceptance Criteria for Mobile Application Development	"There has been observed explosive growth in the development of mobile applications (apps) for Android and iOS operating systems, which has led to the direct impact towards mobile app development. In order to design and propose quality-oriented apps, it is the primary responsibility of developers to devote time and sufficient efforts towards testing to make the apps bug-free and operational in the hands of end-users without any hiccup. Manual testing procedures take a prolonged amount of time in writing test cases, and in some cases, the full testing requirements are not met. Besides, the insufficient knowledge of tester also impacts the overall quality and bug-free apps. To overcome the obstacles of testing, we propose a new testing methodology cum tool called ""AgileUATM"" which works primarily towards white-box and black-box testing. To evaluate the validity of the proposed tool, we put the tool in a real-time operational environment concerning mobile test apps. By using this tool, all the acceptance criteria are determined via user stories. The testers/developers specify requirements with formal specifications based on programs properties, predicates, invariants, and constraints. The results show that the proposed tool generated effective and accurate test cases, test input. Meanwhile, expected output was also generated in a unified fashion from the user stories to meet acceptance criteria. The proposed solution also reduced the development time to identify test data as compared to manual Behavior-Driven Development (BDD) methodologies. This tool can support the developers to get a better idea about the required tests and able to translate the customer's natural languages to computer languages as well. This paper fulfills an approach to suitably test mobile application development. © 2020 World Scientific Publishing Company."		Nguyen D.-M., Huynh Q.-T., Ha N.-H., Nguyen T.-H.	International Journal of Software Engineering and Knowledge Engineering					Included	Included	new_screen			2						
263	Behave	Security and privacy behavior definition for behavior driven development	There is an issue when security measures are implemented and tested while using agile software development techniques such as Behavior Driven Development (BDD). We need to define the necessary levels of security and the privacy behaviors and acceptance criteria for the BDD. A method for defining the acceptance criteria (BehaveSafe) by creating a threat and countermeasure graph called theT&C graph is proposed in this paper. We have estimated the efficiency of our method with a web based system. © Springer International Publishing Switzerland 2014.		Okubo T., Kakizaki Y., Kobashi T., Washizaki H., Ogata S., Kaiya H., Yoshioka N.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)					Included	Included	new_screen			2						
264	Behave	Effort Estimation using Bayesian Networks for Agile Development	This article proposes an automatic method to estimate the effort of development based on narrative texts. Narrative used the agile method. We propose techniques of symbolic analysis of natural language were used for extraction of verbs and nouns, and verbal reduction (verbs in infinitive), and the standardization of keywords through synonyms. For the machine learning was used if the naive Bayesian classifier model. Apply and test the model in real environment that used the narratives in the Portuguese language in the form of BDD (Behavior Driven Development). In these tests, obtaining an accuracy of 83% in the estimates of the story points.	Bayesian network model;Agile;Estimation	C. Ratke; H. H. Hoffmann; T. Gaspar; P. E. Floriani	2019 2nd International Conference on Computer Applications & Information Security (ICCAIS)					Excluded	Excluded	new_screen			2						
265	Behave	Test-Driven Java Development - Second Edition: Invoke TDD Principles for End-to-End Application Development	This book will teach the concepts of test driven development in Java so you can build clean, maintainable and robust code Key Features Explore the most popular TDD tools and frameworks and become more proficient in building applicationsCreate applications with better code design, fewer bugs, and higher test coverage, enabling you to get them to market quickly Implement test-driven programming methods into your development workflows Book Description Test-driven development (TDD) is a development approach that relies on a test-first procedure that emphasizes writing a test before writing the necessary code, and then refactoring the code to optimize it. The value of performing TDD with Java, one of the longest established programming languages, is to improve the productivity of programmers and the maintainability and performance of code, and develop a deeper understanding of the language and how to employ it effectively. Starting with the basics of TDD and understanding why its adoption is beneficial, this book will take you from the first steps of TDD with Java until you are confident enough to embrace the practice in your day-to-day routine. You'll be guided through setting up tools, frameworks, and the environment you need, and we will dive right into hands-on exercises with the goal of mastering one practice, tool, or framework at a time. You'll learn about the Red-Green-Refactor procedure, how to write unit tests, and how to use them as executable documentation. With this book, you'll also discover how to design simple and easily maintainable code, work with mocks, utilize behavior-driven development, refactor old legacy code, and release a half-finished feature to production with feature toggles. You will finish this book with a deep understanding of the test-driven development methodology and the confidence to apply it to application programming with Java. What you will learn Explore the tools and frameworks required for effective TDD development Perform the Red-Green-Refactor process efficiently, the pillar around which all other TDD procedures are based Master effective unit testing in isolation from the rest of your code Design simple and easily maintainable code by implementing different techniques Use mocking frameworks and techniques to easily write and quickly execute tests Develop an application to implement behavior-driven development in conjunction with unit testing Enable and disable features using feature toggles Who This Book Is ForIf you're an experienced Java developer and want to implement more effective methods of programming systems and applications, then this book is for you.		Garcia, Alex; Farcic, Viktor						Excluded	Excluded	new_screen			2						
266	Behave	Behavior-driven development using specification by example: An approach for delivering the right software built in right way	"This chapter highlights a crucial problem seen often in software development that is bridging the communication gap between business and Development"" (BDD) methodology supplemented with ""Specification By Example"" approach of delivering the right software that matters. Effective communication has always been a challenge between clients, business stakeholders, project managers, developers, testers and business analysts because a ""ubiquitous"" language that every one can easily understand and use does not exist. Specification By Example serves as that ubiquitous language for all, helps build right software that matters through effective communication. Specifications are written in plain English language using the Gherkin syntax to describe various behaviors of software. BDD tools help write software specification using gherkin language and also create a living documentation that is automatically generated by programming language reflecting the current state of software at any given point of time. © 2016 by IGI Global. All rights reserved."		Menon P.R.	Emerging Innovations in Agile Software Development					Excluded	Excluded	new_screen			2						
267	Behave	The Business Transformation Framework and Enterprise Architecture Framework for Managers in Business Innovation: An Applied Holistic Mathematical Model	This journal article proposes a cross-business domain applied holistic mathematical model (AHMM) that is the result of a lifetime long research on business transformations, applied mathematics, software modelling, business engineering, financial analysis, and global enterprise architecture. This ultimate research is based on an authentic and proprietary mixed research method that is supported by an underlining mainly qualitative holistic reasoning model module. The proposed AHMM formalism attempts to mimic some functions of the human brain, which uses empirical processes that are mainly based on the beam-search, like heuristic decision-making process. The AHMM can be used to implement a decision-making system or an expert system that can integrate in the enterprise’s business, information and communication technology environments. The AHMM uses a behaviour driven development environment or a natural language environment that can be easily adopted by the project’s development teams. The AHMM offers a high level implementation environment that can be used by any team member without any prior computer sciences qualification. The AHMM can be used also to model enterprise architecture (EA) blueprints, business transformation projects, or knowledge management systems; it is supported by many real-life cases of various business domains. The uniqueness of this research is that the AHMM promotes a holistic unbundling process, the alignment of various EA standards and transformation strategies to support business transformation projects. © 2021 IGI Global. All rights reserved.		Trad A.	International Journal of Service Science, Management, Engineering, and Technology					Excluded	Excluded	new_screen			2						
268	Behave	Ontological syntax highlighting	This paper deals with the special type of syntax highlighting which is powered by combination of DEMO methodology (Design & Engineering Methodology for Organizations), BDD technique (Behaviour-Driven Development). Main contribution of this paper is the idea how to highlight business relevant code in IDEs (Integrated Development Environments) and notice a developer about the fact that important part of code base is edited. The proposal of the implementation encounters usage of code coverage technique and user stories derived upon DEMO methodology. © 2018 Author(s).		Matula J., Zacek J.	AIP Conference Proceedings					Included	Included	new_screen			2						
269	Behave	A History of the Groovy Programming Language	This paper describes the history of the Groovy programming language. At the time of Groovy’s inception, Java was a dominant programming language with a wealth of useful libraries. Despite this, it was perceived by some to be evolving slowing and to have shortcomings for scripting, rapid prototyping and when trying to write minimalistic code. Other languages seemed to be innovating faster than Java and, while overcoming some of Java’s shortcomings, used syntax that was less familiar to Java developers. Integration with Java libraries was also non-optimal. Groovy was created as a complementary language to Java—its dynamic counterpart. It would look and feel like Java but focus on extensibility and rapid innovation. Groovy would borrow ideas from dynamic languages like Ruby, Python and Smalltalk where needed to provide compelling JVM solutions for some of Java’s shortcomings. Groovy supported innovation through its runtime and compile-time metaprogramming capabilities. It supported simple operator overloading, had a flexible grammar and was extensible. These characteristics made it suitable for growing the language to have new commands (verbs) and properties (nouns) specific to a particular domain, a so called Domain Specific Language (DSL). While still intrinsically linked with Java, over time Groovy has evolved from a niche dynamic scripting language into a compelling mainstream language. After many years as a principally dynamically-typed language, a static nature was added to Groovy. Code could be statically type checked or when dynamic features weren’t needed, they could be turned off entirely for Java-like performance. A number of nuances to the static nature came about to support the style of coding used by Groovy developers. Many choices made by Groovy in its design, later appeared in other languages (Swift, C#, Kotlin, Ceylon, PHP, Ruby, Coffeescript, Scala, Frege, TypeScript and Java itself). This includes Groovy’s dangling closure, Groovy builders, null-safe navigation, the Elvis operator, ranges, the spaceship operator, and flow typing. For most languages, we don’t know to what extent Groovy played a part in their choices. We do know that Kotlin took inspiration from Groovy’s dangling closures, builder concept, default it parameter for closures, templates and interpolated strings, null-safe navigation and the Elvis operator. The leadership, governance and sponsorship arrangements of Groovy have evolved over time, but Groovy has always been a successful highly collaborative open source project driven more by the needs of the community than by a vision of a particular company or person.	Closure; Domain Specific Languages; Dynamic typing; Extensibility; Functional programming; Metaprogramming; Object-oriented; Scripting; Static typing	King, Paul	Proc. ACM Program. Lang.					Excluded	Excluded	new_screen			2						
270	Behave	Integrating behavior driven development and programming by contract	This paper developed a Contracted Behavior Driven Development (CBDD) method that extends and combines the ideas behind Test/Behavior Driven Development (TDD/BDD) and Programming by Contract (PBC) to improve the overall stability and quality of a system. A tool is developed to derive unit tests automatically by analyzing human written specifications for preconditions and post-conditions when coupled with data definitions. These results will be used to generate code to be run by a unit testing framework before deployment, either as part of a continuous integration environment or by individual developers. The tool will also generate wireframe classes implementing pre and post-conditions within the code and using runtime contract analysis to generate information when an exception occurs, thereby helping to automate verification of bug fixes. © 2013 Springer-Verlag Berlin Heidelberg.		Schoeneman L., Liu J.B.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)					Included	Included	new_screen			2						
271	Behave	Transit use and the work commute: Analyzing the role of last mile issues	This paper examines the role that public transport last mile problems play in mode choice decisions of commuters, while controlling for trip, built environment, and decision maker related variables. Last-mile problems arise due to lack of adequate connectivity between transit stops and trip origin or termination points. The paper is motivated by previous literature which has pointed out that high-quality public transit needs to consider end-to-end connectivity from trip origins to destinations. In contrast to previous work on transit last mile problems, which has focused on physical distance and sidewalks to transit stops, we consider a wider range of area factors including transit availability, job accessibility, parking costs, the quality of the pedestrian environment and risks to pedestrians from vehicular traffic, and social characteristics such as street-level crime. Using a discrete choice model, our goal is to unpack ways in which such factors contribute to the last-mile problem in home-based work trips, while controlling for these wider range of factors as well as the usual variables such as cost and trip time that inform mode choice. We find that the prevalence of non-domestic violent crimes reduces the odds of using all types of non-motorized alternatives as well as transit that is accessed either by walking or driving. Using compensating variation to measure welfare changes, we show that there are significant benefits that could be brought to transit service users through increasing safety in the transit access trip. By separately controlling for origin and destination transit accessibility, we show that improved destination accessibility significantly boosts transit use to a greater degree than increases in origin level accessibility. These findings argue for improving accessibility and related job densities at employment centers.	Transit use, Last mile problems, Crime, Accessibility, Destination accessibility, Mode choice	Tilahun, Nebiyou; Thakuriah, Piyushimita (Vonu); Li, Moyin; Keita, Yaye	Journal of Transport Geography					Excluded	Excluded	new_screen			2						
272	Behave	Extending behavior-driven development for assessing user interface design artifacts	This paper presents a scenario-based approach to specify requirements and tests by extending Behavior-Driven Development (BDD) with the aim of ensuring the consistency between user requirements and user interface design artifacts. The approach has been evaluated by exploiting user requirements specified by a group of potential Product Owners (POs) for a web system to book business trips. Such requirements gave rise to a set of User Stories that have been refined and used to automatically check the consistency of task models, user interface (UI) prototypes, and final UIs of the system. The results have shown our approach was able to identify different types of inconsistencies in the set of analyzed artifacts and consistently keep the semantic traces between them. © 2019 Knowledge Systems Institute Graduate School. All rights reserved.		Silva T.R., Winckler M., Trætteberg H.	Proceedings of the International Conference on Software Engineering and Knowledge Engineering, SEKE					Included	Included	new_screen			2						
273	Behave	Beast Methodology: An Agile Testing Methodology for Multi-Agent Systems Based on Behaviour Driven Development	This paper presents a testing methodology to apply Behaviour Driven Development (BDD) techniques while developing Multi-Agent Systems (MASs), termed BEhavioural Agent Simple Testing (BEAST) Methodology. This methodology is supported by the open source framework (BEAST Tool) which automatically generates test cases skeletons from BDD scenarios specifications. The developed framework allows the testing of MASs based on JADE or JADEX platforms. In addition, this framework offers a set of configurable Mock Agents with the aim of being able to execute tests while the MAS is under development. The BEAST Methodology presents transparent traceability from user requirements to test cases. Thus, the stakeholders can be aware of the project status. The methodology and the associated tool have been validated in the development of a MAS for fault diagnosis in FTTH (Fiber To The Home) networks. The results have been measured in quantifiable way obtaining a reduction of the tests implementation time.	Behaviour-driven development; Multi-agent systems; Agile; Methodology; Mock-agents; Test	Carrera, Álvaro; Iglesias, Carlos A.; Garijo, Mercedes	Information Systems Frontiers					Excluded	Excluded	new_screen			2						
274	Behave	Beast methodology: An agile testing methodology for multi-agent systems based on behaviour driven development	This paper presents a testing methodology to apply Behaviour Driven Development (BDD) techniques while developing Multi-Agent Systems (MASs), termed BEhavioural Agent Simple Testing (BEAST) Methodology. This methodology is supported by the open source framework (BEAST Tool) which automatically generates test cases skeletons from BDD scenarios specifications. The developed framework allows the testing of MASs based on JADE or JADEX platforms. In addition, this framework offers a set of configurable Mock Agents with the aim of being able to execute tests while the MAS is under development. The BEAST Methodology presents transparent traceability from user requirements to test cases. Thus, the stakeholders can be aware of the project status. The methodology and the associated tool have been validated in the development of a MAS for fault diagnosis in FTTH (Fiber To The Home) networks. The results have been measured in quantifiable way obtaining a reduction of the tests implementation time. © 2013 Springer Science+Business Media New York.		Carrera A., Iglesias C.A., Garijo M.	Information Systems Frontiers					Included	Included	new_screen			2						
275	Behave	A Study of Test Techniques for Integration with Domain Driven Design	This paper presents an exploratory study on agile techniques for software testing Test-Driven Development and Behaviour-Driven Development for integration with the agile software development technique known as Domain-Driven Design. It also comprises a comparison between both test approaches, enhancing the strengths and weaknesses of each one. To make it feasible the integration proposal, an example of domain using Apache Isis framework was developed. According to the study performed, the possibility of creating an automatic test generator to make it agile the validation of entities attributes of the domain model was noted.	Behaviour-Driven Development; Apache Isis; Domain-Driven Development; Software Test; Test-Driven Development	Santos, Eloisa Cristina Silva; Beder, Delano Medeiros; Penteado, Rosângela A. Dellosso	Proceedings of the 2015 12th International Conference on Information Technology - New Generations					Included	Included	new_screen			2						
276	Behave	A Behaviour-Driven Development Approach for Cyber-Physical Production Systems	This paper proposes a method for iterative engineering of cyber-physical production systems (CPPS) that allows early testing of virtual prototypes and early involvement of domain experts. It is based on behaviour-driven development (BDD) from agile software engineering, which is adapted to address a set of issues relevant for CPPS engineering including the use of standardised CPPS models, integration testing, test environments, and brownfield development. The paper describes these adaptations and synthesises them into a procedural model of BDD for CPPS. Finally, a prototypical test system for CPPS is presented that partially implements the approach. © 2020 IEEE.		Kannengiesser U., Krenn F., Stary C.	Proceedings - 2020 IEEE Conference on Industrial Cyberphysical Systems, ICPS 2020					Included	Included	new_screen			2						
277	Behave	Lu-Lu	This paper proposes Lu-Lu as an add-on architecture to open MMOGs and social network games, which has been developed to utilise a key set of ingredients that underline collaborative decision making games as reported within the research literature: personalisation, team matching, non-optimal decision making, leading, decisiveness index, scoring, levelling, and multiple stages. The implementation of Lu-Lu is demonstrated as an add-on to the classic supply chain beer game, including customisation of Lu-Lu to facilitate information exchange through the Facebook games platform, e.g., Graph API and Scores API. Performance assessment of Lu-Lu using Behaviour-Driven Development suggests a successful integration of all key ingredients within Lu-Lu's architecture, yielding autonomous behaviour that improves both player enjoyment and decision making.	Collaborative; Decision making; Game; MPEG-7; Personalisation; Profiling	Daylamani-Zad, Damon; Angelides, Marios C.; Agius, Harry	Decis. Support Syst.					Excluded	Excluded	new_screen			2						
278	Behave	Lu-Lu: A framework for collaborative decision making games	This paper proposes Lu-Lu as an add-on architecture to open MMOGs and social network games, which has been developed to utilise a key set of ingredients that underline collaborative decision making games as reported within the research literature: personalisation, team matching, non-optimal decision making, leading, decisiveness index, scoring, levelling, and multiple stages. The implementation of Lu-Lu is demonstrated as an add-on to the classic supply chain beer game, including customisation of Lu-Lu to facilitate information exchange through the Facebook games platform, e.g., Graph API and Scores API. Performance assessment of Lu-Lu using Behaviour-Driven Development suggests a successful integration of all key ingredients within Lu-Lu's architecture, yielding autonomous behaviour that improves both player enjoyment and decision making.	Collaborative, Decision making, Game, Profiling, Personalisation, MPEG-7	Daylamani-Zad, Damon; Angelides, Marios C.; Agius, Harry	Decision Support Systems					Excluded	Excluded	new_screen			2						
279	Behave	An Approach for Guiding Developers in the Choice of Security Solutions and in the Generation of Concrete Test Cases	This paper tackles the problems of choosing security solutions and writing concrete security test cases for software, which are two tasks of the software life cycle requiring time, expertise and experience. We propose in this paper a method, based upon the notion of knowledge base, for helping developers devise more secure applications from the threat modelling step up to the testing one. The first stage of the approach consists of the acquisition and integration of publicly available security data into a data store. This one is used to assist developers in the design of attack-defense trees expressing the attacker possibilities to compromise an application and the defenses that may be implemented. These defenses are given under the form of security pattern combinations, a security pattern being a generic and reusable solution to design more secure applications. In the second stage, these trees are used to guide developers in the test case generation. Test verdicts show whether an application is vulnerable to the threats modelled by an ADTree and whether the consequences of the chosen security patterns are observed from the application (a consequence leading to some observable events partly showing that a pattern is correctly implemented). We applied this approach to web applications and evaluated it on 24 participants. The results are very encouraging in terms of the two criteria: comprehensibility and effectiveness.	Security; Attack-defense trees; Security patterns; Test case generation	Salva, Sébastien; Regainia, Loukmen	Software Quality Journal					Excluded	Excluded	new_screen			2						
280	Behave	Parsing BDD Stories for Automated Verification of Software Artefacts	This position paper reports on our ongoing developments towards the automated verification of software artefacts by parsing sentences on Behaviour-Driven Development (BDD) stories. The solution we propose is based on different strategies for analysing the consistency of user requirements specified in BDD stories on task models, graphical user interfaces (GUIs), GUI prototypes, and domain models. We illustrate our solution through concrete examples and discuss its challenges and limitations. © 2020, Electronic Communications of the EASST. All rights reserved.		Silva T.R., Fitzgerald B.	Electronic Communications of the EASST					Included	Included	new_screen			2						
281	Behave	Tit for tat and big steps: The case of Swedish banks’ internationalization 1961–2010	This study examines four major Swedish banks’ internationalization process patterns during the period 1961–2010. The study complements earlier studies by also considering the banks’ levels of market commitment. One objective is to determine if ‘Tit for tat’-behaviour seen in earlier studies of Swedish banks still prevails after the deregulation. Adding to earlier studies, this study also considers the level of market activities and commitments. A secondary purpose is to examine how the financial crisis has affected the banks with reference to the banks’ internationalization patterns. The empirical study is based on archival data on the studied banks’ foreign operations. The results show that the banks’ behaviour follows ‘Tit for tat’-behaviour but that the internationalization has accelerated after the deregulation, hence being carried out with ‘big steps’ rather than small steps. The analysis also shows that the mimetic behaviour is complemented by other types of internationalization behaviours. The differences in bank internationalization also mean that the effect of a financial crisis varies depending on how the banks have internationalized.	Banks, Commitment, Financial crisis, Internationalization process, Longitudinal study	Ekman, Peter; Hadjikhani, Annoch Isa; Pajuvirta, Andreas; Thilenius, Peter	International Business Review					Excluded	Excluded	new_screen			2						
282	Behave	A case study of agile software development for safety-Critical systems projects	This study explores the introduction of agile software development within an avionics company engaged in safety-critical system engineering. There is increasing pressure throughout the software industry for development efforts to adopt agile software development in order to respond more rapidly to changing requirements and make more frequent deliveries of systems to customers for review and integration. This pressure is also being experienced in safety-critical industries, where release cycles on typically large and complex systems may run to several years on projects spanning decades. However, safety-critical system developments are normally highly regulated, which may constrain the adoption of agile software development or require adaptation of selected methods or practices. To investigate this potential conflict, we conducted a series of interviews with practitioners in the company, exploring their experiences of adopting agile software development and the challenges encountered. The study also explores the opportunities for altering the existing software process in the company to better fit agile software development to the constraints of software development for safety-critical systems. We conclude by identifying immediate future research directions to better align the tempo of software development for safety-critical systems and agile software development.		Islam, Gibrail; Storer, Tim	Reliability Engineering & System Safety					Excluded	Excluded	new_screen			2						
283	Behave	Does IT team climate matter? An empirical study of the impact of co-workers and the Confucian work ethic on deviance behavior	This study seeks to determine the impact of IT co-workers on individual deviance behavior in organizations. Using data collected from 322 IT employees and their supervisors in Chinese software companies, we also examine the impact of the Confucian work ethic on deviant behavior. The results suggest that both co-workers’ production deviance and the Confucian work ethic have impacts on individuals’ production deviance. The influence of IT co-workers’ production deviance was greater in high team climates and low team climates than in neutral team climates. The Confucian work ethic has no significant influence on production deviance in low team climates.	Confucian work ethic, IT co-worker production deviance, IT team climate	Zhang, Hanpeng; Luo, Xin (Robert); Liao, Qinyu; Peng, Lifang	Information & Management					Excluded	Excluded	new_screen			2						
284	Behave	Legislation-driven development of a Gift Aid system using Event-B	This work presents our approach to formally model the Swiftaid system design, a digital platform that enables donors to automatically add Gift Aid to donations made via card payments. Following principles of Behaviour-Driven Development, we use Gherkin to capture requirements specified in legislation, specifically the UK Charity (Gift Aid Declarations) Regulations 2016. The Gherkin scenarios provide a basis for subsequent formal modelling and analysis using Event-B, Rodin and ProB. Interactive model simulations assist communication between domain experts, software architects and other stakeholders during requirements capture and system design, enabling the emergent system behaviour to be validated. Our approach was employed within the development of the real Swiftaid product, launched by Streeva in February 2019. Our analysis helped conclude that there was not a strong enough business case for one of the features, whichwas shown to provide nominal user convenience at the expense of increased complexity. This work provides a case study in allying formal and agile software development to enable rapid development of robust software. © 2020, The Author(s).		Williams D.M., Darwish S., Schneider S., Michael D.R.	Formal Aspects of Computing					Included	Included	new_screen			2						
285	Behave	Test Descriptions with ETSI TDL	To address the need for abstract, high-level test descriptions that can be shared among different stakeholders, the European Telecommunications Standards Institute (ETSI) commissioned the design of the Test Description Language (TDL). TDL is designed as a domain-specific language for testing, consisting of a standardised abstract syntax (meta-model) and concrete syntaxes for textual specification, graphical design, and model exchange between tools. Its main purpose is to support a test methodology that is followed in the standardisation work for software-intense systems at ETSI and is applicable in industrial projects as well. TDL enables the formal specification of both test objectives derived from system requirements and test descriptions refining the test objectives. The latter serve as blueprint for the implementation of executable tests. A standardised mapping of TDL specifications to test scripts in the standardised test execution language TTCN-3 widens the reach of TDL to ensure compatibility and consistency of generated executable tests. An open-source toolset has been developed as a common platform to accelerate the adoption of TDL and lower the barrier to entry for users and tool vendors. Reports from pilot applications within three ETSI standardisation groups demonstrate the practicality of the chosen approach.	Model-based testing; Domain-specific modelling; Test description language; Test methodology; Testing in standardisation	Makedonski, Philip; Adamis, Gusztáv; Käärik, Martti; Kristoffersen, Finn; Carignani, Michele; Ulrich, Andreas; Grabowski, Jens	Software Quality Journal					Excluded	Excluded	new_screen			2						
286	Behave	Enabling IoT Platform Interoperability Using a Systematic Development Approach by Example	Today, the IoT landscape consists of a large number of vertical IoT platforms that are rarely interconnected. To enable creation of applications across platforms and domain boundaries interoperability needs to be established between IoT platforms. In this paper we present how this task can be simplified by utilizing a systematic software development process based on behavior- and domain-driven development. This process is illustrated using an example that uses the open source IoT interoperability framework symbIoTe to connect two indoor navigation platforms. We show that developers can actually profit from this approach but existing IoT interoperability frameworks are still cumbersome to use.	Internet of Things;IoT;interoperability;semantic interoperability;behavior-driven development;domain-driven design	M. Schneider; B. Hippchen; S. Abeck; M. Jacoby; R. Herzog	2018 Global Internet of Things Summit (GIoTS)					Included	Included	new_screen			2						
287	Behave	Mining reading patterns from eye-tracking data: method and demonstration	Understanding how developers interact with different software artifacts when performing comprehension tasks has a potential to improve developers’ productivity. In this paper, we propose a method to analyze eye-tracking data using process mining to find distinct reading patterns of how developers interacted with the different artifacts. To validate our approach, we conducted an exploratory study using eye-tracking involving 11 participants. We applied our method to investigate how developers interact with different artifacts during domain and code understanding tasks. To contextualize the reading patterns and to better understand the perceived benefits and challenges participants associated with the different artifacts and their choice of reading patterns, we complemented the eye-tracking data with the data obtained from think aloud. The study used behavior-driven development, a development practice that is increasingly used in Agile software development contexts, as a setting. The study shows that our method can be used to explore developers’ behavior at an aggregated level and identify behavioral patterns at varying levels of granularity. © 2019, Springer-Verlag GmbH Germany, part of Springer Nature.		Ioannou C., Nurdiani I., Burattin A., Weber B.	Software and Systems Modeling					Excluded	Excluded	new_screen			2						
288	Behave	Testing Web Applications with State Objects	Use states to drive your tests.		van Deursen, Arie	Commun. ACM					Excluded	Excluded	new_screen			2						
289	Behave	User Interface Prototype Generation from Agile Requirements Specifications Written in Concordia	User interface prototypes (UIP) are widely used to get feedback before building a software feature. They can prevent misunderstandings between the software development team and other stakeholders (e.g., users, investors) that lead to rework or a resulting software that does not meet their needs. UIP can also be a valuable resource in Agile software development, in which feedback is key. In this paper, we present an approach to generate UIP automatically from Agile requirements specifications written in Concordia and its corresponding prototype tool. The tool is able to generate UIP for web-based applications. We evaluated the approach and the tool with questionnaires, and the results revealed that: (i) the generated UIP are very similar to those drawn by respondents; (ii) the generated source code has good enough quality to be reused by developers; and (iii) they save design and development time.	user story; agile; concordia; generation; user interface	Pinto, Thiago Delgado; Gonçalves, Willian Inacio; Costa, Pablo Veiga	Proceedings of the 25th Brazillian Symposium on Multimedia and the Web					Included	Included	new_screen			2						
290	Behave	Remote but Connected: Ownership-Inspired Behavior-Driven Development and What an E-Learning Governance System for Africa Could Look like	Using e-learning technology is one key for developing sustainable education in urban and remote areas in Western Africa as it reduced the demands on students who are well integrated in their rural society to leave their homes for an expensive education. In this chapter we present Ownership-inspired Behavior-Driven Development (OIBBD), a development strategy designed for e-learning governance in remote areas in Africa to support sustainable education as part of the agenda 2030 and the Sustainable Development Goals (SDGs) and show how the design of a User Experience (UX), which is based on user-centered design and feedback from the African target group can be used to support the implementation of e-learning in Africa. We reflect on how a governance for sustainable development in theological education on the African continent can look like. We ask how such an e-learning governance can support remote e-learning in hard to reach areas in Africa and how this can be designed specifically of the needs of the African socio-culture. The guiding hypothesis of this chapter is, that especially leadership and its activation in African teachers can trigger them to develop ownership in using e-learning technology and this way supports the reaching of SDG 4, which deals with sustainable education. © 2018, Springer International Publishing AG.		Gottschalk J., Winther-Nielsen N.	World Sustainability Series					Excluded	Excluded	new_screen			2						
291	Behave	Approach of integrating behaviour-driven development with hardware/software codesign	Using typical approaches in designing embedded systems to manage the specification and design of the hardware and software is not suitable in today’s projects. In this paper, we propose a model-driven approach to integrate Hardware/Software codesign with Behaviour-Driven Development. Hardware/Software codesign approach allows the hardware and the software to be designed and implemented concurrently and optimizes the project design constraint, such as performance and cost. Behaviour-Driven Development spurs project stakeholders to collaborate to ensure the right software is developed to meet their needs and ensures that all project participants communicate in the same language. The approach exploits the advantages of each approach and provides the ability to describe the behaviour of the software as executable user stories in a Hardware/Software codesign environment. The approach is evaluated using a renewable energy project in collaboration with a private company in Canada to build a system for autonomous load management of self-forming renewable energy nanogrids. © 2019, ICIC International. All righs reserved.		Alhaj M., Arbez G., Peyton L.	International Journal of Innovative Computing, Information and Control					Included	Included	new_screen			2						
292	Behave	Modeling test cases in BPMN for behavior-driven development (extended abstract)	Validating analytical business processes and testing executable ones are difficult task in process development projects. Within the project Terravis, which builds a process hub for enabling fully digitalized mortgage processes between Swiss land registries, banks, notaries and other parties, these tasks became problematic. For improving stakeholder communication and extending the test scope, behavior-driven development was adapted to BPMN and business processes. This technique was introduced and very well received within the project, leading to better process documentation and better tests.		Lübke D., Van Lessen T.	CEUR Workshop Proceedings					Excluded	Excluded	new_screen			2						
293	Behave	Chapter 11 - Validation of DEVS Models Using AGILE-Based Methods	Validation of discrete event system specification (DEVS) models at the early phases of the discrete-event modeling and simulation design process is a crucial topic when dealing with complex DEVS models. Based on software engineering test methods, we present in this chapter a new approach, which integrates Agile test methods in the process of the simulation in order to design and test DEVS models. We propose an implementation in Python language based on the use of aspect programming concepts (patch, mocking objects, and decorators). This implementation is performed in the framework of the DEVSimPy environment with the definition of a plug-in dedicated to the automatic generation and execution of test scenario.	Modeling, Simulation, Discrete event, Formalism, AGILE, Validation	Capocchi, L.; Santucci, J. F.						Excluded	Excluded	new_screen			2						
294	Behave	Gherkin Syntax Extension for Parameterization of Network Switch Configurations in Test Specification	We applied test automation in the style of Behavior-Driven Development (BDD), an agile software development technique. In applying BDD, the problem is that a large amount of similar configurations of network switches have to be written in the BDD test specification files. To solve this problem, parameterization of configurations is considered effective. However, Gherkin, the BDD test specification language, does not provide syntax for parameterization. In this paper, we propose a syntax extension of Gherkin, which enables parameterization of configurations. From experiments on 11 configurations, parameterization using the proposed syntax extension can reduce the number of the lines used to describe configurations by 39%.	test specification;parameterization;BDD;Gherkin;syntax extension;network switch;configuration	T. Li; S. Tsubota; K. Hirono	2017 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)					Included	Included	new_screen			2						
295	Behave	Automation and consistency analysis of test cases written in natural language: An industrial context	We present here a novel test automation strategy that receives as input a freestyle natural language (NL) test case (consisting of a sequence of test steps) and produces executable test scripts. This strategy relies on a database of previously automated seed test steps, available for reuse. New steps are automated via a capturing process by a tester, without requiring any programming knowledge. Automated tests can be executed by a replay facility. We discuss the reuse improvement, implementation effort, and user feedback regarding the industrial applicability and usability of our capture & replay tool. We then show that restricting the input textual description to obey a proposed Controlled NL (CNL) brings significant advantages: (1) reuse improvement; (2) the possibility of integration with a test generation framework; and (3) definition of consistency notions for test actions and test action sequences, that ensure, respectively, well-formedness of each action and a proper configuration to safely execute a sequence of actions. We formalize these consistency notions in Alloy and use the Alloy Analyzer to carry out the consistency check; the scalability of the analysis is assessed via an evaluation considering a repository with real test cases; the practical context of our work is mobile device testing, involving a partnership with Motorola Mobility, a Lenovo company.	Test automation, Controlled natural language, Alloy, Test case consistency	Arruda, Filipe; Barros, Flávia; Sampaio, Augusto	Science of Computer Programming					Excluded	Excluded	new_screen			2						
296	Behave	Automatic acceptance testing of the web application security with ITU-T X.805 framework	Web application development companies should ensure the high quality of their products. This can be achieved through high quality of the software development lifecycle. Web applications are mostly running on the Internet and are being exposed to many security threats and malicious operations. The mission of EUCISE2020 project (EUropean test bed for the maritime Common Information Sharing Environment in the 2020 perspective) is to enhance interoperability between systems and networks. The interconnections must be established in a decentralized way using cutting-edge technologies. Hence, it requires innovative and practical solutions from the web development companies. The research problem is being addressed with the Stanford Research Institute NABC (Needs, Approach, Benefits and Competition) method. Our approach is to conceptualize a testing scenario for the web application development process. The concept utilizes the International Telecommunication Union recommended standard security framework (ITU-T X.805) in the context of test automation for end-to-end communications. This study presents a new holistic solution in feature driven fashion. As a result, we propose that building acceptance test scenarios using ITU-T X.805 guidelines in Software Development Lifecycle is a sustainable approach.	EUCISE 2020;ITU-T Recommendation X.805;NABC analysis;web application development;automated testing scenario;behavior-driven development (BDD)	P. Rathod; V. Julkunen; T. Kaisti; J. Nissilä	2015 Second International Conference on Computer Science, Computer Engineering, and Social Media (CSCESM)					Excluded	Excluded	new_screen			2						
297	Behave	Testing of Web Services Using Behavior-Driven Development	Web services are commonly used in the communication of software over the web. To fully trust a web service, it should be tested and certified, but testing of web services provoke new challenges. Behavior-Driven Development (BDD) can be applied to the testing of web services. Gherkin language is used to define scenarios in BDD. We used Gherkin language to define test cases for web services and we developed a tool to convert these test cases into JMeter test scripts.	Behavior-Driven Development; Software Testing; Gherkin; JMeter; Testing of Web Services; Web Services.	Oruç, Ahmet Furkan; Ovatman, Tolga	Proceedings of the 6th International Conference on Cloud Computing and Services Science - Volume 1 and 2					Included	Included	new_screen			2						
298	Behave	ScrumOntoBDD: Agile software development based on scrum, ontologies and behaviour-driven development	When developing a Learning Management System (LMS) using Scrum, we noticed that it was quite often necessary to redefine some system behaviour scenarios, due to ambiguities in the requirement specifications, or due to misinterpretations of stories reported by the Product Owners (POs). The definition of test suites was also cumbersome, resulting in test suites that were incomplete or did not at all comply with the system requirements. Based on this experience and to deal with these problems, in this paper, we propose the ScrumOntoBDD approach to agile software development, which combines Scrum, ontologies and Behaviour-Driven Development (BDD). This approach is centred on the concepts and techniques of Scrum and BDD and focuses on the planning and analysis phases of the software life cycle, since the BDD tools currently provide little support to these phases, while most of the problems during the LMS development were found exactly there. We claim that our approach improves the software development practices in this respect. Furthermore, ScrumOntoBDD employs ontologies in order to reduce ambiguities intrinsic to the use of a natural language as a BDD ubiquitous language. In this paper, we illustrate and systematically evaluate our approach, showing that it is beneficial since it improves the communication between members of an agile development team. © 2021, The Author(s).		Lopes de Souza P., Lopes de Souza W., Ferreira Pires L.	Journal of the Brazilian Computer Society					Included	Included	new_screen			2						
299	Behave	Formal Model Validation Through Acceptance Tests	When formal systems modelling is used as part of the development process, modellers need to understand the requirements in order to create appropriate models, and domain experts need to validate the final models to ensure they fit the needs of stakeholders. A suitable mechanism for such a validation are acceptance tests. In this paper we discuss how the principles of Behaviour-Driven Development (BDD) can be applied to (i) formal modelling and (ii) validation of behaviour specifications, thus coupling those two tasks. We show how to close the gap between the informal domain specification and the formal model, thus enabling the domain expert to write acceptance tests in a high-level language matching the formal specification. We analyse the applicability of this approach by providing the Gherkin scenarios for an formal model of a ‘fixed virtual block’ approach to train movement control, developed according to the Hybrid ERTMS/ETCS Level 3 principles specified by the EEIG ERTMS Users Group and presented as a case study on the 6. International ABZ Conference 2018. © 2019, Springer Nature Switzerland AG.		Fischer T., Dghyam D.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)					Included	Included	new_screen			2						
300	Behave	Executable requirements in a safety-critical context with Ada	When people who need the software and people who build the software do not understand each other, the success of a project may be impacted. In the same way, when it is difficult to know which test case corresponds to a given requirement, or if each and every requirement is fully covered by the test suite, we have a traceability issue that may also impact the success of the project. During the last few years, the agile community has suggested a new development paradigm in order to address this traceability issue. This approach is called Behaviour Driven Development (BDD). It is based on a new way of expressing requirements using a common language understandable by all parties at stake. After having described the Behaviour Driven Development in details, we introduce the XReq tool, an Open Source project developed by SOGILIS and part of the Open-DO project. It is designed to bring the Behaviour Driven Development to the Ada language and other statically typed languages. It also aims at facilitating the traceability of High and Low Level Tests in the context of DO-178B projects.		Bâillon C., Bouchez-Mongardé S.	Ada User Journal					Included	Included	new_screen			2						
301	Behave	Creation of multiple conceptual models from user stories – a natural language processing approach	While Agile methodologies are used in software development, researchers have identified many issues related to requirements engineering in Agile approaches. Some of these issues relate to ambiguity in user stories, which is a widely-used requirements specification mechanism in Agile methodologies. This research proposes the use of conceptual models while developing user stories. We posit that the use of conceptual models helps reducing ambiguity in user stories. An important aspect of our research is the creation of an algorithm for automatic generation of such models while developing the user stories. © Springer Nature Switzerland AG 2019.		Gupta A., Poels G., Bera P.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)					Excluded	Excluded	new_screen			2						
302	Behave	Test Automation with the Gauge Framework: Experience and Best Practices	While Behavior-driven development (BDD) tools such as Cucumber are powerful tools for automated testing, they have certain limitations. For example, they often enforce strict syntax for test cases, like the “Given-When-Then” format, which may not always be easy to write for a given test case. A new test automation framework named Gauge (gauge.org) addresses that limitation since it does not prescribe the BDD testing process with a strict syntax. In Gauge, writing a test case is as easy as writing down the flow of test cases in several itemized sentences in a natural language, like English. In the context of Testinium (testinium.com), a large software testing company which provides software testing services, tools and solutions to a large number of clients, we have actively used the Gauge framework since 2018 to develop large automated front-end test suites for several large web applications. In this paper/talk, the speakers will share several examples and best practices of developing automated tests in natural-language requirements using the Gauge framework. By learning from the ideas presented in the talk, readers (attendees) will be able to consider applying the Gauge framework in their own test automation projects. © 2020, Springer Nature Switzerland AG.		Garousi V., Keleş A.B., Balaman Y., Güler Z.Ö.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)					Excluded	Excluded	new_screen			2						
303	Behave	Leveraging Semi-formal Approaches for DepDevOps	While formal methods have long been praised by the dependable Cyber-Physical System community, continuous software engineering practices are now employing or promoting semi-formal approaches for achieving lean and agile processes. This paper is a discussion about using Behaviour Driven Development, particularly Gherkin and RSpec for DepDevOps, DevOps for dependable Cyber-Physical Systems. © 2020, Springer Nature Switzerland AG.		Zaeske W., Durak U.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)					Included	Included	new_screen			2						
304	Behave	FormTester: Effective Integration of Model-Based and Manually Specified Test Cases	Whilst Model Based Testing (MBT) is an improvement over manual test specification, the leap from it to MBT can be hard. Only recently MBT tools for web applications have emerged that can recover models from existing manually specified test cases. However, there are further requirements for supporting both MBT and manually specified tests. First, we need support for the generation of test initialization procedures. Also, we want to identify areas of the system that are not testable due to defects. We present FormTester, a new MBT tool addressing these limitations. An evaluation with real web applications shows that FormTester helps to reduce the time spent on developing test cases.		Dixit, Rahul; Lutteroth, Christof; Weber, Gerald	Proceedings of the 37th International Conference on Software Engineering - Volume 2					Excluded	Excluded	new_screen			2						
305	Behave	Software Automation Testing Secrets Revealed	Widely acknowledged one of the best practical guide to software test automation, Narayanan Palani's Automation Labs has been helping freshers write better automation test scripts for the last three years! Now this classic book has been fully updated and revised with leading-testing tools–and hundreds of new script samples–illustrating the art and science of automation testing. Capturing the body of knowledge available from strong professional experience and industry best practices, Palani synthesizes the most effective techniques and must-know principles into clear, pragmatic guidance. No matter what your experience level,test environment, or project size, this book will inform and stimulate your thinking–and help you build the highest quality automation scripts. Discover the timeless techniques and framework designing methods that help you:Design for TestNG, Visual Studio, Jenkins, Excel VBA, Selenium, HP UFT (formerly QTP), Ranorex, RFT and other wide ranged QA Testing Tools. Reap the benefits of well built selenium webdriver automation framework! Apply powerful programming techniques to build well-estabilished data driven framework, keyword driven framework, hybrid framework, Agile Continuous Integration Automation Framework. Exploit opportunities to design Web services based SOAP Automation Frameworks with the help of SOA, ETL basics and SQL Automation scripts to validate Database Systems! Use construction practices using Object Recognition Technology of test automation tools and capture dynamic web elements. Debug problems in software development life cycle to improve testing process using test estimation techniques, tool selection process. Build quality automation scripts by understanding the machine learning basics of selenium automation framework Resolve automation issues and introduce cucumber, Specflow based Behaviour Driven Development and Test Driven Development in functional testing.		Palani, Narayanan						Excluded	Excluded	new_screen			2						
306	Behave	ATDD by Example: A Practical Guide to Acceptance Test-Driven Development	With Acceptance Test-Driven Development (ATDD), business customers, testers, and developers can collaborate to produce testable requirements that help them build higher quality software more rapidly. However, ATDD is still widely misunderstood by many practitioners. ATDD by Example is the first practical, entry-level, hands-on guide to implementing and successfully applying it. ATDD pioneer Markus Grtner walks readers step by step through deriving the right systems from business users, and then implementing fully automated, functional tests that accurately reflect business requirements, are intelligible to stakeholders, and promote more effective development. Through two end-to-end case studies, Grtner demonstrates how ATDD can be applied using diverse frameworks and languages. Each case study is accompanied by an extensive set of artifacts, including test automation classes, step definitions, and full sample implementations. These realistic examples illuminate ATDDs fundamental principles, show how ATDD fits into the broader development process, highlight tips from Grtners extensive experience, and identify crucial pitfalls to avoid. Readers will learn to Master the thought processes associated with successful ATDD implementationUse ATDD with Cucumber to describe software in ways businesspeople can understand Test web pages using ATDD toolsBring ATDD to Java with the FitNesse wiki-based acceptance test framework Use examples more effectively in Behavior-Driven Development (BDD)Specify software collaboratively through innovative workshopsImplement more user-friendly and collaborative test automationTest more cleanly, listen to test results, and refactor tests for greater value If youre a tester, analyst, developer, or project manager, this book offers a concrete foundation for achieving real benefits with ATDD nowand it will help you reap even more value as you gain experience.		Grtner, Markus; Grtner, Markus						Excluded	Excluded	new_screen			2						
307	Behave	A serious gaming framework for decision support on hydrological hazards	With increasing population and human intervention on the natural environment, hazards are a growing threat, coming in many forms, including floods, droughts, soil erosion, and water pollution. A key approach to mitigate hydrological disaster risk at the community level is informed planning with decision support systems. The literature shows emerging efforts on multi-hazard decision support systems for hydrological disasters and demonstrates the need for an engaging, accessible, and collaborative serious game environment facilitating the relationship between the environment and communities. In this study, a web-based decision support tool (DST) was developed for hydrological multi-hazard analysis while employing gamification techniques to introduce a competitive element. The serious gaming environment provides functionalities for intuitive management, visualization, and analysis of geospatial, hydrological, and economic data to help stakeholders in the decision-making process regarding hydrological hazard preparedness and response. Major contributions of the presented DST include involving the community in environmental decision making by reducing the technical complexity required for analysis, increasing community awareness for the environmental and socio-economic consequences of hydrological hazards, and allowing stakeholders to discover and discuss potential trade-offs to hazardous scenarios considering the limitations in budget, regulations, and technicality. The paper describes the software design approaches and system architecture applied for a modular, secure, and scalable software as well as the framework's intuitive web-based user interfaces for real-time and collaborative data analysis and damage assessment. Finally, a case study was conducted to demonstrate the usability of DST in a formal setting and to measure user satisfaction with surveys.	Serious games, Multi-hazard tournament, Decision support systems, Hydrological data management and visualization, Web-based systems	Sermet, Yusuf; Demir, Ibrahim; Muste, Marian	Science of The Total Environment					Excluded	Excluded	new_screen			2						
308	Behave	Towards accountability driven development for machine learning systems	With rapid deployment of Machine Learning (ML) systems into diverse domains such as healthcare and autonomous driving, important questions regarding accountability in case of incidents resulting from ML errors remain largely unsolved. To improve accountability of ML systems, we introduce a framework called Accountability Driven Development (ADD). Our framework reuses Behaviour Driven Development (BDD) approach to describe testing scenarios and system behaviours in ML Systems’ development using natural language, guides and forces developers and intended users to actively record necessary accountability information in the design and implementation stages. In this paper, we illustrate how to transform accountability requirements to specific scenarios and provide syntax to describe them. The use of natural language allows non technical collaborators such as stakeholders and non ML domain experts deeply engaged in ML system development to provide more comprehensive evidence to support system’s accountability. This framework also attributes the responsibility to the whole project team including the intended users rather than putting all the accountability burden on ML engineers only. Moreover, this framework can be considered as a combination of both system test and acceptance test, thus making the development more efficient. We hope this work can attract more engineers to use our idea, which enables them to create more accountable ML systems. Copyright © 2021 for this paper by its authors.		Fung C.P., Pang W., Naja I., Markovic M., Edwards P.	CEUR Workshop Proceedings					Included	Included	new_screen			2						
309	Behave	Automated Acceptance Test Refactoring	With the increasing popularity of agile software development and Test-Driven-Development, also maintenance of acceptance test has become an important issue. In this paper, we describe a concept and a tool for automated acceptance test maintenance using a refactoring approach. Acceptance tests are user tests which are used to determine if a system satisfies acceptance criteria and to enable a customer to determine whether or not to accept the system. In agile development acceptance test are also used as a mean for specification, i.e. acceptance tests are written in advance to the production code (called Behavior-Driven-Development - BDD). In an agile project this poses three major challenges with respect to maintenance of acceptance tests: new requirements may cause changes in the acceptance criteria, which require the system under test to be adapted; when the system under test undergoes a major restructuring, even the acceptance test might have to be adapted; with the increasing acceptance test suite in an agile project the tests themselves may undergo a major reorganization. Having a large acceptance test base, doing these refactorings manually is error prone and causes a lot of effort. In this paper we present a concept and tool for executing automated refactoring for Fit acceptance tests, which significantly reduces the effort for test maintenance and makes them much less error prone.	acceptance test; automation; eclipse; maintenance; plug-in; refactoring	Borg, Rodrick; Kropp, Martin	Proceedings of the 4th Workshop on Refactoring Tools					Excluded	Excluded	new_screen			2						
310	Behave	Automated acceptance test refactoring	With the increasing popularity of agile software development and Test-Driven-Development, also maintenance of acceptance test has become an important issue. In this paper, we describe a concept and a tool for automated acceptance test maintenance using a refactoring approach. Acceptance tests are user tests which are used to determine if a system satisfies acceptance criteria and to enable a customer to determine whether or not to accept the system. In agile development acceptance test are also used as a mean for specification, i.e. acceptance tests are written in advance to the production code (called Behavior-Driven-Development - BDD). In an agile project this poses three major challenges with respect to maintenance of acceptance tests: new requirements may cause changes in the acceptance criteria, which require the system under test to be adapted; when the system under test undergoes a major restructuring, even the acceptance test might have to be adapted; with the increasing acceptance test suite in an agile project the tests themselves may undergo a major reorganization. Having a large acceptance test base, doing these refactorings manually is error prone and causes a lot of effort. In this paper we present a concept and tool for executing automated refactoring for Fit acceptance tests, which significantly reduces the effort for test maintenance and makes them much less error prone. Copyright 2011 ACM.		Borg R., Kropp M.	WRT 2011 - Proceedings of the 4th Workshop on Refactoring Tools, co-located with ICSE 2011					Excluded	Excluded	new_screen			2						
311	Behave	Building Applications with Scala	Write modern, scalable, and reactive applications with the power of ScalaAbout This BookDelves into the intricacies of functional reactive programming with ScalaExplores frameworks like Akka, Play and Slick used to develop efficient applications A step by step guide with plenty of examples showing practical implementation of essential concepts Who This Book Is ForIf you are a Java or JVM developer who wants to use Scala to build reactive functional applications for the JVM platform, then this book is for you. Prior knowledge of Java or functional programing would help. No Scala knowledge is required. What You Will Learn Use Akka to create a chat service for your appEquip yourself with the techniques and tools to build reports and build database persistence with Scala and Slick Develop a customer-facing Rest API that makes use of Scala and SprayMake use of the Scala web development principles and scale up the architecture of your applicationGet familiar with the core principles and concepts of Functional Programming Use the Play framework to create models, controllers, and views Develop reactive backing frameworks by writing code with RxScala Discover what proper testing entails with Scala using behavior-driven development In DetailScala is known for incorporating both object-oriented and functional programming into a concise and extremely powerful package. However, creating an app in Scala can get a little tricky because of the complexity the language has. This book will help you dive straight into app development by creating a real, reactive, and functional application. We will provide you with practical examples and instructions using a hands-on approach that will give you a firm grounding in reactive functional principles. The book will take you through all the fundamentals of app development within Scala as you build an application piece by piece. We've made sure to incorporate everything you need from setting up to building reports and scaling architecture. This book also covers the most useful tools available in the Scala ecosystem, such as Slick, Play, and Akka, and a whole lot more. It will help you unlock the secrets of building your own up-to-date Scala application while maximizing performance and scalability. Style and approach This book takes a step-by-step approach to app development with Scala. It will place special emphasis on functional language. It will teach you the core benefits of Scala and the fundamentals of functional programming by developing a robust application.		Pacheco, Diego						Excluded	Excluded	new_screen			2						
312	Behave	Documentation by example	Writing documentation can be fun and rewarding, but keeping up with an ever-changing system can take a toll on that joy. The documentation tends to get either expensive (duplication-intense), outdated or non-existing. This demonstration will present an open source tool that addresses these shortcomings by extending the BDD[1] approach to provide rich and human readable documents automatically from a JUnit[2] test suite. You'll learn how to include snippets, run-time data and more in your documents, all this with minimal effort and intrusion. This approach is suitable both for APIs and GUIs, as will be shown. © 2009 Springer Berlin Heidelberg.		Brolund D.	Lecture Notes in Business Information Processing					Included	Included	new_screen			2						
313	Behave	Discovery: Explore Behaviour Using Examples (Volume 1)	Written by the creator of SpecFlow and the author of The Cucumber for Java Book, this book provides inside information on how to get the most out of the discovery phase of Behaviour Driven Development (BDD). This practical guide demonstrates good collaboration techniques, illustrated by concrete examples. This book is written for everyone involved in the specification and delivery of software (including product owners, business analysts, developers, and testers). The book starts by explaining the reasons BDD exists in the first place and describes techniques for getting the most out of collaboration between business and delivery team members. This is the first in the BDD Books series that will guide you through the entire development process, including specific technical practices needed to successfully drive development using collaboratively-authored specifications and living documentation.		Nagy, Gaspar; Rose, Seb						Excluded	Excluded	new_screen			2						
314	Behave	The RSpec Book: Behaviour Driven Development with Rspec, Cucumber, and Friends	"You'll get started right away with RSpec 2 and Cucumber by developing a simple game, using Cucumber to express high-level requirements in language your customer understands, and RSpec to express more granular requirements that focus on the behavior of individual objects in the system. You'll learn how to use test doubles (mocks and stubs) to control the environment and focus the RSpec examples on one object at a time, and how to customize RSpec to ""speak"" in the language of your domain. You'll develop Rails 3 applications and use companion tools such as Webrat and Selenium to express requirements for web applications both in memory and in the browser. And you'll learn to specify Rails views, controllers, and models, each in complete isolation from the other. Whether you're developing applications, frameworks, or the libraries that power them, The RSpec Book will help you write better code, better tests, and deliver better software to happier users."		Chelimsky, David; Astels, Dave; Helmkamp, Bryan; North, Dan; Dennis, Zach; Hellesoy, Aslak						Excluded	Excluded	new_screen			2						
315	Behave	The Cucumber Book: Behaviour-Driven Development for Testers and Developers	Your customers want rock-solid, bug-free software that does exactly what they expect it to do. Yet they can't always articulate their ideas clearly enough for you to turn them into code. The Cucumber Book dives straight into the core of the problem: communication between people. Cucumber saves the day; it's a testing, communication, and requirements tool - all rolled into one. We'll show you how to express your customers' wild ideas as a set of clear, executable specifications that everyone on the team can read. You'll learn how to feed those examples into Cucumber and let it guide your development. You'll build just the right code to keep your customers happy, and not a line more. The first part of the book teaches you how to use the core features of Cucumber. You'll learn how to use Cucumber's Gherkin DSL to describe– in plain language - the behavior your customers want from the system. You'll learn how to write Ruby code that interprets those plain language specifications and checks them against your application. In Part 2, you'll consolidate the knowledge you just gained with a worked example. Although it was born in the Ruby community, you can use Cucumber to test almost any system, from a simple shell script or a Perl script, to enterprise PHP or a Java web application. In Part 3, you'll find a selection of recipes for some of the most common situations you'll encounter using Cucumber in the wild. You'll learn how to test Ajax-heavy web applications with Capybara and Selenium, REST web services, Ruby on Rails applications, command-line applications, legacy applications and lots more! Written by the creator of Cucumber and one of its most experienced users and contributors, The Cucumber Book is an authoritative guide that will give you and your team all the knowledge you need to start using Cucumber with confidence. What You Need: Windows, Mac OS X (with XCode) or Linux Ruby 1.9.2 and upwards		Wynne, Matt; Hellesoy, Aslak						Excluded	Excluded	new_screen			2						
316	Behave	A Basic Spring Boot Application	http://link.springer.com/chapter/10.1007/978-1-4842-6131-6_3	specific testing technologies/languages	Moisés Macero García						Excluded	Excluded	new_screen			2						
317	Behave	A Beginner's Guide to Scala, Object Orientation and Functional Programming		specific testing technologies/languages	Dr. John Hunt						Excluded	Excluded	new_screen			2						
318	Behave	A Circumstantial Methodological Analysis of Recent Studies on NLP-driven Test Automation Approaches	http://link.springer.com/chapter/10.1007/978-981-33-6081-5_14	NLP in testing	Atulya GuptaRajendra Prasad Mahapatra						Excluded	Excluded	new_screen			2						
319	Behave	A distributable event-oriented architecture for activity recognition in smart homes	http://link.springer.com/article/10.1007/s40860-020-00125-y		Cédric DemongivertKévin BouchardSébastien GabouryBruno BouchardMaxime LussierMaxime ParenteauCatherine LalibertéMélanie CoutureNathalie BierSylvain Giroux						Excluded	Excluded	new_screen			2						
320	Behave	A domain-specific language to design false data injection tests for air traffic control systems	http://link.springer.com/article/10.1007/s10009-021-00604-4		Alexandre VernotteAymeric CretinBruno LegeardFabien Peureux						Excluded	Excluded	new_screen			2						
321	Behave	A Dynamic System Model Using Agile Method Techniques Applied to Geomatics	http://link.springer.com/chapter/10.1007/978-3-030-33229-7_7		René Rodríguez ZamoraÁlvaro Peraza GarzónIliana Amabely Silva Hernández						Excluded	Excluded	new_screen			2						
322	Behave	A Four-Leaf Clover Shape Methodology for Prosumer Service Developments	http://link.springer.com/chapter/10.1007/978-3-319-13102-3_78		Diego MartínRamon AlcarriaAlvaro Sánchez-PicotTomás RoblesDiego Sánchez de Rivera						Excluded	Excluded	new_screen			2						
323	Behave	A Lightweight Semi-automated Acceptance Test-Driven Development Approach for Web Applications	http://link.springer.com/chapter/10.1007/978-3-319-38791-8_55		Diego ClerissiMaurizio LeottaGianna ReggioFilippo Ricca						Excluded	Excluded	new_screen			2						
324	Behave	A Literature Review on Story Test Driven Development	http://link.springer.com/chapter/10.1007/978-3-642-13054-0_20		Shelly ParkFrank Maurer						Excluded	Excluded	new_screen			2						
325	Behave	A New Ontology-Based Approach for Construction of Domain Model	http://link.springer.com/chapter/10.1007/978-3-319-54472-4_8		Bogumiła HnatkowskaZbigniew HuzarLech TuzinkiewiczIwona Dubielewicz						Excluded	Excluded	new_screen			2						
326	Behave	A scalable Cloud-based system for data-intensive spatial analysis	http://link.springer.com/article/10.1007/s10009-015-0398-6		R. O. SinnottW. Voorsluys						Excluded	Excluded	new_screen			2						
327	Behave	A Survey on Agile Practices and Challenges of a Global Software Development Team	http://link.springer.com/chapter/10.1007/978-3-030-36701-5_11		Tatiane LautertAdolfo Gustavo Serra Seca NetoNádia P. Kozievitch						Excluded	Excluded	new_screen			2						
328	Behave	A Systematic Approach to Automatically Derive Test Cases from Use Cases Specified in Restricted Natural Languages	http://link.springer.com/chapter/10.1007/978-3-319-11743-0_10		Man ZhangTao YueShaukat AliHuihui ZhangJi Wu						Excluded	Excluded	new_screen			2						
329	Behave	A Taxonomy on Continuous Integration and Deployment Tools and Frameworks	http://link.springer.com/chapter/10.1007/978-3-030-63329-5_22		Patricia Ortegon CanoAyrton Mondragon MejiaSilvana De Gyves AvilaGloria Eva Zagal DominguezIsmael Solis MorenoArianne Navarro Lepe						Excluded	Excluded	new_screen			2						
330	Behave	A Test Specification Language for Information Systems Based on Data Entities, Use Cases and State Machines	http://link.springer.com/chapter/10.1007/978-3-030-11030-7_20		Alberto Rodrigues da SilvaAna C. R. PaivaValter E. R. da Silva						Excluded	Excluded	new_screen			2						
331	Behave	A Textual Domain Specific Language for User Interface Modelling	http://link.springer.com/chapter/10.1007/978-1-4614-3558-7_84		Mart Karu						Excluded	Excluded	new_screen			2						
332	Behave	A Very Brief History of Test-Driven Development	http://link.springer.com/chapter/10.1007/978-1-4842-6972-5_1	General books on testing	Juntao Qiu						Excluded	Excluded	new_screen			2						
333	Behave	Acceptance Test Driven Development	http://link.springer.com/chapter/10.1007/978-1-4842-3832-5_16		Arnon Axelrod						Excluded	Excluded	new_screen			2						
334	Behave	Acceptance tests for validating ARIA requirements in widgets	http://link.springer.com/article/10.1007/s10209-015-0437-9		Willian Massami WatanabeRenata P. M. FortesAna Luiza Dias						Excluded	Excluded	new_screen			2						
335	Behave	Adopting Agile Software Development Combined with User-Centered Design and Lean Startup: A Systematic Literature Review on Maturity Models	http://link.springer.com/chapter/10.1007/978-3-030-75418-1_24		Maximilian ZorzettiCassiano MorallesLarissa SalernoEliana PereiraSabrina MarczakRicardo Bastos						Excluded	Excluded	new_screen			2						
336	Behave	Advanced Guide to Python 3 Programming	http://link.springer.com/book/10.1007/978-3-030-25943-3		Dr. John Hunt						Excluded	Excluded	new_screen			2						
337	Behave	Advances in infrastructures and tools for multiagent systems	http://link.springer.com/article/10.1007/s10796-014-9493-6		Juan M. AlberolaVicent BottiJose M. Such						Excluded	Excluded	new_screen			2						
338	Behave	Agile Android	http://link.springer.com/chapter/10.1007/978-1-4302-5858-2_4		Godfrey NolanOnur CinarDavid Truxall						Excluded	Excluded	new_screen			2						
339	Behave	Agile Practices in Azure DevOps and TFS	http://link.springer.com/chapter/10.1007/978-1-4842-4483-8_6		Joachim Rossberg						Excluded	Excluded	new_screen			2						
340	Behave	Agile Practices, Collaboration and Experience	https://link.springer.com/chapter/10.1007/978-3-319-49094-6_28		Martin KroppAndreas MeierRobert Biddle						Excluded	Excluded	new_screen			2						
341	Behave	Agile Test Automation			Manfred BaumgartnerMartin KlonkChristian MastnakHelmut PichlerRichard SeidlSiegfried Tanczos						Excluded	Excluded	new_screen			2						
342	Behave	Agile Testing	http://link.springer.com/book/10.1007/978-3-030-73209-7		Manfred BaumgartnerMartin KlonkChristian MastnakHelmut PichlerRichard SeidlSiegfried Tanczos						Excluded	Excluded	new_screen			2						
343	Behave	An Agile Approach to Requirement Specification	http://link.springer.com/chapter/10.1007/978-3-540-73101-6_35		Tom J. Bang						Excluded	Excluded	new_screen			2						
344	Behave	An architecture governance approach for Agile development by tailoring the Spotify model	http://link.springer.com/article/10.1007/s00146-021-01240-x		Abdallah SalamehJulian M. Bass						Excluded	Excluded	new_screen			2						
345	Behave	An Automated Approach for Acceptance Web Test Case Modeling and Executing	http://link.springer.com/chapter/10.1007/978-3-642-13054-0_12		Felipe M. BessonDelano M. BederMarcos L. Chaim						Excluded	Excluded	new_screen			2						
346	Behave	An autonomous performance testing framework using self-adaptive fuzzy reinforcement learning	http://link.springer.com/article/10.1007/s11219-020-09532-z		Mahshid Helali MoghadamMehrdad SaadatmandMarkus BorgMarkus BohlinBjörn Lisper						Excluded	Excluded	new_screen			2						
347	Behave	An Empirical Study on the Adoption of Agile Software Development in Public Organizations	https://link.springer.com/chapter/10.1007/978-3-319-55907-0_1		Isaque VacariRafael Prikladnicki						Excluded	Excluded	new_screen			2						
348	Behave	An Exploratory Study on Applying a Scrum Development Process for Safety-Critical Systems	http://link.springer.com/chapter/10.1007/978-3-319-69926-4_23		Yang WangJasmin RamadaniStefan Wagner						Excluded	Excluded	new_screen			2						
349	Behave	An Overview of Requirements Evolution	http://link.springer.com/chapter/10.1007/978-3-642-45398-4_1		Neil ErnstAlexander BorgidaIvan J. JuretaJohn Mylopoulos						Excluded	Excluded	new_screen			2						
350	Behave	AngularJS	http://link.springer.com/chapter/10.1007/978-1-4842-2044-3_5		Elad Elrom						Excluded	Excluded	new_screen			2						
351	Behave	Apogee: Application Ontology Generation with Size Optimization	http://link.springer.com/chapter/10.1007/978-3-319-25840-9_29		Iaakov ExmanDanil Iskusnov						Excluded	Excluded	new_screen			2						
352	Behave	Appendix	http://link.springer.com/chapter/10.1007/978-1-4842-2526-4_10		Sumanta Boral						Excluded	Excluded	new_screen			2						
353	Behave	Applying TDD and BDD Techniques	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_12		Abhishek Mishra						Excluded	Excluded	new_screen			2						
354	Behave	Applying TDD to Collection View Controllers	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_6		Abhishek Mishra						Excluded	Excluded	new_screen			2						
355	Behave	Applying TDD to the Model	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_4		Abhishek Mishra						Excluded	Excluded	new_screen			2						
356	Behave	Applying TDD to View Controllers			Abhishek Mishra						Excluded	Excluded	new_screen			2						
357	Behave	Approaches to Business Analysis in Scrum at StepStone—Case Study	http://link.springer.com/chapter/10.1007/978-3-030-34706-2_11		Piotr Forowicz						Excluded	Excluded	new_screen			2						
358	Behave	Augmented System Verification Using Automated Testing	http://link.springer.com/chapter/10.1007/978-3-319-60366-7_7		Amir SchurMike Williams						Included	Included	new_screen			2						
359	Behave	AutoJet: Web Application Automation Tool	http://link.springer.com/chapter/10.1007/978-981-13-2348-5_3		Sheetika KapoorKalpna Sagar						Excluded	Excluded	new_screen			2						
360	Behave	Automated Acceptance Tests as Software Requirements: An Experiment to Compare the Applicability of Fit Tables and Gherkin Language	http://link.springer.com/chapter/10.1007/978-3-319-91602-6_7		Ernani César dos SantosPatrícia Vilain						Included	Included	new_screen			2						
361	Behave	Automated Integration Testing	http://link.springer.com/chapter/10.1007/978-1-4302-2944-5_11		Matt StephensDoug Rosenberg						Excluded	Excluded	new_screen			2						
362	Behave	Automated Testing	http://link.springer.com/chapter/10.1007/978-1-4302-6790-4_9		Steve Fenton						Excluded	Excluded	new_screen			2						
363	Behave	Automating Expert-Defined Tests: A Suitable Approach for the Medical Device Industry?			David ConnollyFergal Mc CafferyFrank Keenan						Excluded	Excluded	new_screen			2						
364	Behave	Basic Concepts	https://link.springer.com/chapter/10.1007/978-1-4842-6131-6_2		Moisés Macero García						Excluded	Excluded	new_screen			2						
365	Behave	Behavior-Driven Development	http://link.springer.com/chapter/10.1007/978-1-4842-6972-5_10		Juntao Qiu						Excluded	Excluded	new_screen			2						
366	Behave	Behaviour-Driven Development			Prof. Dr. Stephan Kleuker						Excluded	Excluded	new_screen			2						
367	Behave	Best Practices for OutSystems Development and Its Influence on Test Automation	http://link.springer.com/chapter/10.1007/978-3-030-72654-6_9		Joana SalgueiroFernando RibeiroJosé Metrôlho						Excluded	Excluded	new_screen			2						
368	Behave	Blockchain-Based Distributed Marketplace	http://link.springer.com/chapter/10.1007/978-3-030-04849-5_17		Oliver R. KabiVirginia N. L. Franqueira						Excluded	Excluded	new_screen			2						
369	Behave	BPMN-Based Model-Driven Testing of Service-Based Processes	http://link.springer.com/chapter/10.1007/978-3-319-59466-8_8		Daniel LübkeTammo van Lessen						Excluded	Excluded	new_screen			2						
370	Behave	Bridging Enterprise and Software Engineering Through an User-Centered Design Perspective	http://link.springer.com/chapter/10.1007/978-3-319-48743-4_28		Pedro ValenteThiago SilvaMarco WincklerNuno Nunes						Excluded	Excluded	new_screen			2						
371	Behave	Building Software the Correct Way	http://link.springer.com/chapter/10.1007/978-1-4842-3015-2_1		Shekhar GulatiRahul Sharma						Excluded	Excluded	new_screen			2						
372	Behave	Business Processes	http://link.springer.com/chapter/10.1007/978-1-4842-3832-5_5		Arnon Axelrod						Excluded	Excluded	new_screen			2						
373	Behave	Cassandra on Docker, Apache Spark, and the Cassandra Cluster Manager			Sam R. Alapati						Excluded	Excluded	new_screen			2						
374	Behave	Challenges of CE	http://link.springer.com/chapter/10.1007/978-3-319-13776-6_28		Wim J. C. VerhagenJosip StjepandićNel Wognum						Excluded	Excluded	new_screen			2						
375	Behave	Chapter 10 - Development			Lundahl, David						Excluded	Excluded	new_screen			2						
376	Behave	Chasing Mutants	http://link.springer.com/chapter/10.1007/978-3-030-29509-7_12		Adam Leon Smith						Excluded	Excluded	new_screen			2						
377	Behave	Clean C++20	http://link.springer.com/book/10.1007/978-1-4842-5949-8		Stephan Roth						Excluded	Excluded	new_screen			2						
378	Behave	Cloud and Services Testing Applied in Manufacturing			F. AlvesC. CoutinhoR. Peña-OrtizX. XuA. NietoJ. AholaL. SaariA. Katasonov						Excluded	Excluded	new_screen			2						
379	Behave	Code Organization	http://link.springer.com/chapter/10.1007/978-1-4842-3249-1_2		Steve Fenton						Excluded	Excluded	new_screen			2						
380	Behave	Comparison of national clinical practice guidelines and recommendations on vaccination of adult patients with autoimmune rheumatic diseases	http://link.springer.com/article/10.1007/s00296-013-2907-9		Despoina PapadopoulouNikolaos V. Sipsas						Excluded	Excluded	new_screen			2						
381	Behave	Completeness-Driven Development	http://link.springer.com/chapter/10.1007/978-3-642-33654-6_3		Rolf DrechslerMelanie DiepenbeckDaniel GroßeUlrich KühneHoang M. LeJulia SeiterMathias SoekenRobert Wille						Excluded	Excluded	new_screen			2						
382	Behave	Component architecture of model-based testing environment	http://link.springer.com/article/10.1134/S036176881005004X		V. V. Kuliamin						Excluded	Excluded	new_screen			2						
383	Behave	Conceptual Design and Controller Testing	http://link.springer.com/chapter/10.1007/978-1-4302-2944-5_6		Matt StephensDoug Rosenberg						Excluded	Excluded	new_screen			2						
384	Behave	Contents				Procedia Computer Science					Excluded	Excluded	new_screen			2						
385	Behave	Continuous Architecting with Microservices and DevOps: A Systematic Mapping Study	http://link.springer.com/chapter/10.1007/978-3-030-29193-8_7		Davide TaibiValentina LenarduzziClaus Pahl						Excluded	Excluded	new_screen			2						
386	Behave	Continuous Integration	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_9		Abhishek Mishra						Excluded	Excluded	new_screen			2						
387	Behave	Controllers and Actions	https://link.springer.com/chapter/10.1007/978-1-4302-2887-5_9		Steven Sanderson						Excluded	Excluded	new_screen			2						
388	Behave	Creating Automation Frameworks Using Appium	http://link.springer.com/chapter/10.1007/978-1-4842-2418-2_5		Shankar Garg	Keyword BDD auto inserted					Excluded	Excluded	new_screen			2						
389	Behave	Cross-species protein sequence and gene structure prediction with fine-tuned Webscipio 2.0 and Scipio	http://link.springer.com/article/10.1186/1756-0500-4-265		Klas HatjeOliver KellerBjörn HammesfahrHolger PillmannStephan WaackMartin Kollmar						Excluded	Excluded	new_screen			2						
390	Behave	Data-Driven Usability Test Scenario Creation	http://link.springer.com/chapter/10.1007/978-3-030-05909-5_6		Maikel L. van EckElse MarkslagNatalia SidorovaAngelique Brosens-KesselsWil M. P. van der Aalst						Excluded	Excluded	new_screen			2						
391	Behave	Deployment Considerations	http://link.springer.com/chapter/10.1007/978-1-4842-0160-2_10		Andrew Grant						Excluded	Excluded	new_screen			2						
392	Behave	Description and Analysis of Design Decisions: An Ontological Approach	http://link.springer.com/chapter/10.1007/978-3-030-00940-3_13		Yordani Cruz SeguraNemury Silega MartínezAilía Parra FernándezOiner Gómez Baryolo						Excluded	Excluded	new_screen			2						
393	Behave	Design	http://link.springer.com/chapter/10.1007/978-1-4842-4303-9_3		Shailesh Kumar ShivakumarSourabhh Sethii						Excluded	Excluded	new_screen			2						
394	Behave	Design for the Decentralized World: Democratization of Blockchain-Based Software Design			Vladislav GladyshevQiong Wu						Excluded	Excluded	new_screen			2						
395	Behave	Develop	https://link.springer.com/chapter/10.1007/978-1-4842-1067-3_6		Tathagat Varma						Excluded	Excluded	new_screen			2						
396	Behave	Developing a Spiral Curriculum for Teaching Agile at the National Software Academy	https://link.springer.com/chapter/10.1007/978-981-13-2751-3_15		James OsborneWendy IvinsCarl Jones						Excluded	Excluded	new_screen			2						
397	Behave	Directed Multi-target Search Based Unit Tests Generation	http://link.springer.com/chapter/10.1007/978-3-030-30275-7_8		Greta RudžionienėŠarūnas PackevičiusEduardas Bareiša						Excluded	Excluded	new_screen			2						
398	Behave	Documentation, Error Handling, Debugging, and Testing	http://link.springer.com/chapter/10.1007/978-1-4842-6324-2_8		Peter Cooper						Excluded	Excluded	new_screen			2						
399	Behave	Documenting, Testing, and Verifying	http://link.springer.com/chapter/10.1007/978-1-4842-4480-7_15		Alejandro Serrano Mena						Excluded	Excluded	new_screen			2						
400	Behave	Domain Modeling Based on Requirements Specification and Ontology	http://link.springer.com/chapter/10.1007/978-3-319-43606-7_3		Iwona DubielewiczBogumiła HnatkowskaZbigniew HuzarLech Tuzinkiewicz						Excluded	Excluded	new_screen			2						
401	Behave	Domain V: Adaptive Planning			Sumanta Boral						Excluded	Excluded	new_screen			2						
402	Behave	Domain VI: Problem Detection and Resolution	http://link.springer.com/chapter/10.1007/978-1-4842-2526-4_7		Sumanta Boral						Excluded	Excluded	new_screen			2						
403	Behave	Editorial to the theme section on model-based testing			Mike PapadakisShaukat AliGilles Perrouin						Excluded	Excluded	new_screen			2						
404	Behave	Effective Testing	https://link.springer.com/chapter/10.1007/978-1-4842-0268-5_7		Paul FisherBrian D. Murphy						Excluded	Excluded	new_screen			2						
405	Behave	Efficient and Flexible Test Automation in Production Systems Engineering			Dietmar WinklerKristof MeixnerPetr Novak	Keyword -- Behavior Driven Test					Included	Included	new_screen			2						
406	Behave	Engineering Multi-agent Systems with Statecharts	http://link.springer.com/article/10.1007/s42979-021-00706-5		Nikolaos I. Spanoudakis						Excluded	Excluded	new_screen			2						
407	Behave	Enterprise Information Systems			Prof. Dr. Joaquim FilipeMichał ŚmiałekAlexander BrodskySlimane Hammoudi						Excluded	Excluded	new_screen			2						
408	Behave	Espresso	http://link.springer.com/chapter/10.1007/978-1-4842-9701-8_5		Godfrey Nolan						Excluded	Excluded	new_screen			2						
409	Behave	Every Product Owner Needs Four Things	http://link.springer.com/chapter/10.1007/978-1-4842-5168-3_5		Allan Kelly						Excluded	Excluded	new_screen			2						
410	Behave	Example-driven modeling: on effects of using examples on structural model comprehension, what makes them useful, and how to create them	http://link.springer.com/article/10.1007/s10270-017-0652-3		Dina ZayanAtrisha SarkarMichał AntkiewiczRita Suzana Pitangueira MacielKrzysztof Czarnecki						Excluded	Excluded	new_screen			2						
411	Behave	Extending, Unit Testing, and Packaging	https://link.springer.com/chapter/10.1007/978-1-4302-6074-5_10		Prabhu Sunderaraman						Excluded	Excluded	new_screen			2						
412	Behave	eXtreme Programming	http://link.springer.com/chapter/10.1007/978-1-4302-3534-7_3		Jerrel BlankenshipMatthew BussaScott Millett						Excluded	Excluded	new_screen			2						
413	Behave	Flipping the Run/Build Ratio: The Business Case for Software Craftsmanship	http://link.springer.com/chapter/10.1007/978-3-319-54087-0_9		Daryl KulakHong Li						Excluded	Excluded	new_screen			2						
414	Behave	Formal Specification Level	http://link.springer.com/chapter/10.1007/978-3-319-01418-0_3		Rolf DrechslerMathias SoekenRobert Wille						Excluded	Excluded	new_screen			2						
415	Behave	Formal Testing from Natural Language in an Industrial Context	http://link.springer.com/chapter/10.1007/978-3-319-49815-7_2		Augusto SampaioFilipe Arruda						Excluded	Excluded	new_screen			2						
416	Behave	FRAGGLE: A FRamework for AGile Gamification of Learning Experiences			Alberto MoraPanagiotis ZahariasCarina GonzálezJoan Arnedo-Moreno	Framework inspired by BDD					Excluded	Excluded	new_screen			2						
417	Behave	Fragment-based spreadsheet debugging	http://link.springer.com/article/10.1007/s10515-018-0250-9		Dietmar JannachThomas SchmitzBirgit HoferKonstantin SchekotihinPatrick KochFranz Wotawa						Excluded	Excluded	new_screen			2						
418	Behave	Framework Options and Design Pattern	http://link.springer.com/chapter/10.1007/978-1-4842-7289-3_9		Shashank Shukla						Excluded	Excluded	new_screen			2						
419	Behave	From COBOL to Business Rules—Extracting Business Rules from Legacy Code	http://link.springer.com/chapter/10.1007/978-3-030-26574-8_14		Harry M. SneedChris Verhoef						Excluded	Excluded	new_screen			2						
420	Behave	From Requirements to Automated Acceptance Tests with the RSL Language	http://link.springer.com/chapter/10.1007/978-3-030-40223-5_3		Ana C. R. PaivaDaniel MacielAlberto Rodrigues da Silva						Excluded	Excluded	new_screen			2						
421	Behave	From Requirements to Verifiable Executable Models Using Rebeca			Marjan SirjaniLuciana ProvenzanoSara Abbaspour AsadollahMahshid Helali Moghadam						Excluded	Excluded	new_screen			2						
422	Behave	Fusing Modeling and Programming into Language-Oriented Programming	http://link.springer.com/chapter/10.1007/978-3-030-03418-4_19		Markus Voelter						Excluded	Excluded	new_screen			2						
423	Behave	Gamification: a systematic review of design frameworks	http://link.springer.com/article/10.1007/s12528-017-9150-4		Alberto MoraDaniel RieraCarina GonzálezJoan Arnedo-Moreno						Excluded	Excluded	new_screen			2						
424	Behave	Getting Coaching That Really Helps	http://link.springer.com/chapter/10.1007/978-3-319-54087-0_13		Daryl KulakHong Li						Excluded	Excluded	new_screen			2						
425	Behave	Getting Started	http://link.springer.com/chapter/10.1007/978-1-4842-7289-3_1		Shashank Shukla						Excluded	Excluded	new_screen			2						
426	Behave	Getting Started with Selenium and Visual Studio			Chaminda ChandrasekaraPushpa Herath						Excluded	Excluded	new_screen			2						
427	Behave	Getting Started with Test-Driven Development	http://link.springer.com/chapter/10.1007/978-1-4842-7002-8_3		Gio Lodi						Excluded	Excluded	new_screen			2						
428	Behave	Groovy Awesomeness	http://link.springer.com/chapter/10.1007/978-1-4842-2117-4_11		Adam L. Davis						Excluded	Excluded	new_screen			2						
429	Behave	Hamcrest vs AssertJ: An Empirical Assessment of Tester Productivity	http://link.springer.com/chapter/10.1007/978-3-030-29238-6_12		Maurizio LeottaMaura CerioliDario OlianasFilippo Ricca						Excluded	Excluded	new_screen			2						
430	Behave	How Do Software Architects Specify and Validate Quality Requirements?			Andrea CaraccioloMircea Filip LunguOscar Nierstrasz						Excluded	Excluded	new_screen			2						
431	Behave	ICITPM: Integrity Validation of Software in Iterative Continuous Integration Through the Use of Trusted Platform Module (TPM)	https://link.springer.com/chapter/10.1007/978-3-030-66504-3_9		Antonio MuñozAristeidis FaraoJordy Ryan Casas CorreiaChristos Xenakis						Excluded	Excluded	new_screen			2						
432	Behave	Implement Tests in Our Daily Work Routine	https://link.springer.com/chapter/10.1007/978-1-4842-6382-2_10		Avi Tsadok						Excluded	Excluded	new_screen			2						
433	Behave	In the right order of brush strokes: a sketch of a software philosophy retrospective	http://link.springer.com/article/10.1186/2193-1801-3-186		Evgeny Pyshkin						Excluded	Excluded	new_screen			2						
434	Behave	Incident Management Adaption	http://link.springer.com/chapter/10.1007/978-1-4842-3976-6_7		Abhinav Krishna Kaiser						Excluded	Excluded	new_screen			2						
435	Behave	Index									Excluded	Excluded	new_screen			2						
436	Behave	Industry practices and challenges for the evolvability assurance of microservices	https://link.springer.com/article/10.1007/s10664-021-09999-9		Justus BognerJonas FritzschStefan WagnerAlfred Zimmermann						Excluded	Excluded	new_screen			2						
437	Behave	InstAL: An Institutional Action Language	http://link.springer.com/chapter/10.1007/978-3-319-33570-4_6		Julian PadgetEmad ElDeen ElakehalTingting LiMarina De Vos						Excluded	Excluded	new_screen			2						
438	Behave	Installing Quick	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_11		Abhishek Mishra						Excluded	Excluded	new_screen			2						
439	Behave	Integrating Quality Tooling into the Chef Development Life Cycle	https://link.springer.com/chapter/10.1007/978-1-4842-1476-3_6		Stuart Preston						Excluded	Excluded	new_screen			2						
440	Behave	Integration of Security Standards in DevOps Pipelines: An Industry Case Study	http://link.springer.com/chapter/10.1007/978-3-030-64148-1_27		Fabiola MoyónRafael SoaresMaria Pinto-AlbuquerqueDaniel MendezKristian Beckers						Excluded	Excluded	new_screen			2						
441	Behave	Inter-organizational Co-development with Scrum: Experiences and Lessons Learned from a Distributed Corporate Development Environment	http://link.springer.com/chapter/10.1007/978-3-642-38314-4_11		Raoul VallonStefan StroblMario BernhartThomas Grechenig						Excluded	Excluded	new_screen			2						
442	Behave	Interpreter Pattern	http://link.springer.com/chapter/10.1007/978-1-4842-2680-3_12		Wessel Badenhorst	These keywords were added by machine and not by the authors. This process is experimental and the keywords may be updated as the learning algorithm improves.					Excluded	Excluded	new_screen			2						
443	Behave	Interviews and Case Studies	http://link.springer.com/chapter/10.1007/978-1-4842-4388-6_9		Dave HarrisonKnox Lively						Excluded	Excluded	new_screen			2						
444	Behave	Introducing a New Agile Development for Web Applications Using a Groupware as Example	http://link.springer.com/chapter/10.1007/978-3-642-22247-4_13		Vinicius PereiraAntonio Francisco do Prado						Excluded	Excluded	new_screen			2						
445	Behave	Introduction to Behavior-Driven Development	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_10		Abhishek Mishra						Excluded	Excluded	new_screen			2						
446	Behave	Introduction to Cucumber	http://link.springer.com/chapter/10.1007/978-1-4842-6141-5_6		Panos Matsinopoulos						Excluded	Excluded	new_screen			2						
447	Behave	Introduction to DevOps	http://link.springer.com/chapter/10.1007/978-1-4842-3976-6_1		Abhinav Krishna Kaiser						Excluded	Excluded	new_screen			2						
448	Behave	Introduction to RSpec	http://link.springer.com/chapter/10.1007/978-1-4842-6141-5_4		Panos Matsinopoulos						Excluded	Excluded	new_screen			2						
449	Behave	Introduction to Security and Quality Improvement in Complex Cyber-Physical Systems Engineering	http://link.springer.com/chapter/10.1007/978-3-030-25312-7_1		Stefan BifflMatthias EckhartArndt LüderEdgar Weippl						Excluded	Excluded	new_screen			2						
450	Behave	Introduction to Test-Driven Development	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_1		Abhishek Mishra						Excluded	Excluded	new_screen			2						
451	Behave	Introduction to Testing	http://link.springer.com/chapter/10.1007/978-1-4302-1040-5_10		John Hunt						Excluded	Excluded	new_screen			2						
452	Behave	Introduction to Testing with Rspec	http://link.springer.com/book/10.1007/978-1-4842-2689-6								Excluded	Excluded	new_screen			2						
453	Behave	iOS Code Testing	https://link.springer.com/book/10.1007/978-1-4842-2689-6		Abhishek Mishra						Excluded	Excluded	new_screen			2						
454	Behave	Iterative and Scenario-Based Requirements Specification in a System of Systems Context	http://link.springer.com/chapter/10.1007/978-3-030-73128-1_12		Carsten WiecherJoel GreenyerCarsten WolffHarald AnackerRoman Dumitrescu						Included	Included	new_screen			2						
455	Behave	JavaScript Unit Testing	https://link.springer.com/chapter/10.1007/978-1-4302-6674-7_10		Gil FinkIdo Flatow						Excluded	Excluded	new_screen			2						
456	Behave	KODEGEN: A Code Generation and Testing Tool Using Runnable Knowledge	http://link.springer.com/chapter/10.1007/978-3-662-46549-3_17		Iaakov ExmanAnton LitovkaReuven Yagel						Excluded	Excluded	new_screen			2						
457	Behave	Languages, Frameworks, Libraries, and Tools	http://link.springer.com/chapter/10.1007/978-1-4842-3775-5_2		Fu Cheng						Excluded	Excluded	new_screen			2						
458	Behave	Lean R&D: An Agile Research and Development Approach for Digital Transformation			Marcos KalinowskiHélio LopesAlex Furtado TeixeiraGabriel da Silva CardosoAndré KuramotoBruno ItagybaSolon Tarso BatistaJuliana Alves PereiraThuener SilvaJorge Alam WarrakMarcelo da CostaMarinho FischerCristiane SalgadoBianca TeixeiraJacques ChuekeBruna Ferreira						Excluded	Excluded	new_screen			2						
459	Behave	Lean Software Development – What Exactly Are We Talking About?	http://link.springer.com/book/10.1007/978-3-030-76020-5		Oisín CawleyXiaofeng WangIta Richardson						Excluded	Excluded	new_screen			2						
460	Behave	Logic, Computation and Rigorous Methods			Alexander RaschkeElvinia RiccobeneProf. Klaus-Dieter Schewe						Excluded	Excluded	new_screen			2						
461	Behave	Making It Better	http://link.springer.com/chapter/10.1007/978-1-4842-5473-8_12		Andrew Davis						Excluded	Excluded	new_screen			2						
462	Behave	Measuring Test Case Similarity to Support Test Suite Understanding	http://link.springer.com/chapter/10.1007/978-3-658-25087-4_6		Michaela GreilerArie van DeursenAndy Zaidman						Excluded	Excluded	new_screen			2						
463	Behave	Meshing agile and plan-driven development in safety-critical software: a case study	http://link.springer.com/chapter/10.1007/978-3-642-30561-0_8		Lise Tordrup HeeagerPeter Axel Nielsen						Excluded	Excluded	new_screen			2						
464	Behave	Microservices: The Evolution and Extinction of Web Services?	http://link.springer.com/article/10.1007/s10664-020-09804-z		Luciano BaresiMartin Garriga						Excluded	Excluded	new_screen			2						
465	Behave	Microservices: Yesterday, Today, and Tomorrow	http://link.springer.com/chapter/10.1007/978-3-319-67425-4_12		Nicola DragoniSaverio GiallorenzoAlberto Lluch LafuenteManuel MazzaraFabrizio MontesiRuslan MustafinLarisa Safina						Excluded	Excluded	new_screen			2						
466	Behave	Migrating to Microservices			Alexis HenryYoussef Ridene						Excluded	Excluded	new_screen			2						
467	Behave	Mobile Testing	http://link.springer.com/chapter/10.1007/978-1-4302-4039-6_13		Scott Preston						Excluded	Excluded	new_screen			2						
468	Behave	Mock objects for testing java systems	http://link.springer.com/article/10.1007/s10664-018-9663-0		Davide SpadiniMaurício AnicheMagiel BruntinkAlberto Bacchelli						Excluded	Excluded	new_screen			2						
469	Behave	Modeling and Analyzing Using ASMs: The Landing Gear System Case Study	http://link.springer.com/chapter/10.1007/978-3-319-07512-9_3		Paolo ArcainiAngelo GargantiniElvinia Riccobene						Excluded	Excluded	new_screen			2						
470	Behave	Modeling in Agile Software Development: Decomposing Use Cases Towards Logical Architecture Design	http://link.springer.com/chapter/10.1007/978-3-662-61168-5_10		Nuno SantosJaime PereiraNuno FerreiraRicardo J. Machado						Excluded	Excluded	new_screen			2						
471	Behave	Modeling Software Requirements	http://link.springer.com/book/10.1007/978-3-662-56386-1		Themistoklis DiamantopoulosAndreas L. Symeonidis						Excluded	Excluded	new_screen			2						
472	Behave	NLP-Assisted Model Generation	http://link.springer.com/chapter/10.1007/978-1-4842-2044-3_3		Mathias SoekenRolf Drechsler						Excluded	Excluded	new_screen			2						
473	Behave	Node Modules	http://link.springer.com/chapter/10.1007/978-3-658-22065-5_5		Elad Elrom						Excluded	Excluded	new_screen			2						
474	Behave	Normen, Standards, Practices	http://link.springer.com/chapter/10.1007/978-3-319-77243-1_18		Klaus-Rainer Müller						Excluded	Excluded	new_screen			2						
475	Behave	Onstage Product Owner	http://link.springer.com/chapter/10.1007/978-1-4842-5168-3_8		Allan Kelly						Excluded	Excluded	new_screen			2						
476	Behave	Open Debates	http://link.springer.com/chapter/10.1007/978-1-4842-1464-0_10		Vikram Dhillon						Excluded	Excluded	new_screen			2						
477	Behave	Organization of the Software Test in Agile Projects	http://link.springer.com/chapter/10.1007/978-3-030-73209-7_3		Manfred BaumgartnerMartin KlonkChristian MastnakHelmut PichlerRichard SeidlSiegfried Tanczos						Excluded	Excluded	new_screen			2						
478	Behave	Patterns – Wie geht es weiter?	http://link.springer.com/chapter/10.1007/978-3-642-34718-4_11		Karl EilebrechtGernot Starke						Excluded	Excluded	new_screen			2						
479	Behave	People and Tools	http://link.springer.com/chapter/10.1007/978-1-4842-3832-5_3		Arnon Axelrod						Excluded	Excluded	new_screen			2						
480	Behave	Planning Your Work	http://link.springer.com/chapter/10.1007/978-1-4842-4152-3_2		Chris Northwood						Excluded	Excluded	new_screen			2						
481	Behave	Polytrix: A Pacto-Powered Polyglot Test Matrix	http://link.springer.com/chapter/10.1007/978-3-642-55128-4_27		Max LincolnFernando Alves						Excluded	Excluded	new_screen			2						
482	Behave	Poor Foundations	http://link.springer.com/chapter/10.1007/978-1-4842-1745-0_4		Tim Brizard						Excluded	Excluded	new_screen			2						
483	Behave	PowerShell-Skripte testen mit Pester	http://link.springer.com/chapter/10.1007/978-3-658-17666-2_6		Peter Monadjemi						Excluded	Excluded	new_screen			2						
484	Behave	Preparing the Project	http://link.springer.com/chapter/10.1007/978-1-4842-1679-8_4		Alan Cline						Excluded	Excluded	new_screen			2						
485	Behave	Prerequisites	http://link.springer.com/chapter/10.1007/978-1-4302-2887-5_3		Steven Sanderson						Excluded	Excluded	new_screen			2						
486	Behave	Prioritization of User Story Acceptance Tests in Agile Software Development Using Meta-Heuristic Techniques and Comparative Analysis	http://link.springer.com/chapter/10.1007/978-981-13-2348-5_4		Ritu SibalPreeti KaurChayanika Sharma						Excluded	Excluded	new_screen			2						
487	Behave	Product Planning	http://link.springer.com/chapter/10.1007/978-3-642-55140-6_4		Hans-Bernd KittlausSamuel A. Fricker						Excluded	Excluded	new_screen			2						
488	Behave	Program comprehension of domain-specific and general-purpose languages: replication of a family of experiments using integrated development environments	https://link.springer.com/article/10.1007/s10664-017-9593-2		Tomaž KosarSašo GabercJeffrey C. CarverMarjan Mernik						Excluded	Excluded	new_screen			2						
489	Behave	PTCWA: Performance Testing of Cloud Based Web Applications	http://link.springer.com/chapter/10.1007/978-3-030-41862-5_32		M. S. Geetha DevasenaR. Kingsy GraceS. ManjuV. Krishna Kumar						Excluded	Excluded	new_screen			2						
490	Behave	Public Administration for the Next Generation	http://link.springer.com/chapter/10.1007/978-3-319-63743-3_2		Peter Winstanley						Excluded	Excluded	new_screen			2						
491	Behave	Putting ASP.NET MVC in Context			Adam Freeman						Excluded	Excluded	new_screen			2						
492	Behave	QTREDS: a Ruby on Rails-based platform for omics laboratories			Piergiorgio PallaGianfranco FrauLaura VargiuPatricia Rodriguez-Tomé						Excluded	Excluded	new_screen			2						
493	Behave	Quality and Testing			Andrew Davis						Excluded	Excluded	new_screen			2						
494	Behave	Reengineering and Reverse Engineering			Ervin Varga						Excluded	Excluded	new_screen			2						
495	Behave	Refactoring Tools	http://link.springer.com/chapter/10.1007/978-1-4302-2728-1_6		Francesco TrucchiaJacopo Romei						Excluded	Excluded	new_screen			2						
496	Behave	Requirement Engineering as a Software Development Process	http://link.springer.com/chapter/10.1007/978-3-030-34706-2_2		Pawel BaszuroJakub Swacha						Excluded	Excluded	new_screen			2						
497	Behave	Requirements Engineering and Semantic Web*	http://link.springer.com/article/10.1007/s10559-016-9808-3		L. P. Babenko						Excluded	Excluded	new_screen			2						
498	Behave	Requirements Engineering for Cyber-Physical Systems	http://link.springer.com/chapter/10.1007/978-3-662-44739-0_35		Stefan WiesnerChristian GorldtMathias SoekenKlaus-Dieter ThobenRolf Drechsler						Excluded	Excluded	new_screen			2						
499	Behave	Requirements Thread	http://link.springer.com/chapter/10.1007/978-1-4842-1679-8_9		Alan Cline						Excluded	Excluded	new_screen			2						
500	Behave	Resolving Interoperability in Concurrent Engineering	http://link.springer.com/chapter/10.1007/978-3-319-13776-6_6		Nicolas FigayCatarina Ferreira da SilvaParisa GhodousRicardo Jardim-Goncalves						Excluded	Excluded	new_screen			2						
501	Behave	REST API	http://link.springer.com/chapter/10.1007/978-1-4842-0037-7_21		Azat Mardan						Excluded	Excluded	new_screen			2						
502	Behave	Rigorous development process of a safety-critical system: from ASM models to Java code	http://link.springer.com/article/10.1007/s10009-015-0394-x		Paolo ArcainiAngelo GargantiniElvinia Riccobene						Excluded	Excluded	new_screen			2						
503	Behave	Robust Design of a Collaborative Platform for Model-Based System Engineering: Experience from an Industrial Deployment	http://link.springer.com/chapter/10.1007/978-3-030-32065-2_23		Christophe PonsardRobert DarimontMounir Touzani						Excluded	Excluded	new_screen			2						
504	Behave	ROM: An Approach to Self-consistency Verification of a Runnable Ontology Model	http://link.springer.com/chapter/10.1007/978-3-642-54105-6_18		Iaakov ExmanReuven Yagel						Excluded	Excluded	new_screen			2						
505	Behave	SAFECode Whitepaper: Fundamental Practices for Secure Software Development 2nd Edition			Stacy Simpson						Excluded	Excluded	new_screen			2						
506	Behave	Scala Testing	http://link.springer.com/chapter/10.1007/978-3-319-75771-1_37		John Hunt						Excluded	Excluded	new_screen			2						
507	Behave	Scaling Your Team			David Pollak						Excluded	Excluded	new_screen			2						
508	Behave	Scripting			Gennadiy Alpaev						Excluded	Excluded	new_screen			2						
509	Behave	Scrum Framework und Praxis	http://link.springer.com/chapter/10.1007/978-3-658-25085-0_3		Janko Böhm						Excluded	Excluded	new_screen			2						
510	Behave	Semi-automated Design Guidance Enhancer (SADGE): A Framework for Architectural Guidance Development			Mohsen AnvaariOlaf Zimmermann						Excluded	Excluded	new_screen			2						
511	Behave	Shorter Feedback Loops By Means of Continuous Deployment	http://link.springer.com/chapter/10.1007/978-3-319-18612-2_24		Arjan ClaassenLaurens Boekhorst						Excluded	Excluded	new_screen			2						
512	Behave	Software Processes in the Software Product Life Cycle	http://link.springer.com/chapter/10.1007/978-3-319-98845-0_3		Ralf Kneuper						Excluded	Excluded	new_screen			2						
513	Behave	Software Quality Assurance During Implementation: Results of a Survey in Software Houses from Germany, Austria and Switzerland	http://link.springer.com/chapter/10.1007/978-3-319-49421-0_7		Michael FeldererFlorian Auer						Excluded	Excluded	new_screen			2						
514	Behave	Software Testing	http://link.springer.com/chapter/10.1007/978-3-030-00262-6_4		Gordon FraserJosé Miguel Rojas						Excluded	Excluded	new_screen			2						
515	Behave	Specification by Example	http://link.springer.com/chapter/10.1007/978-3-030-00262-6_4		Michael Hüttermann						Excluded	Excluded	new_screen			2						
516	Behave	Specifications and Testing	http://link.springer.com/chapter/10.1007/978-1-4842-1745-0_15		Tim Brizard						Excluded	Excluded	new_screen			2						
517	Behave	SportsStore: A Real Application	http://link.springer.com/chapter/10.1007/978-1-4302-2887-5_4		Steven Sanderson						Excluded	Excluded	new_screen			2						
518	Behave	SportsStore: Navigation and Shopping Cart	http://link.springer.com/chapter/10.1007/978-1-4302-2887-5_5		Steven Sanderson						Excluded	Excluded	new_screen			2						
519	Behave	Spotify Tailoring for Architectural Governance	http://link.springer.com/chapter/10.1007/978-3-030-58858-8_24		Abdallah SalamehJulian M. Bass						Excluded	Excluded	new_screen			2						
520	Behave	Sprint 1: Starting a Game	http://link.springer.com/chapter/10.1007/978-1-4302-3534-7_5		Jerrel BlankenshipMatthew BussaScott Millett						Excluded	Excluded	new_screen			2						
521	Behave	Subconscious Requirements: The Fright of Every Tester			Hans van Loenhoud						Excluded	Excluded	new_screen			2						
522	Behave	Success and Failure Factors for Adopting a Combined Approach: A Case Study of Two Software Development Teams	http://link.springer.com/chapter/10.1007/978-3-030-64148-1_8		Ingrid SignorettiMaximilian ZorzettiLarissa SalernoCassiano MorallesEliana PereiraCássio TrindadeSabrina MarczakRicardo Bastos						Excluded	Excluded	new_screen			2						
523	Behave	Supporting Agile Software Development by Natural Language Processing	http://link.springer.com/chapter/10.1007/978-3-642-45260-4_7		Barbara PlankThomas SauerIna Schaefer						Excluded	Excluded	new_screen			2						
524	Behave	Taking It to 11			Jeffrey ScheafferAruna RavichandranAlex Martins						Excluded	Excluded	new_screen			2						
525	Behave	TDD and BDD for Node.js with Mocha	http://link.springer.com/chapter/10.1007/978-1-4302-6596-2_3		Azat Mardan						Excluded	Excluded	new_screen			2						
526	Behave	TDD as an API Design Technique			Ervin Varga						Excluded	Excluded	new_screen			2						
527	Behave	Temporal Random Testing for Spark Streaming	http://link.springer.com/chapter/10.1007/978-3-319-33693-0_25		Adrián RiescoJuan Rodríguez-Hortalá						Excluded	Excluded	new_screen			2						
528	Behave	Test Early, Test Often	http://link.springer.com/chapter/10.1007/978-3-030-30701-1_6		Doug RosenbergBarry BoehmMatt StephensCharles SuscheckShobha Rani DhalipathiBo Wang						Excluded	Excluded	new_screen			2						
529	Behave	Test Frameworks	http://link.springer.com/chapter/10.1007/978-1-4302-4024-2_12		Stephen D. Ritchie						Excluded	Excluded	new_screen			2						
530	Behave	Test-Driven Development	http://link.springer.com/chapter/10.1007/978-1-4842-5949-8_8		Stephan Roth						Excluded	Excluded	new_screen			2						
531	Behave	Test-Driven Development 101	http://link.springer.com/chapter/10.1007/978-1-4842-6972-5_3		Juntao Qiu						Excluded	Excluded	new_screen			2						
532	Behave	Test-Driven Development as a Reliable Embedded Software Engineering Practice	http://link.springer.com/chapter/10.1007/978-3-642-40888-5_4		Piet CordemansSille Van LandschootJeroen BoydensEric Steegmans						Excluded	Excluded	new_screen			2						
533	Behave	Test-Driven Development in Swift	http://link.springer.com/chapter/10.1007/978-1-4842-5602-2_12		Gio Lodi						Excluded	Excluded	new_screen			2						
534	Behave	Testing	http://link.springer.com/chapter/10.1007/978-1-4842-0187-9_12		Chris Northwood						Excluded	Excluded	new_screen			2						
535	Behave	Testing & Debugging	http://link.springer.com/chapter/10.1007/978-1-4842-3519-5_10		Fanie Reynders						Excluded	Excluded	new_screen			2						
536	Behave	Testing and Debugging Projects	http://link.springer.com/chapter/10.1007/978-1-4302-1637-7_7								Excluded	Excluded	new_screen			2						
537	Behave	Testing Batch Processes	http://link.springer.com/chapter/10.1007/978-1-4842-3724-3_13		Michael T. Minella						Excluded	Excluded	new_screen			2						
538	Behave	Testing Chatbots with Charm	http://link.springer.com/chapter/10.1007/978-3-030-58793-2_34		Sergio Bravo-SantosEsther GuerraJuan de Lara						Excluded	Excluded	new_screen			2						
539	Behave	Testing Go Applications	http://link.springer.com/chapter/10.1007/978-1-4842-1052-9_10		Shiju Varghese						Excluded	Excluded	new_screen			2						
540	Behave	Testing Idempotence for Infrastructure as Code	http://link.springer.com/chapter/10.1007/978-3-030-29509-7_3		Waldemar HummerFlorian RosenbergFábio OliveiraTamar Eilam						Excluded	Excluded	new_screen			2						
541	Behave	Testing in DevOps	http://link.springer.com/chapter/10.1007/978-1-4302-6059-2_11		Frank Faber						Excluded	Excluded	new_screen			2						
542	Behave	Testing in Node.js	http://link.springer.com/chapter/10.1007/978-3-319-44902-9_7		Cory Gackenheimer						Excluded	Excluded	new_screen			2						
543	Behave	Testing Strategies in an Agile Context	http://link.springer.com/chapter/10.1007/978-3-030-29509-7_9		Zornitsa Nikolova						Excluded	Excluded	new_screen			2						
544	Behave	Testing Strategies: How to Become a Better Tester?	http://link.springer.com/chapter/10.1007/978-3-319-73195-7_2		Adam Roman						Excluded	Excluded	new_screen			2						
545	Behave	Testing the Distributed System	http://link.springer.com/chapter/10.1007/978-1-4842-3165-4_6		Moises Macero						Excluded	Excluded	new_screen			2						
546	Behave	Testing the User Interface	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_13		Abhishek Mishra						Excluded	Excluded	new_screen			2						
547	Behave	Testing URLSession	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_7		Abhishek Mishra						Excluded	Excluded	new_screen			2						
548	Behave	Testing Your Backbone.js Application	http://link.springer.com/chapter/10.1007/978-1-4302-6335-7_8		James Sugrue						Excluded	Excluded	new_screen			2						
549	Behave	Testing, Deployment, and Troubleshooting	http://link.springer.com/chapter/10.1007/978-1-4842-5116-4_7		Bryan LimRichard LaFranchi						Excluded	Excluded	new_screen			2						
550	Behave	Testmanagement und Softwaretest	http://link.springer.com/book/10.1007/978-3-658-25087-4		Frank Witte						Excluded	Excluded	new_screen			2						
551	Behave	Thailand’s Software Startup Ecosystem	http://link.springer.com/chapter/10.1007/978-3-030-35983-6_12		Aziz NanthaamornphongRattana Wetprasit						Excluded	Excluded	new_screen			2						
552	Behave	The ASMETA Approach to Safety Assurance of Software Systems	http://link.springer.com/chapter/10.1007/978-3-030-76020-5_13		Paolo ArcainiAndrea BombardaSilvia BonfantiAngelo GargantiniElvinia RiccobenePatrizia Scandurra						Excluded	Excluded	new_screen			2						
553	Behave	The Basic Spring Boot Application	http://link.springer.com/chapter/10.1007/978-1-4842-3165-4_2		Moises Macero						Excluded	Excluded	new_screen			2						
554	Behave	The Basics	http://link.springer.com/chapter/10.1007/978-1-4842-2638-4_1		Bala Paranj						Excluded	Excluded	new_screen			2						
555	Behave	The Big Green Check Mark	http://link.springer.com/chapter/10.1007/978-1-4842-2701-5_5		Patrick Gleeson						Excluded	Excluded	new_screen			2						
556	Behave	The Design, Evolution, and Use of KernelF	http://link.springer.com/chapter/10.1007/978-3-319-93317-7_1		Markus Voelter						Excluded	Excluded	new_screen			2						
557	Behave	The Distinct Trends and Transitions in the Information Technology (IT) Space	http://link.springer.com/chapter/10.1007/978-3-319-78637-7_1		Pethuru RajAnupama Raman						Excluded	Excluded	new_screen			2						
558	Behave	The Ecosystem: Extending React Native	http://link.springer.com/chapter/10.1007/978-1-4842-4454-8_10		Akshat PaulAbhishek Nalwaya						Excluded	Excluded	new_screen			2						
559	Behave	The evolution of agile software development in Brazil	http://link.springer.com/article/10.1007/s13173-013-0114-x		Claudia de O. MeloViviane SantosEduardo KatayamaHugo CorbucciRafael PrikladnickiAlfredo GoldmanFabio Kon						Excluded	Excluded	new_screen			2						
560	Behave	The Goals Approach: Agile Enterprise Driven Software Development	http://link.springer.com/chapter/10.1007/978-3-319-52593-8_13		Pedro ValenteThiago SilvaMarco WincklerNuno Nunes						Excluded	Excluded	new_screen			2						
561	Behave	The Goals Approach: Enterprise Model-Driven Agile Human-Centered Software Engineering	http://link.springer.com/chapter/10.1007/978-3-319-44902-9_17		Pedro ValenteThiago Rocha SilvaMarco WincklerNuno Jardim Nunes						Excluded	Excluded	new_screen			2						
562	Behave	The MVVM Architectural Pattern	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_3		Abhishek Mishra						Excluded	Excluded	new_screen			2						
563	Behave	The Product Backlog	http://link.springer.com/chapter/10.1007/978-1-4842-4164-6_9		Frederik M. Fowler						Excluded	Excluded	new_screen			2						
564	Behave	The Protractor Handbook	http://link.springer.com/book/10.1007/978-1-4842-7289-3		Shashank Shukla						Excluded	Excluded	new_screen			2						
565	Behave	The State of Agile Software Development in the Czech Republic: Preliminary Findings Indicate the Dominance of “Abridged” Scrum	http://link.springer.com/chapter/10.1007/978-3-030-37632-1_4		Michal DolezelAlena BuchalcevovaMichal Mencik						Excluded	Excluded	new_screen			2						
566	Behave	The Study of the Effectiveness of the Secure Software Development Life-Cycle Models in IT Project Management	http://link.springer.com/chapter/10.1007/978-3-030-14070-0_14		Saniora R. DuclervilJing-Chiou Liou						Excluded	Excluded	new_screen			2						
567	Behave	To Build a Fire	http://link.springer.com/chapter/10.1007/978-1-4842-4388-6_7		Dave HarrisonKnox Lively						Excluded	Excluded	new_screen			2						
568	Behave	Towards a Taxonomy of Microservices Architectures	http://link.springer.com/chapter/10.1007/978-3-319-74781-1_15		Martin Garriga						Excluded	Excluded	new_screen			2						
569	Behave	Towards a Verification-Driven Iterative Development of Software for Safety-Critical Cyber-Physical Systems	http://link.springer.com/article/10.1186/s13174-021-00132-z		Marjan SirjaniLuciana ProvenzanoSara Abbaspour AsadollahMahshid Helali MoghadamMehrdad Saadatmand						Excluded	Excluded	new_screen			2						
570	Behave	Towards an Executable Methodology for the Formalization of Legal Texts	http://link.springer.com/chapter/10.1007/978-3-030-44638-3_10		Tomer LibalAlexander Steen						Excluded	Excluded	new_screen			2						
571	Behave	Towards Automated UI-Tests for Sensor-Based Mobile Applications	http://link.springer.com/chapter/10.1007/978-3-319-22689-7_1		Tobias GriebeMarc HeseniusVolker Gruhn						Excluded	Excluded	new_screen			2						
572	Behave	Towards Establishing Mass Customization Methods for Cloud-Compliant Services	http://link.springer.com/chapter/10.1007/978-3-642-32847-3_75		Shigeru HosonoYoshiki Shimomura						Excluded	Excluded	new_screen			2						
573	Behave	Towards More Flexible Enterprise Information Systems	http://link.springer.com/chapter/10.1007/978-3-642-36611-6_12		Rogerio Atem de CarvalhoBjörn Johansson						Excluded	Excluded	new_screen			2						
574	Behave	Towards Transparent Legal Formalization	http://link.springer.com/chapter/10.1007/978-3-030-82017-6_18		Tomer LibalTereza Novotná						Excluded	Excluded	new_screen			2						
575	Behave	Towards User-Friendly Projectional Editors	http://link.springer.com/chapter/10.1007/978-3-319-11245-9_3		Markus VoelterJanet SiegmundThorsten BergerBernd Kolb						Excluded	Excluded	new_screen			2						
576	Behave	Transitioning Towards Continuous Experimentation in a Large Software Product and Service Development Organisation – A Case Study	http://link.springer.com/chapter/10.1007/978-3-319-49094-6_22		Sezin Gizem YamanFabian FagerholmMyriam MunezeroJürgen MünchMika AaltolaChristina PalmuTomi Männistö						Excluded	Excluded	new_screen			2						
577	Behave	TSTL: the template scripting testing language	http://link.springer.com/article/10.1007/s10009-016-0445-y		Josie HolmesAlex GroceJervis PintoPranjal MittalPooria AzimiKevin KellarJames O’Brien						Excluded	Excluded	new_screen			2						
578	Behave	Understanding Core JUnit 5	http://link.springer.com/chapter/10.1007/978-1-4842-3015-2_2		Shekhar GulatiRahul Sharma						Excluded	Excluded	new_screen			2						
579	Behave	Understanding Services with Reactive Programming	http://link.springer.com/chapter/10.1007/978-1-4842-2620-9_5		Oren Farhi						Excluded	Excluded	new_screen			2						
580	Behave	Unit Testing	http://link.springer.com/chapter/10.1007/978-1-4302-3163-9_7		Gary McLean Hall						Excluded	Excluded	new_screen			2						
581	Behave	Unit Testing and Integration Testing	http://link.springer.com/chapter/10.1007/978-1-4302-4726-5_15		Tugberk UgurluAlexander ZeitlerAli Kheyrollahi						Excluded	Excluded	new_screen			2						
582	Behave	Unit Tests and TDD	http://link.springer.com/chapter/10.1007/978-1-4842-3832-5_17		Arnon Axelrod						Excluded	Excluded	new_screen			2						
583	Behave	Unity Application Testing Automation with Appium and Image Recognition	http://link.springer.com/chapter/10.1007/978-3-319-71734-0_12		Maxim MozgovoyEvgeny Pyshkin						Excluded	Excluded	new_screen			2						
584	Behave	Use, potential, and showstoppers of models in automotive requirements engineering	http://link.springer.com/article/10.1007/s10270-018-0683-4		Grischa LiebelMatthias TichyEric Knauss						Excluded	Excluded	new_screen			2						
585	Behave	Useful RSpec Tools	http://link.springer.com/chapter/10.1007/978-1-4842-6141-5_5		Panos Matsinopoulos						Excluded	Excluded	new_screen			2						
586	Behave	User Interface Design	http://link.springer.com/chapter/10.1007/978-1-4842-4303-9_4		Shailesh Kumar ShivakumarSourabhh Sethii						Excluded	Excluded	new_screen			2						
587	Behave	Using Agile Testing in an Academic Health System Case Study	http://link.springer.com/chapter/10.1007/978-3-319-67549-7_11		Daniela America da SilvaSamara Cardoso dos SantosRodrigo Monteiro de Barros SantanaFilipe Santiago QueirozGildarcio Sousa GoncalvesVictor Ulisses PuglieseAlexandre NascimentoLuiz Alberto Vieira DiasAdilson Marques da CunhaJohnny MarquesPaulo Marcelo Tasinaffo						Excluded	Excluded	new_screen			2						
588	Behave	Using Data Integration for Security Testing	http://link.springer.com/chapter/10.1007/978-3-658-19969-2_3		Sébastien SalvaLoukmen Regainia						Excluded	Excluded	new_screen			2						
589	Behave	Using language workbenches and domain-specific languages for safety-critical software development	http://link.springer.com/chapter/10.1007/978-3-662-50263-1_3		Markus VoelterBernd KolbKlaus BirkenFederico TomassettiPatrick AlffLaurent WiartAndreas WortmannArne Nordmann						Excluded	Excluded	new_screen			2						
590	Behave	Web Testing Practices	http://link.springer.com/chapter/10.1007/978-1-4302-3970-3_3		Matthew Sacks						Excluded	Excluded	new_screen			2						
591	Behave	What Do They Do All Day?	http://link.springer.com/chapter/10.1007/978-1-4842-2701-5_4		Patrick Gleeson						Excluded	Excluded	new_screen			2						
592	Behave	What Is Unit Testing?	http://link.springer.com/chapter/10.1007/978-1-4842-1212-7_2		Rādhārādhya Dāsa						Excluded	Excluded	new_screen			2						
593	Behave	What your plug-in test suites really test: an integration perspective on test suite understanding	http://link.springer.com/article/10.1007/s10664-012-9235-7		Michaela GreilerArie van Deursen						Excluded	Excluded	new_screen			2						
594	Behave	What’s Ahead for You and Scrum?	http://link.springer.com/chapter/10.1007/978-1-4302-2887-5_1		Jerrel BlankenshipMatthew BussaScott Millett						Excluded	Excluded	new_screen			2						
595	Behave	What’s the Big Idea?	http://link.springer.com/chapter/10.1007/978-1-4842-6711-0_2		Adam Freeman						Excluded	Excluded	new_screen			2						
596	Behave	Why Test-Driven Development Is a Must for Code Quality	http://link.springer.com/chapter/10.1007/978-3-662-56386-1_9		Paul David Hardy						Excluded	Excluded	new_screen			2						
597	Behave	Windows Server-Administration mit PowerShell 5.1	http://link.springer.com/book/10.1007/978-3-658-17666-2		Peter Monadjemi						Excluded	Excluded	new_screen			2						
598	Behave	Workflow	http://link.springer.com/chapter/10.1007/978-1-4302-6098-1_8		Mark E. Daggett						Excluded	Excluded	new_screen			2						
599	Behave	Working with Legacy Code	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_8		Abhishek Mishra						Excluded	Excluded	new_screen			2						
600	Behave	Writing Your First Set of Unit Tests with Xcode	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_2		Abhishek Mishra						Excluded	Excluded	new_screen			2						
