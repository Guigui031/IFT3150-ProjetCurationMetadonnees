key	project	title	abstract	keywords	authors	venue	doi	references	pages	bibtex	screened_decision	final_decision	mode	inclusion_criteria	exclusion_criteria	reviewer_count	source	year	meta_title	link	publisher	metadata_missing
0	Behave	On the understanding of BDD scenarios’ quality: Preliminary practitioners’ opinions	[Context & Motivation] In agile development, acceptance tests are written to express the details from the conversations between customers and developers. One of the formats to express those details is BDD (Behavior-Driven Development) scenarios, which use a ubiquitous language, one that business and technical people can understand, to build an executable specification that represents a system behavior. [Question/Problem] Problems caused by bad documentation are known to cause project failure and we believe those problems apply to documentation in the format of acceptance tests as well. Thus, in the long-term, we seek to understand what would be the definition of a good BDD scenario and the criteria to define it. [Principal idea/results] To achieve that, we previously identified known requirements’ quality attributes that would be suitable to evaluate BDD scenarios’ quality. Based on that list of attributes, we now aim to validate that list with practitioners, identify their interpretation of the listed attributes, and uncover general recommendations to write BDD scenarios. [Contribution] Preliminary results from our initial set of interviews revealed practitioners’ interpretations for consistent, testable, valuable, understandable, and unambiguous attributes and some recommendations to write good BDD scenarios, such as the use of declarative form of writing. © Springer International Publishing AG, part of Springer Nature 2018.		Oliveira G., Marczak S.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	[Context & Motivation] In agile development, acceptance tests are written to express the details from the conversations between customers and developers. One of the formats to express those details is BDD (Behavior-Driven Development) scenarios, which use a ubiquitous language, one that business and technical people can understand, to build an executable specification that represents a system behavior. [Question/Problem] Problems caused by bad documentation are known to cause project failure and we believe those problems apply to documentation in the format of acceptance tests as well. Thus, in the long-term, we seek to understand what would be the definition of a good BDD scenario and the criteria to define it. [Principal idea/results] To achieve that, we previously identified known requirements’ quality attributes that would be suitable to evaluate BDD scenarios’ quality. Based on that list of attributes, we now aim to validate that list with practitioners, identify their interpretation of the listed attributes, and uncover general recommendations to write BDD scenarios. [Contribution] Preliminary results from our initial set of interviews revealed practitioners’ interpretations for consistent, testable, valuable, understandable, and unambiguous attributes and some recommendations to write good BDD scenarios, such as the use of declarative form of writing. © Springer International Publishing AG, part of Springer Nature 2018.				Excluded	Excluded	new_screen			2						
1	Behave	Testing schematron using XSpec	[No abstract available]		[No author name available]	Balisage Series on Markup Technologies	[No abstract available]				Excluded	Excluded	new_screen			2						
2	Behave	Enhancing the Student Learning Experience by Adopting TDD and BDD in Course Projects	A demonstration of the application and contribution of Test-Driven Development (TDD) and Behavior-Driven Development (BDD) in the student learning experience in the context of a Software Engineering course. Background: Software testing is an activity for ensuring software quality. Although teaching testing rigorously to students is a priority in academia, undergraduate students often encounter difficulties performing testing tasks effectively. Intended Outcomes: To increase satisfaction rate and course grades, and reduce delivery time. Application Design: We experimented with the Software Engineering Laboratory (LES) course of a Private University in the Bachelor of Computer Science and Information Systems courses. This experiment corroborated the learning difficulties of students. Collected data were assessed both quantitatively and qualitatively. Findings: Backed up with statistical tests, the results showed a reduction in student absences, higher student satisfaction rate, and higher grades in the courses. Furthermore, our approach allowed students to deliver a product in a short period, representing a possibility of adoption of BDD due to their successful learning experience. Finally, we aim to foster a discussion of appropriate teaching methods of software testing.	Software Testing;Student Learning Experience;Software Engineering Education;course Project;Agile Software Development	F. G. Rocha; L. S. Souza; T. S. Silva; G. Rodríguez	2021 IEEE Global Engineering Education Conference (EDUCON)	A demonstration of the application and contribution of Test-Driven Development (TDD) and Behavior-Driven Development (BDD) in the student learning experience in the context of a Software Engineering course. Background: Software testing is an activity for ensuring software quality. Although teaching testing rigorously to students is a priority in academia, undergraduate students often encounter difficulties performing testing tasks effectively. Intended Outcomes: To increase satisfaction rate and course grades, and reduce delivery time. Application Design: We experimented with the Software Engineering Laboratory (LES) course of a Private University in the Bachelor of Computer Science and Information Systems courses. This experiment corroborated the learning difficulties of students. Collected data were assessed both quantitatively and qualitatively. Findings: Backed up with statistical tests, the results showed a reduction in student absences, higher student satisfaction rate, and higher grades in the courses. Furthermore, our approach allowed students to deliver a product in a short period, representing a possibility of adoption of BDD due to their successful learning experience. Finally, we aim to foster a discussion of appropriate teaching methods of software testing.				Included	Included	new_screen			2						
3	Behave	How to Evaluate BDD Scenarios' Quality?	A scenario from the Behavior-driven development (BDD) practice is a known format to represent acceptance tests in agile methodologies, communicating assumptions and expectations by expressing the details that result from the conversations between customers and developers. We believe that this formalization of behavior need to be of good quality to avoid known requirement problems that arise from bad documentation, such as incomplete, underspecified and inconsistent requirements. However, there are only informal guidelines to guide practitioners on their BDD scenarios' elaboration and quality evaluations. To address this lack of guidance, we define a set of quality attributes and propose a question-based checklist to assist BDD scenarios' quality evaluations. [Methods] The quality attributes were identified from an interview-based study with 18 practitioners. In this study, practitioners shared their interpretations on an initial set of literature-informed quality attributes and their own personal evaluation criteria. We consolidated both in a single list of newly redefined attributes, used in the definition of our proposed checklist. We believe that our newly re-defined quality attributes and question-based checklist can enhance the existing guidelines and practitioners' ability to evaluate BDD scenario's quality by providing them with an standard guideline for scenarios' refinement conversations.	behavior-driven development; empirical study; checklist; documentation; quality	Oliveira, Gabriel; Marczak, Sabrina; Moralles, Cassiano	Proceedings of the XXXIII Brazilian Symposium on Software Engineering	A scenario from the Behavior-driven development (BDD) practice is a known format to represent acceptance tests in agile methodologies, communicating assumptions and expectations by expressing the details that result from the conversations between customers and developers. We believe that this formalization of behavior need to be of good quality to avoid known requirement problems that arise from bad documentation, such as incomplete, underspecified and inconsistent requirements. However, there are only informal guidelines to guide practitioners on their BDD scenarios' elaboration and quality evaluations. To address this lack of guidance, we define a set of quality attributes and propose a question-based checklist to assist BDD scenarios' quality evaluations. [Methods] The quality attributes were identified from an interview-based study with 18 practitioners. In this study, practitioners shared their interpretations on an initial set of literature-informed quality attributes and their own personal evaluation criteria. We consolidated both in a single list of newly redefined attributes, used in the definition of our proposed checklist. We believe that our newly re-defined quality attributes and question-based checklist can enhance the existing guidelines and practitioners' ability to evaluate BDD scenario's quality by providing them with an standard guideline for scenarios' refinement conversations.				Included	Included	new_screen			2						
4	Behave	Implementing behavior driven development in an open source ERP	A typical problem in Software Engineering is how to guarantee that all system's requirements are correctly implemented through source code. Traditionally, requirement tracing is a manual task comprised of keeping links from requirements to source code, going through different modeling artifacts, including models. However, these techniques cannot guarantee that requirements are always correctly implemented by source code. Aiming at solving this problem, Behavior-Driven Development (BDD) is a specification technique that automatically checks if all functional requirements are treated properly by source code through the connection of the textual description of requirements to automated tests. Given that for Enterprise Information Systems, requirements are usually identified by analyzing business process models, and these processes are implemented through workflows, connecting workflows to automated tests through BDD specifications can provide automated requirements traceability. The aim of this paper is to briefly present this proposal and show how it was implemented for the open source ERP5 system. © 2013 IFIP International Federation for Information Processing.		De Carvalho R.A., De Carvalho E Silva F.L., Manhães R.S., De Oliveira G.L.	Lecture Notes in Business Information Processing	A typical problem in Software Engineering is how to guarantee that all system's requirements are correctly implemented through source code. Traditionally, requirement tracing is a manual task comprised of keeping links from requirements to source code, going through different modeling artifacts, including models. However, these techniques cannot guarantee that requirements are always correctly implemented by source code. Aiming at solving this problem, Behavior-Driven Development (BDD) is a specification technique that automatically checks if all functional requirements are treated properly by source code through the connection of the textual description of requirements to automated tests. Given that for Enterprise Information Systems, requirements are usually identified by analyzing business process models, and these processes are implemented through workflows, connecting workflows to automated tests through BDD specifications can provide automated requirements traceability. The aim of this paper is to briefly present this proposal and show how it was implemented for the open source ERP5 system. © 2013 IFIP International Federation for Information Processing.				Included	Included	new_screen			2						
5	Behave	Business Language Driven Development: Joining business process models to automated tests	A typical problem in Software Engineering is how to guarantee that every system requirement is correctly implemented by source code. Many techniques were proposed, mostly based on taking notes of relationships between requirements and code in modeling and documenting artifacts. However, these techniques cannot guarantee that the artifacts are always synchronized with source code. Aiming at solving this problem, Behavior-Driven Development (BDD) is a specification technique that automatically checks that all functional requirements are treated properly by source code, through connecting the textual description of requirements to automated tests. Nevertheless, in some software development areas, such as Enterprise Information Systems (EIS), requirements are usually identified by analyzing business process models - which use graphical notations of the underlying processes logic. Therefore, the aim of this paper is to present Business Language Driven Development (BLDD), a method that aims to extend BDD, by connecting business process models directly to automated tests, thus guaranteeing that requirements are properly covered by code. © 2012 Taylor & Francis Group, London.		De Carvalho R.A., De Carvalho E Silva F.L., Manhaes R.S.	Advances in Enterprise Information Systems II - Proceedings of the 5th International Conference on Research and Practical Issues of Enterprise Information Systems, CONFENIS 2011	A typical problem in Software Engineering is how to guarantee that every system requirement is correctly implemented by source code. Many techniques were proposed, mostly based on taking notes of relationships between requirements and code in modeling and documenting artifacts. However, these techniques cannot guarantee that the artifacts are always synchronized with source code. Aiming at solving this problem, Behavior-Driven Development (BDD) is a specification technique that automatically checks that all functional requirements are treated properly by source code, through connecting the textual description of requirements to automated tests. Nevertheless, in some software development areas, such as Enterprise Information Systems (EIS), requirements are usually identified by analyzing business process models - which use graphical notations of the underlying processes logic. Therefore, the aim of this paper is to present Business Language Driven Development (BLDD), a method that aims to extend BDD, by connecting business process models directly to automated tests, thus guaranteeing that requirements are properly covered by code. © 2012 Taylor & Francis Group, London.				Included	Included	new_screen			2						
6	Behave	Test Automation Using Selenium Webdriver 3.0 with C#	About the Book Test Automation using Selenium WebDriver with C#, is the latest book released on Selenium 3.0 using C# as a programming language. This Selenium book has been designed with the objectives of simplicity and ease of understanding. After the huge success of author Vaibhav Mittal and Navneesh Gargs Test Automation books on Selenium with Java, UFT and Microsoft Coded UI this book follows a similar step by step approach to Install, configure and design automation framework using Selenium WebDriver using Visual Studio 2017 and its components. Who is this book for? This book is recommended both for those who are beginning to learn test automation (using Selenium WebDriver) and for advanced automation users. It follows a unique training based approach instead of a regular textbook approach. Using a step by step approach, it guides the students through the exercises using pictorial snapshots. It includes many practical examples and issues which most of the automation testers encounter in day-to-day automation. These experiences will give you an insight into what challenges you could face with automation in the real world. Practical examples cover how to use most of the features within Selenium WebDriver using Visual Studio 2017. No Programming Background? A major fear amongst functional testers who want to learn Selenium is of programming language and coding. As a part of this, we will cover just enough basics of C# programming language that will give the readers the confidence to use Selenium WebDriver. Integrations Covered This book covers Selenium Webdriver integration with independent components to be installed like Microsoft Visual Studio 2017, Katalon, Extent Report, VSTS (Continuous Integration tool) and Specflow (Behaviour Driven Development). We will cover step by step installation, configuration and use of each of these components. Those want to know about Cross Browser testing, it covers how to use Selenium WebDriver to run on IE, Firefox and Chrome browsers. It also covers aspects of Continuous Integration tool from Microsoft (VSTS) so that Selenium WebDriver scripts can be integrated with the development environment and run on nightly builds.		Mittal, Vaibhav; Garg, Navneesh		About the Book Test Automation using Selenium WebDriver with C#, is the latest book released on Selenium 3.0 using C# as a programming language. This Selenium book has been designed with the objectives of simplicity and ease of understanding. After the huge success of author Vaibhav Mittal and Navneesh Gargs Test Automation books on Selenium with Java, UFT and Microsoft Coded UI this book follows a similar step by step approach to Install, configure and design automation framework using Selenium WebDriver using Visual Studio 2017 and its components. Who is this book for? This book is recommended both for those who are beginning to learn test automation (using Selenium WebDriver) and for advanced automation users. It follows a unique training based approach instead of a regular textbook approach. Using a step by step approach, it guides the students through the exercises using pictorial snapshots. It includes many practical examples and issues which most of the automation testers encounter in day-to-day automation. These experiences will give you an insight into what challenges you could face with automation in the real world. Practical examples cover how to use most of the features within Selenium WebDriver using Visual Studio 2017. No Programming Background? A major fear amongst functional testers who want to learn Selenium is of programming language and coding. As a part of this, we will cover just enough basics of C# programming language that will give the readers the confidence to use Selenium WebDriver. Integrations Covered This book covers Selenium Webdriver integration with independent components to be installed like Microsoft Visual Studio 2017, Katalon, Extent Report, VSTS (Continuous Integration tool) and Specflow (Behaviour Driven Development). We will cover step by step installation, configuration and use of each of these components. Those want to know about Cross Browser testing, it covers how to use Selenium WebDriver to run on IE, Firefox and Chrome browsers. It also covers aspects of Continuous Integration tool from Microsoft (VSTS) so that Selenium WebDriver scripts can be integrated with the development environment and run on nightly builds.				Excluded	Excluded	new_screen			2						
7	Behave	Bridging the Gap between Requirements Modeling and Behavior-Driven Development	Acceptance criteria (AC) are implementation agnostic conditions that a system must meet to be consistent with its requirements and be accepted by its stakeholders. Each acceptance criterion is typically expressed as a natural-language statement with a clear pass or fail outcome. Writing AC is a tedious and error-prone activity, especially when the requirements specifications evolve and there are different analysts and testing teams involved. Analysts and testers must iterate multiple times to ensure that AC are understandable and feasible, and accurately address the most important requirements and workflows of the system being developed. In many cases, analysts express requirements through models, along with natural language, typically in some variant of the UML. AC must then be derived by developers and testers from such models. In this paper, we bridge the gap between requirements models and AC by providing a UML-based modeling methodology and an automated solution to generate AC. We target AC in the form of Behavioral Specifications in the context of Behavioral-Driven Development (BDD), a widely used agile practice in many application domains. More specially we target the well-known Gherkin language to express AC, which then can be used to generate executable test cases. We evaluate our modeling methodology and AC generation solution through an industrial case study in the financial domain. Our results suggest that (1) our methodology is feasible to apply in practice, and (2) the additional modeling effort required by our methodology is outweighed by the benefits the methodology brings in terms of automated and systematic AC generation and improved model precision.	Software testing;BDD;modeling;requirements engineering;text generation;Gherkin;FinTech	M. Alferez; F. Pastore; M. Sabetzadeh; L. Briand; J. Riccardi	2019 ACM/IEEE 22nd International Conference on Model Driven Engineering Languages and Systems (MODELS)	Acceptance criteria (AC) are implementation agnostic conditions that a system must meet to be consistent with its requirements and be accepted by its stakeholders. Each acceptance criterion is typically expressed as a natural-language statement with a clear pass or fail outcome. Writing AC is a tedious and error-prone activity, especially when the requirements specifications evolve and there are different analysts and testing teams involved. Analysts and testers must iterate multiple times to ensure that AC are understandable and feasible, and accurately address the most important requirements and workflows of the system being developed. In many cases, analysts express requirements through models, along with natural language, typically in some variant of the UML. AC must then be derived by developers and testers from such models. In this paper, we bridge the gap between requirements models and AC by providing a UML-based modeling methodology and an automated solution to generate AC. We target AC in the form of Behavioral Specifications in the context of Behavioral-Driven Development (BDD), a widely used agile practice in many application domains. More specially we target the well-known Gherkin language to express AC, which then can be used to generate executable test cases. We evaluate our modeling methodology and AC generation solution through an industrial case study in the financial domain. Our results suggest that (1) our methodology is feasible to apply in practice, and (2) the additional modeling effort required by our methodology is outweighed by the benefits the methodology brings in terms of automated and systematic AC generation and improved model precision.				Included	Included	new_screen			2						
8	Behave	Design and validation of a C++ code generator from Abstract State Machines specifications	According to best practices of model-driven engineering, the implementation of a system should be obtained from its model through a systematic model-to-code transformation. We present in this paper a methodology supported by the Asm2C++ tool, which allows the users to generate C++ code from abstract state machine models. Thanks to Asm2C++, the implementation is generated in a seamless manner with an assurance of potential bug freeness of the generated code. Following the same approach, model-based testing suggests deriving also (unit) tests from abstract models. We extend the Asm2C++ tool such that it can automatically produce unit tests for the generated code. Abstract test sequences, either generated randomly or through model checking, are translated to concrete C++ unit tests using the Boost library. In a similar manner, also, scenarios are generated in a behavior-driven development (BDD) approach. To guarantee the correctness of the transformation process, we define a mechanism to test the correctness of the model-to-code transformation with respect to two main criteria: syntactical correctness and semantic correctness, which is based on the definition of conformance between the specification and the code. Using this approach, we have devised a process able to test the generated code by reusing unit tests. The process has been used to validate our model-to-code transformations. © 2019 John Wiley & Sons, Ltd.		Bonfanti S., Gargantini A., Mashkoor A.	Journal of Software: Evolution and Process	According to best practices of model-driven engineering, the implementation of a system should be obtained from its model through a systematic model-to-code transformation. We present in this paper a methodology supported by the Asm2C++ tool, which allows the users to generate C++ code from abstract state machine models. Thanks to Asm2C++, the implementation is generated in a seamless manner with an assurance of potential bug freeness of the generated code. Following the same approach, model-based testing suggests deriving also (unit) tests from abstract models. We extend the Asm2C++ tool such that it can automatically produce unit tests for the generated code. Abstract test sequences, either generated randomly or through model checking, are translated to concrete C++ unit tests using the Boost library. In a similar manner, also, scenarios are generated in a behavior-driven development (BDD) approach. To guarantee the correctness of the transformation process, we define a mechanism to test the correctness of the model-to-code transformation with respect to two main criteria: syntactical correctness and semantic correctness, which is based on the definition of conformance between the specification and the code. Using this approach, we have devised a process able to test the generated code by reusing unit tests. The process has been used to validate our model-to-code transformations. © 2019 John Wiley & Sons, Ltd.				Excluded	Excluded	new_screen			2						
9	Behave	An optimized algorithm on distributed network node data access path based on behavior drive model	According to different node data access objects, and based on the idea of behavior-driven development, an interface-oriented node data access tool is designed and implemented. The tool mainly implements an executable node data access tool that is based on MFC, and writes a set of Win32 console application, which improves the node data automation access scripts and encapsulates the module interfaces, thus improving the distributed network data access speed. © (2014) Trans Tech Publications, Switzerland.		Jiang W.X., Hu X.Z., Wang S., Liang Y.	Applied Mechanics and Materials	According to different node data access objects, and based on the idea of behavior-driven development, an interface-oriented node data access tool is designed and implemented. The tool mainly implements an executable node data access tool that is based on MFC, and writes a set of Win32 console application, which improves the node data automation access scripts and encapsulates the module interfaces, thus improving the distributed network data access speed. © (2014) Trans Tech Publications, Switzerland.				Excluded	Excluded	new_screen			2						
10	Behave	The new Y Chromosome Haplotype Reference Database	After opening the first version of an internet-accessible worldwide reference database of Y chromosome profiles 14 years ago and six years after the last major relaunch the new YHRD 4.0 repository and website has been rolled-out. By November 2014 about 136k 9-locus haplotypes, among these 84k 17-locus haplotypes, 25k 23-locus haplotypes and 15k Y SNP profiles from 917 sampling locations in 128 countries have been submitted by more than 250 institutes and laboratories. In geographic terms, about 39% of the YHRD samples are from Europe, 32% from Asia, 16% from South America, 6% from North America, 4% from Africa and 2% from Oceania/Australia. Worldwide collaboration is the driving force for the rapid growth of the database and this, in turn, allows the evaluation and implementation of enhanced interpretation tools (variable frequency estimators, LR-based mixture and kinship analysis, Y-SNP-based ancestry assessment).	Database, Y chromosome, Haplotype, Y-STR, Frequency estimation, Metapopulation	Willuweit, Sascha; Roewer, Lutz	Forensic Science International: Genetics	After opening the first version of an internet-accessible worldwide reference database of Y chromosome profiles 14 years ago and six years after the last major relaunch the new YHRD 4.0 repository and website has been rolled-out. By November 2014 about 136k 9-locus haplotypes, among these 84k 17-locus haplotypes, 25k 23-locus haplotypes and 15k Y SNP profiles from 917 sampling locations in 128 countries have been submitted by more than 250 institutes and laboratories. In geographic terms, about 39% of the YHRD samples are from Europe, 32% from Asia, 16% from South America, 6% from North America, 4% from Africa and 2% from Oceania/Australia. Worldwide collaboration is the driving force for the rapid growth of the database and this, in turn, allows the evaluation and implementation of enhanced interpretation tools (variable frequency estimators, LR-based mixture and kinship analysis, Y-SNP-based ancestry assessment).				Excluded	Excluded	new_screen			2						
11	Behave	Digital forensics as a service: Stepping up the game	After providing Digital Forensics as a Service (DFaaS) implementations to law enforcement agencies for close to a decade, we present our view from an inside-out perspective. We share the lessons learned from an organizational, operational and development perspective in a forensic and legal context. We conclude with our vision on how to bring the DFaaS concept to the next level for both investigative and innovative purposes.	Digital forensics, Digital forensics as a service, DFaaS, Hansken	van Beek, H. M. A.; van den Bos, J.; Boztas, A.; van Eijk, E. J.; Schramp, R.; Ugen, M.	Forensic Science International: Digital Investigation	After providing Digital Forensics as a Service (DFaaS) implementations to law enforcement agencies for close to a decade, we present our view from an inside-out perspective. We share the lessons learned from an organizational, operational and development perspective in a forensic and legal context. We conclude with our vision on how to bring the DFaaS concept to the next level for both investigative and innovative purposes.				Excluded	Excluded	new_screen			2						
12	Behave	Behavior-Driven Development Benefits and Challenges: Reports from an Industrial Study	Agile approaches arose as a way of addressing some of the main challenges in software development, such as changing requirements, lack of understanding about the system scope, and out-of-sync between code, requirements, and documentation. Studies show that agile projects still suffer from lack of customer support, resulting in difficulties to represent customer needs on requested features. Behavior-Driven Development (BDD) brings a structured way to represent user behaviors and to validate user stories by using an ubiquitous language, shared among everyone involved on the development of the software. The approach allows the creation of scenarios that can be used by the team to share information between different stakeholders, enabling all those players to successfully collaborate and coordinate their work. In this paper, we report on an empirical study conducted with 24 IT professionals with practical experience on BDD. Through this, we identify the perceived benefits and challenges of adopting BDD.	agile development; behavior-driven development; empirical study; grounded theory	Pereira, Lauriane; Sharp, Helen; de Souza, Cleidson; Oliveira, Gabriel; Marczak, Sabrina; Bastos, Ricardo	Proceedings of the 19th International Conference on Agile Software Development: Companion	Agile approaches arose as a way of addressing some of the main challenges in software development, such as changing requirements, lack of understanding about the system scope, and out-of-sync between code, requirements, and documentation. Studies show that agile projects still suffer from lack of customer support, resulting in difficulties to represent customer needs on requested features. Behavior-Driven Development (BDD) brings a structured way to represent user behaviors and to validate user stories by using an ubiquitous language, shared among everyone involved on the development of the software. The approach allows the creation of scenarios that can be used by the team to share information between different stakeholders, enabling all those players to successfully collaborate and coordinate their work. In this paper, we report on an empirical study conducted with 24 IT professionals with practical experience on BDD. Through this, we identify the perceived benefits and challenges of adopting BDD.				Included	Included	new_screen			2						
13	Behave	Legend: An Agile DSL Toolset for Web Acceptance Testing	Agile development emphasizes collaborations among customers, business analysts, domain experts, developers, and testers. However, the large scale and rapid pace of many agile projects presents challenges during testing activities. Large sets of test artifacts must be comprehensible and available to various stakeholders, traceable to requirements, and easily maintainable as the software evolves. In this paper we describe Legend, a toolset that leverages domain-specific language to streamline functional testing in agile projects. Some key features of the toolset include test template generation from user stories, model-based automation, test inventory synchronization, and centralized test tagging.	Behavior-Driven Development; Software Testing; Agile Development; Domain-Specific Languages; Test Automation	King, Tariq M.; Nunez, Gabriel; Santiago, Dionny; Cando, Adam; Mack, Cody	Proceedings of the 2014 International Symposium on Software Testing and Analysis	Agile development emphasizes collaborations among customers, business analysts, domain experts, developers, and testers. However, the large scale and rapid pace of many agile projects presents challenges during testing activities. Large sets of test artifacts must be comprehensible and available to various stakeholders, traceable to requirements, and easily maintainable as the software evolves. In this paper we describe Legend, a toolset that leverages domain-specific language to streamline functional testing in agile projects. Some key features of the toolset include test template generation from user stories, model-based automation, test inventory synchronization, and centralized test tagging.				Included	Included	new_screen			2						
14	Behave	Combining STPA and BDD for Safety Analysis and Verification in Agile Development	Agile development is in widespread use, even in safety-critical domains. However, there is a lack of an appropriate safety analysis and verification method in agile development. In this poster, we propose the use of Behavior Driven Development for safety verification with System-Theoretic Process Analysis for safety analysis in agile development. It shows a good capability on communication effectiveness through a preliminary controlled experiment.	agile development; safety verification; safety-critical systems	Wang, Yang; Wagner, Stefan	Proceedings of the 40th International Conference on Software Engineering: Companion Proceeedings	Agile development is in widespread use, even in safety-critical domains. However, there is a lack of an appropriate safety analysis and verification method in agile development. In this poster, we propose the use of Behavior Driven Development for safety verification with System-Theoretic Process Analysis for safety analysis in agile development. It shows a good capability on communication effectiveness through a preliminary controlled experiment.				Included	Included	new_screen			2						
15	Behave	Poster: Combining STPA and BDD for Safety Analysis and Verification in Agile Development	Agile development is in widespread use, even in safety-critical domains. However, there is a lack of an appropriate safety analysis and verification method in agile development. In this poster, we propose the use of Behavior Driven Development for safety verification with System-Theoretic Process Analysis for safety analysis in agile development. It shows a good capability on communication effectiveness through a preliminary controlled experiment.	Agile Development;Safety Verification;Safety-Critical Systems	Y. Wang; S. Wagner	2018 IEEE/ACM 40th International Conference on Software Engineering: Companion (ICSE-Companion)	Agile development is in widespread use, even in safety-critical domains. However, there is a lack of an appropriate safety analysis and verification method in agile development. In this poster, we propose the use of Behavior Driven Development for safety verification with System-Theoretic Process Analysis for safety analysis in agile development. It shows a good capability on communication effectiveness through a preliminary controlled experiment.				Excluded	Excluded	new_screen			2						
16	Behave	Identifying critical areas for improvement in agile multi-site co-development	Agile processes potentially ease distributed software development by demanding regular communication and self-management of virtual team members. However, being designed for collocated teams, extensions to the regular process need to be made. We investigate critical areas of improvement based on a case of distributed Scrum involving two unaffiliated Austrian IT organizations that collaborate to build software. We identified eight critical areas for improvement originating from interviews, retrospective meetings and an in-depth case analysis. Key suggestions for practice include the establishment of long-lived single-site Scrum teams and the application of Behavior Driven Development (BDD) to make implicit requirement knowledge explicit and transparent to all of the distributed parties. Copyright © 2013 SCITEPRESS.		Vallon R., Bayrhammer K., Strobl S., Bernhart M., Grechenig T.	ENASE 2013 - Proceedings of the 8th International Conference on Evaluation of Novel Approaches to Software Engineering	Agile processes potentially ease distributed software development by demanding regular communication and self-management of virtual team members. However, being designed for collocated teams, extensions to the regular process need to be made. We investigate critical areas of improvement based on a case of distributed Scrum involving two unaffiliated Austrian IT organizations that collaborate to build software. We identified eight critical areas for improvement originating from interviews, retrospective meetings and an in-depth case analysis. Key suggestions for practice include the establishment of long-lived single-site Scrum teams and the application of Behavior Driven Development (BDD) to make implicit requirement knowledge explicit and transparent to all of the distributed parties. Copyright © 2013 SCITEPRESS.				Excluded	Excluded	new_screen			2						
17	Behave	Quality of software requirements specification in agile projects: A cross-case analysis of six companies	Agile Software Development (ASD) has several limitations concerning its requirements engineering activities. Improving the quality of Software Requirements Specifications (SRSs) in ASD may help to gain a competitive advantage in the software industry. Based on the findings of a Systematic Mapping study, six industrial case studies in different contexts were conducted to investigate and characterize the requirements specification activity in ASD. Data collected from documents, observations, and interviews with software engineers were triangulated, analyzed, and synthesized using Grounded Theory and Meta-Ethnography. The analysis and cross-synthesis of the six case studies resulted in a model describing the phenomenon. This model defines the simplicity and objectivity as essential quality factors of SRSs in ASD. The main factors that affect the SRSs quality in ASD projects are related to their customer-driven nature that leads to prolix SRSs, hindering its understanding from the developer perspective. The emerged model is supported by explanations and provides a deeper understanding of the requirements specification activity in ASD. This creates opportunities for further studies and improvements in SRSs for ASD in industry.	Requirements specification, Agile methods, Empirical study, Agile Requirements Engineering	Medeiros, Juliana; Vasconcelos, Alexandre; Silva, Carla; Goulão, Miguel	Journal of Systems and Software	Agile Software Development (ASD) has several limitations concerning its requirements engineering activities. Improving the quality of Software Requirements Specifications (SRSs) in ASD may help to gain a competitive advantage in the software industry. Based on the findings of a Systematic Mapping study, six industrial case studies in different contexts were conducted to investigate and characterize the requirements specification activity in ASD. Data collected from documents, observations, and interviews with software engineers were triangulated, analyzed, and synthesized using Grounded Theory and Meta-Ethnography. The analysis and cross-synthesis of the six case studies resulted in a model describing the phenomenon. This model defines the simplicity and objectivity as essential quality factors of SRSs in ASD. The main factors that affect the SRSs quality in ASD projects are related to their customer-driven nature that leads to prolix SRSs, hindering its understanding from the developer perspective. The emerged model is supported by explanations and provides a deeper understanding of the requirements specification activity in ASD. This creates opportunities for further studies and improvements in SRSs for ASD in industry.				Excluded	Excluded	new_screen			2						
18	Behave	Assessing The Effectiveness Of Test-Driven Development and Behavior-Driven Development in an Industry Setting	Agile software development deviates from the traditional and plan-based approaches to software engineering as its iterative cycles embrace changes in software requirements. Test-Driven Development (TDD) and Behavior-Driven Development (BDD) are techniques that have been recently adopted by the software industry and have evolved from agile practices. These techniques aim at improving both the quality of the delivered software and the developers' productivity. They are several studies that have been conducted on TDD in both academic and industry settings with however only a few on BDD. While TDD and BDD have both become popular, many organizations and developers still do not understand the differences between these concepts or where they overlap. The aim of this paper is to assess the effectiveness of these two approaches in terms of external code quality, internal code quality and developers' productivity. To understand the weaknesses and strengths of each of these methods, a literature review was first performed. An experiment was then carried out in an industry setting to observe the effectiveness of TDD and BDD on a number of subjects. Our results showed that both techniques indeed increased the external quality of the delivered product. However, a decrease in productivity and internal quality were noted when BDD was used compared to TDD which might be due to the additional steps involved in BDD.	Test-Driven Development;Behavior-Driven Development;TDD;BDD;productivity;quality;code coverage	A. S. Dookhun; L. Nagowah	2019 International Conference on Computational Intelligence and Knowledge Economy (ICCIKE)	Agile software development deviates from the traditional and plan-based approaches to software engineering as its iterative cycles embrace changes in software requirements. Test-Driven Development (TDD) and Behavior-Driven Development (BDD) are techniques that have been recently adopted by the software industry and have evolved from agile practices. These techniques aim at improving both the quality of the delivered software and the developers' productivity. They are several studies that have been conducted on TDD in both academic and industry settings with however only a few on BDD. While TDD and BDD have both become popular, many organizations and developers still do not understand the differences between these concepts or where they overlap. The aim of this paper is to assess the effectiveness of these two approaches in terms of external code quality, internal code quality and developers' productivity. To understand the weaknesses and strengths of each of these methods, a literature review was first performed. An experiment was then carried out in an industry setting to observe the effectiveness of TDD and BDD on a number of subjects. Our results showed that both techniques indeed increased the external quality of the delivered product. However, a decrease in productivity and internal quality were noted when BDD was used compared to TDD which might be due to the additional steps involved in BDD.				Included	Included	new_screen			2						
19	Behave	The effect of Test-Driven Development and Behavior-Driven Development on Project Success Factors: A Systematic Literature Review Based Study	Agile testing approaches test-driven development (TDD), behavior-driven development (BDD); have gained popularity since the introduction of agile practices. The concept of using these approaches in software projects is to help projects succeed. The effect of TDD and BDD on Project success factors namely, cost, time, and customer satisfaction/external quality, remains an area of investigation. Therefore, this study investigates the results of previously published articles on the effect of TDD and BDD on project success factors. A systematic literature review has been conducted considering articles published between 1999 up to 2020. Thirty-one studies were selected and analyzed. 74.1% of studies are experiments, 25.8% are case studies. 67.7% of these studies were performed in an industrial setting, 29.0% were performed in an academic setting and only one study with 3.22% was mixed academic and industrial settings. The result shows that the TDD and the BDD consume more time and cost compared to traditional testing (TLD). Moreover, the TDD as TLD may not necessarily satisfy the customer unlike the BDD appears that achieve customer satisfaction. Although, when TDD compared to BDD, TDD consumed more time and lower customer acceptance than the BDD.	Test Driven Development;Behavior Driven Development;Test Last Development;Systematic Literature Review;Agile Testing;Projects Success Factors	H. M. Abushama; H. A. Alassam; F. A. Elhaj	2020 International Conference on Computer, Control, Electrical, and Electronics Engineering (ICCCEEE)	Agile testing approaches test-driven development (TDD), behavior-driven development (BDD); have gained popularity since the introduction of agile practices. The concept of using these approaches in software projects is to help projects succeed. The effect of TDD and BDD on Project success factors namely, cost, time, and customer satisfaction/external quality, remains an area of investigation. Therefore, this study investigates the results of previously published articles on the effect of TDD and BDD on project success factors. A systematic literature review has been conducted considering articles published between 1999 up to 2020. Thirty-one studies were selected and analyzed. 74.1% of studies are experiments, 25.8% are case studies. 67.7% of these studies were performed in an industrial setting, 29.0% were performed in an academic setting and only one study with 3.22% was mixed academic and industrial settings. The result shows that the TDD and the BDD consume more time and cost compared to traditional testing (TLD). Moreover, the TDD as TLD may not necessarily satisfy the customer unlike the BDD appears that achieve customer satisfaction. Although, when TDD compared to BDD, TDD consumed more time and lower customer acceptance than the BDD.				Excluded	Excluded	new_screen			2						
20	Behave	Behavior driven testing in ALMA telescope calibration software	ALMA software development cycle includes well defined testing stages that involves developers, testers and scientists. We adapted Behavior Driven Development (BDD) to testing activities applied to Telescope Calibration (TELCAL) software. BDD is an agile technique that encourages communication between roles by defining test cases using natural language to specify features and scenarios, what allows participants to share a common language and provides a high level set of automated tests. This work describes how we implemented and maintain BDD testing for TELCAL, the infrastructure needed to support it and proposals to expand this technique to other subsystems. © COPYRIGHT SPIE. Downloading of the abstract is permitted for personal use only.		Gil J.P., Garces M., Broguiere D., Shen T.-C.	Proceedings of SPIE - The International Society for Optical Engineering	ALMA software development cycle includes well defined testing stages that involves developers, testers and scientists. We adapted Behavior Driven Development (BDD) to testing activities applied to Telescope Calibration (TELCAL) software. BDD is an agile technique that encourages communication between roles by defining test cases using natural language to specify features and scenarios, what allows participants to share a common language and provides a high level set of automated tests. This work describes how we implemented and maintain BDD testing for TELCAL, the infrastructure needed to support it and proposals to expand this technique to other subsystems. © COPYRIGHT SPIE. Downloading of the abstract is permitted for personal use only.				Included	Included	new_screen			2						
21	Behave	Behavior-Driven Requirements Traceability via Automated Acceptance Tests	Although information retrieval advances significantly improved automated traceability tools, their accuracy is still far from 100% and therefore they still need human intervention. Furthermore, despite the demonstrated benefits of traceability, many practitioners find the overhead for its creation and maintenance too high. We propose the Behavior Driven Traceability Method (BDT) that takes a different standpoint on automated traceability: we establish ubiquitous traceability between user story requirements and source code by taking advantage of the automated acceptance tests that are created as part of the Behavior Driven Development process.	User stories;automated acceptance tests;traceability;requirements;behavior-driven development	G. Lucassen; F. Dalpiaz; J. M. E. M. van der Werf; S. Brinkkemper; D. Zowghi	2017 IEEE 25th International Requirements Engineering Conference Workshops (REW)	Although information retrieval advances significantly improved automated traceability tools, their accuracy is still far from 100% and therefore they still need human intervention. Furthermore, despite the demonstrated benefits of traceability, many practitioners find the overhead for its creation and maintenance too high. We propose the Behavior Driven Traceability Method (BDT) that takes a different standpoint on automated traceability: we establish ubiquitous traceability between user story requirements and source code by taking advantage of the automated acceptance tests that are created as part of the Behavior Driven Development process.				Included	Included	new_screen			2						
22	Behave	Orchestration of Domain Specific Test Languages with a Behavior Driven Development approach	An airplane is composed by many complexes and embedded systems. During the integration testing phase, the design office produces requirements of the targeted system, and the test center produces concrete test procedures to be executed on a test bench. In this context, integration tests are mostly written in natural language and manually executed step by step by a tester. In order to formalize integration tests procedures dedicated to each system with domain specific languages approved by testers, and in order to automatize integration tests, we have introduced agile practices in the integration testing phase. We have chosen a Behavior Driven Development (BDD) approach to orchestrate Domain Specific Test Languages produced for the ACOVAS FUI project.		R. Bussenot; H. Leblanc; C. Percebois	2018 13th Annual Conference on System of Systems Engineering (SoSE)	An airplane is composed by many complexes and embedded systems. During the integration testing phase, the design office produces requirements of the targeted system, and the test center produces concrete test procedures to be executed on a test bench. In this context, integration tests are mostly written in natural language and manually executed step by step by a tester. In order to formalize integration tests procedures dedicated to each system with domain specific languages approved by testers, and in order to automatize integration tests, we have introduced agile practices in the integration testing phase. We have chosen a Behavior Driven Development (BDD) approach to orchestrate Domain Specific Test Languages produced for the ACOVAS FUI project.				Included	Included	new_screen			2						
23	Behave	Android Best Practices	Android Best Practices by Godfrey Nolan shows you how to make your Android apps stand out from the crowd with great reviews. Why settle for just making any Android app? Build a brilliant Android app instead that lets your users praise it for ease of use, better performance, and more. Using a series of example apps which gradually evolve throughout this book, Android Best Practices brings together current Android best practices from user interface (UI)/user experience (UX) design, test-driven development (TDD), and design patterns (e.g., MVC) to help you take your app to the next level. In this book youll learn how to: Use Android design patterns for consistent UI experience on many devices Use agile techniques such as test-driven development, behavior-driven development, and continuous integration Improve the speed and overall performance of your app Organize an Android app using design patterns such as MVC/MVP Create and consume REST and SOAP web servicesDesigning and developing an app that runs well on many if not all the leading Android smartphones and tablets today can be one of the most daunting challenges for Android developers. Well, this book takes much of the mystery out of that for you. After reading and using Android Best Practices, you'll become a much better Android app designer and developer, which in turn can make your apps better placed and more successful in the market place. What youll learn How to use Android design patterns for consistent UI experience on many devicesHow to use Agile techniques such as Test Driven Development, Behavior Driven Development and Continuous Integration How to test Android APKs on many devices and master device fragmentation Secure coding practices on Android How to organize an Android app using design patterns such as MVC/MVP etc. How to create and consume REST and SOAP web services Who this book is for This book is for Android developers looking to solidify their coding and overall app design and development skills.		Nolan, Godfrey; Cinar, Onur; Truxall, David		Android Best Practices by Godfrey Nolan shows you how to make your Android apps stand out from the crowd with great reviews. Why settle for just making any Android app? Build a brilliant Android app instead that lets your users praise it for ease of use, better performance, and more. Using a series of example apps which gradually evolve throughout this book, Android Best Practices brings together current Android best practices from user interface (UI)/user experience (UX) design, test-driven development (TDD), and design patterns (e.g., MVC) to help you take your app to the next level. In this book youll learn how to: Use Android design patterns for consistent UI experience on many devices Use agile techniques such as test-driven development, behavior-driven development, and continuous integration Improve the speed and overall performance of your app Organize an Android app using design patterns such as MVC/MVP Create and consume REST and SOAP web servicesDesigning and developing an app that runs well on many if not all the leading Android smartphones and tablets today can be one of the most daunting challenges for Android developers. Well, this book takes much of the mystery out of that for you. After reading and using Android Best Practices, you'll become a much better Android app designer and developer, which in turn can make your apps better placed and more successful in the market place. What youll learn How to use Android design patterns for consistent UI experience on many devicesHow to use Agile techniques such as Test Driven Development, Behavior Driven Development and Continuous Integration How to test Android APKs on many devices and master device fragmentation Secure coding practices on Android How to organize an Android app using design patterns such as MVC/MVP etc. How to create and consume REST and SOAP web services Who this book is for This book is for Android developers looking to solidify their coding and overall app design and development skills.				Excluded	Excluded	new_screen			2						
24	Behave	Smells in software test code: A survey of knowledge in industry and academia	As a type of anti-pattern, test smells are defined as poorly designed tests and their presence may negatively affect the quality of test suites and production code. Test smells are the subject of active discussions among practitioners and researchers, and various guidelines to handle smells are constantly offered for smell prevention, smell detection, and smell correction. Since there is a vast grey literature as well as a large body of research studies in this domain, it is not practical for practitioners and researchers to locate and synthesize such a large literature. Motivated by the above need and to find out what we, as the community, know about smells in test code, we conducted a ‘multivocal’ literature mapping (classification) on both the scientific literature and also practitioners’ grey literature. By surveying all the sources on test smells in both industry (120 sources) and academia (46 sources), 166 sources in total, our review presents the largest catalogue of test smells, along with the summary of guidelines/techniques and the tools to deal with those smells. This article aims to benefit the readers (both practitioners and researchers) by serving as an “index” to the vast body of knowledge in this important area, and by helping them develop high-quality test scripts, and minimize occurrences of test smells and their negative consequences in large test automation projects.	Software testing, Automated testing, Test automation, Test scripts, Test smells, Test anti-patterns, Multivocal literature mapping, Survey, Systematic mapping	Garousi, Vahid; Küçük, Barış	Journal of Systems and Software	As a type of anti-pattern, test smells are defined as poorly designed tests and their presence may negatively affect the quality of test suites and production code. Test smells are the subject of active discussions among practitioners and researchers, and various guidelines to handle smells are constantly offered for smell prevention, smell detection, and smell correction. Since there is a vast grey literature as well as a large body of research studies in this domain, it is not practical for practitioners and researchers to locate and synthesize such a large literature. Motivated by the above need and to find out what we, as the community, know about smells in test code, we conducted a ‘multivocal’ literature mapping (classification) on both the scientific literature and also practitioners’ grey literature. By surveying all the sources on test smells in both industry (120 sources) and academia (46 sources), 166 sources in total, our review presents the largest catalogue of test smells, along with the summary of guidelines/techniques and the tools to deal with those smells. This article aims to benefit the readers (both practitioners and researchers) by serving as an “index” to the vast body of knowledge in this important area, and by helping them develop high-quality test scripts, and minimize occurrences of test smells and their negative consequences in large test automation projects.				Excluded	Excluded	new_screen			2						
25	Behave	Omni-script: Device independent user interface development for omni-channel fintech applications	As the number of devices and platforms gradually increased that serve as a medium for online banking services, the number of replicated services for different platforms also increase. Each service has a different representation in a different platform even though targeting the same business objectives. This situation results in the problem of re-developing similar set of requirements for different devices and services which in turn results in multiplied effort in software development and degradation in the software quality because of the replicated code. The objective of this paper is to present a device independent user interface development approach that eliminates the replicated user interface development effort of the same set of services for different platforms/devices while increasing the presentation performance. In this context, we provide a basic technique that uses a json based user interface definition format, called omni-script, to separate the representation of banking services in different platforms/devices, so called channels. Omni-script is a pioneering solution being used in a real development environment in banking software domain that is experiencing a shift towards omni-channel user experience, where users are able to seamlessly continue using banking services in different platforms and devices. As the evaluation method, we have measured the actual development effort on a representative sample development team and a set of services. Additionally, we later deployed and measured the rendering time and the amount of data communication for the proposed approach in a real production environment. Production deployment resulted in a remarkable decrease in data communication and in loading times at the client side. As importantly, the proposed approach also resulted in a nearly 75% decrease in service development time by enabling analysts to produce user interface prototypes that can be integrated to service development with minimal effort.	Multimodal user interface definition, Omni-channel user experience, Omni-channel banking services	Ulusoy, Simge; Batıoğlu, Alper; Ovatman, Tolga	Computer Standards & Interfaces	As the number of devices and platforms gradually increased that serve as a medium for online banking services, the number of replicated services for different platforms also increase. Each service has a different representation in a different platform even though targeting the same business objectives. This situation results in the problem of re-developing similar set of requirements for different devices and services which in turn results in multiplied effort in software development and degradation in the software quality because of the replicated code. The objective of this paper is to present a device independent user interface development approach that eliminates the replicated user interface development effort of the same set of services for different platforms/devices while increasing the presentation performance. In this context, we provide a basic technique that uses a json based user interface definition format, called omni-script, to separate the representation of banking services in different platforms/devices, so called channels. Omni-script is a pioneering solution being used in a real development environment in banking software domain that is experiencing a shift towards omni-channel user experience, where users are able to seamlessly continue using banking services in different platforms and devices. As the evaluation method, we have measured the actual development effort on a representative sample development team and a set of services. Additionally, we later deployed and measured the rendering time and the amount of data communication for the proposed approach in a real production environment. Production deployment resulted in a remarkable decrease in data communication and in loading times at the client side. As importantly, the proposed approach also resulted in a nearly 75% decrease in service development time by enabling analysts to produce user interface prototypes that can be integrated to service development with minimal effort.				Excluded	Excluded	new_screen			2						
26	Behave	Validating enterprise architecture using ontology-based approach: A case study of student internship programme	As the practice of Enterprise Architecture (EA) diversifies, the schematic management of its objects, semantics and relationship continues to be complex. Given that EA provides support for the IT environment by simulating alignment between dynamic business architectures, heterogeneous application systems and incongruent technologies, the need to ensure validation of conceptualized EA models has become also critical. As a relatively new discipline, its disparate and widespread methodologies makes it even more challenging to adopt a generic approach in which models can be verified sequel to the unavailability of unified EA modelling languages able to describe a wide range of Information Technology domains. This paper seeks to present an approach for addressing this challenge through the use of ontologies and queries based on constraints specified in the model's motivation taxonomy. The paper is experimental research-based and grounds its hypothesis on initial model created using the ArchiMate modelling language. By transforming its conceptual metamodel into a model instance, a process which can be achieved irrespective of the modeling language used in the design of the EA, it represents extracted triples as resource description framework schema (RDFS) by mapping the model artefacts directly into classes and slots using a more conventional web ontology language. The generated RDF is then queried using Protocol and RDF Query Language (SPARQL) adopting the Behavior Driven Development (BDD) concept. A case study of the Student Internship Program (SIP) is deployed to translate information from business needs to IT solutions encapsulating a view of abstraction of the EA. The paper also proposes an implementation of the approach using an open source platform that allows construction of domain models and knowledge-based applications with ontologies and is a contribution towards effective validation of EA through taxonomy decomposition, systematic generation of testable EA artifacts, creation of structural triples of model elements and alignment of motivational goals to business behavior specifications.	Ontology;Enterprise Architecture;Metamodel;Model;Viewpoints;Resource Description Framework;Schema and Query Language;ArchiMate;Validation	S. Oussena; J. Essien	2013 3rd International Symposium ISKO-Maghreb	As the practice of Enterprise Architecture (EA) diversifies, the schematic management of its objects, semantics and relationship continues to be complex. Given that EA provides support for the IT environment by simulating alignment between dynamic business architectures, heterogeneous application systems and incongruent technologies, the need to ensure validation of conceptualized EA models has become also critical. As a relatively new discipline, its disparate and widespread methodologies makes it even more challenging to adopt a generic approach in which models can be verified sequel to the unavailability of unified EA modelling languages able to describe a wide range of Information Technology domains. This paper seeks to present an approach for addressing this challenge through the use of ontologies and queries based on constraints specified in the model's motivation taxonomy. The paper is experimental research-based and grounds its hypothesis on initial model created using the ArchiMate modelling language. By transforming its conceptual metamodel into a model instance, a process which can be achieved irrespective of the modeling language used in the design of the EA, it represents extracted triples as resource description framework schema (RDFS) by mapping the model artefacts directly into classes and slots using a more conventional web ontology language. The generated RDF is then queried using Protocol and RDF Query Language (SPARQL) adopting the Behavior Driven Development (BDD) concept. A case study of the Student Internship Program (SIP) is deployed to translate information from business needs to IT solutions encapsulating a view of abstraction of the EA. The paper also proposes an implementation of the approach using an open source platform that allows construction of domain models and knowledge-based applications with ontologies and is a contribution towards effective validation of EA through taxonomy decomposition, systematic generation of testable EA artifacts, creation of structural triples of model elements and alignment of motivational goals to business behavior specifications.				Excluded	Excluded	new_screen			2						
27	Behave	Did You Remember To Test Your Tokens?	"Authentication is a critical security feature for confirming the identity of a system's users, typically implemented with help from frameworks like Spring Security. It is a complex feature which should be robustly tested at all stages of development. Unit testing is an effective technique for fine-grained verification of feature behaviors that is not widely-used to test authentication. Part of the problem is that resources to help developers unit test security features are limited. Most security testing guides recommend test cases in a ""black box"" or penetration testing perspective. These resources are not easily applicable to developers writing new unit tests, or who want a security-focused perspective on coverage.In this paper, we address these issues by applying a grounded theory-based approach to identify common (unit) test cases for token authentication through analysis of 481 JUnit tests exercising Spring Security-based authentication implementations from 53 open source Java projects. The outcome of this study is a developer-friendly unit testing guide organized as a catalog of 53 test cases for token authentication, representing unique combinations of 17 scenarios, 40 conditions, and 30 expected outcomes learned from the data set in our analysis. We supplement the test guide with common test smells to avoid. To verify the accuracy and usefulness of our testing guide, we sought feedback from selected developers, some of whom authored unit tests in our dataset."	Unit Test; Java; Authentication; Repository Mining; Security Test	Gonzalez, Danielle; Rath, Michael; Mirakhorli, Mehdi	Proceedings of the 17th International Conference on Mining Software Repositories	"Authentication is a critical security feature for confirming the identity of a system's users, typically implemented with help from frameworks like Spring Security. It is a complex feature which should be robustly tested at all stages of development. Unit testing is an effective technique for fine-grained verification of feature behaviors that is not widely-used to test authentication. Part of the problem is that resources to help developers unit test security features are limited. Most security testing guides recommend test cases in a ""black box"" or penetration testing perspective. These resources are not easily applicable to developers writing new unit tests, or who want a security-focused perspective on coverage.In this paper, we address these issues by applying a grounded theory-based approach to identify common (unit) test cases for token authentication through analysis of 481 JUnit tests exercising Spring Security-based authentication implementations from 53 open source Java projects. The outcome of this study is a developer-friendly unit testing guide organized as a catalog of 53 test cases for token authentication, representing unique combinations of 17 scenarios, 40 conditions, and 30 expected outcomes learned from the data set in our analysis. We supplement the test guide with common test smells to avoid. To verify the accuracy and usefulness of our testing guide, we sought feedback from selected developers, some of whom authored unit tests in our dataset."				Excluded	Excluded	new_screen			2						
28	Behave	XUnit Test Patterns: Refactoring Test Code	"Automated testing is a cornerstone of agile development. An effective testing strategy will deliver new functionality more aggressively, accelerate user feedback, and improve quality. However, for many developers, creating effective automated tests is a unique and unfamiliar challenge.xUnit Test Patterns is the definitive guide to writing automated tests using xUnit, the most popular unit testing framework in use today. Agile coach and test automation expert Gerard Meszaros describes 68 proven patterns for making tests easier to write, understand, and maintain. He then shows you how to make them more robust and repeatable–and far more cost-effective.Loaded with information, this book feels like three books in one. The first part is a detailed tutorial on test automation that covers everything from test strategy to in-depth test coding. The second part, a catalog of 18 frequently encountered ""test smells,"" provides trouble-shooting guidelines to help you determine the root cause of problems and the most applicable patterns. The third part contains detailed descriptions of each pattern, including refactoring instructions illustrated by extensive code samples in multiple programming languages.Topics covered include Writing better tests–and writing them faster The four phases of automated tests: fixture setup, exercising the system under test, result verification, and fixture teardown Improving test coverage by isolating software from its environment using Test Stubs and Mock Objects Designing software for greater testability Using test ""smells"" (including code smells, behavior smells, and project smells) to spot problems and know when and how to eliminate them Refactoring tests for greater simplicity, robustness, and execution speedThis book will benefit developers, managers, and testers working with any agile or conventional development process, whether doing test-driven development or writing the tests last. While the patterns and smells are especially applicable to all members of the xUnit family, they also apply to next-generation behavior-driven development frameworks such as RSpec and JBehave and to other kinds of test automation tools, including recorded test tools and data-driven test tools such as Fit and FitNesse.Visual Summary of the Pattern Languageï Foreword Preface Acknowledgments Introduction Refactoring a TestPART I: The Narratives Chapter 1 A Brief Tour Chapter 2 Test Smells Chapter 3 Goals of Test Automation Chapter 4 Philosophy of Test Automation Chapter 5 Principles of Test Automation Chapter 6 Test Automation Strategy Chapter 7 xUnit Basics Chapter 8 Transient Fixture Management Chapter 9 Persistent Fixture Management Chapter 10 Result Verification Chapter 11 Using Test Doubles Chapter 12 Organizing Our Tests Chapter 13 Testing with Databases Chapter 14 A Roadmap to Effective Test Automation PART II: The Test Smellsï Chapter 15 Code Smells Chapter 16 Behavior Smells Chapter 17 Project Smells PART III: The Patternsï Chapter 18 Test Strategy Patterns Chapter 19 xUnit Basics Patterns Chapter 20 Fixture Setup Patterns Chapter 21 Result Verification Patterns Chapter 22 Fixture Teardown Patterns Chapter 23 Test Double Patterns Chapter 24 Test Organization Patterns Chapter 25 Database Patterns Chapter 26 Design-for-Testability Patterns Chapter 27 Value Patterns PART IV: Appendixes Appendix A Test Refactorings ï Appendix B xUnit Terminologyï Appendix C xUnit Family Members Appendix D Tools Appendix E Goals and Principles Appendix F Smells, Aliases, and Causes Appendix G Patterns, Aliases, and Variations Glossary Referencesï Indexï"		Meszaros, Gerard		"Automated testing is a cornerstone of agile development. An effective testing strategy will deliver new functionality more aggressively, accelerate user feedback, and improve quality. However, for many developers, creating effective automated tests is a unique and unfamiliar challenge.xUnit Test Patterns is the definitive guide to writing automated tests using xUnit, the most popular unit testing framework in use today. Agile coach and test automation expert Gerard Meszaros describes 68 proven patterns for making tests easier to write, understand, and maintain. He then shows you how to make them more robust and repeatable–and far more cost-effective.Loaded with information, this book feels like three books in one. The first part is a detailed tutorial on test automation that covers everything from test strategy to in-depth test coding. The second part, a catalog of 18 frequently encountered ""test smells,"" provides trouble-shooting guidelines to help you determine the root cause of problems and the most applicable patterns. The third part contains detailed descriptions of each pattern, including refactoring instructions illustrated by extensive code samples in multiple programming languages.Topics covered include Writing better tests–and writing them faster The four phases of automated tests: fixture setup, exercising the system under test, result verification, and fixture teardown Improving test coverage by isolating software from its environment using Test Stubs and Mock Objects Designing software for greater testability Using test ""smells"" (including code smells, behavior smells, and project smells) to spot problems and know when and how to eliminate them Refactoring tests for greater simplicity, robustness, and execution speedThis book will benefit developers, managers, and testers working with any agile or conventional development process, whether doing test-driven development or writing the tests last. While the patterns and smells are especially applicable to all members of the xUnit family, they also apply to next-generation behavior-driven development frameworks such as RSpec and JBehave and to other kinds of test automation tools, including recorded test tools and data-driven test tools such as Fit and FitNesse.Visual Summary of the Pattern Languageï Foreword Preface Acknowledgments Introduction Refactoring a TestPART I: The Narratives Chapter 1 A Brief Tour Chapter 2 Test Smells Chapter 3 Goals of Test Automation Chapter 4 Philosophy of Test Automation Chapter 5 Principles of Test Automation Chapter 6 Test Automation Strategy Chapter 7 xUnit Basics Chapter 8 Transient Fixture Management Chapter 9 Persistent Fixture Management Chapter 10 Result Verification Chapter 11 Using Test Doubles Chapter 12 Organizing Our Tests Chapter 13 Testing with Databases Chapter 14 A Roadmap to Effective Test Automation PART II: The Test Smellsï Chapter 15 Code Smells Chapter 16 Behavior Smells Chapter 17 Project Smells PART III: The Patternsï Chapter 18 Test Strategy Patterns Chapter 19 xUnit Basics Patterns Chapter 20 Fixture Setup Patterns Chapter 21 Result Verification Patterns Chapter 22 Fixture Teardown Patterns Chapter 23 Test Double Patterns Chapter 24 Test Organization Patterns Chapter 25 Database Patterns Chapter 26 Design-for-Testability Patterns Chapter 27 Value Patterns PART IV: Appendixes Appendix A Test Refactorings ï Appendix B xUnit Terminologyï Appendix C xUnit Family Members Appendix D Tools Appendix E Goals and Principles Appendix F Smells, Aliases, and Causes Appendix G Patterns, Aliases, and Variations Glossary Referencesï Indexï"				Excluded	Excluded	new_screen			2						
29	Behave	Visualizing data, encouraging change: Technical interventions in food purchasing	Baked Potato is a mobile web service geared at addressing the imbalance of power between those who market and those who consume food products. Food marketers rarely provide a detailed range of information about products that would allow consumers to understand how a product and its company connect to their cultural values. The main goal of this application is to connect people in a way that celebrates their differences and gives them agency by helping them make better decisions about their food purchases.	Behavior Driven Development;decision making;human-computer interaction;incentive design;social gaming	D. J. Sackey; N. Ullmann	2012 IEEE International Professional Communication Conference	Baked Potato is a mobile web service geared at addressing the imbalance of power between those who market and those who consume food products. Food marketers rarely provide a detailed range of information about products that would allow consumers to understand how a product and its company connect to their cultural values. The main goal of this application is to connect people in a way that celebrates their differences and gives them agency by helping them make better decisions about their food purchases.				Excluded	Excluded	new_screen			2						
30	Behave	Visualizing data, encouraging change: Technical interventions in food purchasing	Baked Potato is a mobile web service geared at addressing the imbalance of power between those who market and those who consume food products. Food marketers rarely provide a detailed range of information about products that would allow consumers to understand how a product and its company connect to their cultural values. The main goal of this application is to connect people in a way that celebrates their differences and gives them agency by helping them make better decisions about their food purchases. © 2012 IEEE.		Sackey D.J., Ullmann N.	IEEE International Professional Communication Conference	Baked Potato is a mobile web service geared at addressing the imbalance of power between those who market and those who consume food products. Food marketers rarely provide a detailed range of information about products that would allow consumers to understand how a product and its company connect to their cultural values. The main goal of this application is to connect people in a way that celebrates their differences and gives them agency by helping them make better decisions about their food purchases. © 2012 IEEE.				Excluded	Excluded	new_screen			2						
31	Behave	Behavior driven development for airborne software engineering	Behavior Driven Development (BDD) is a test driven development approach which aims at bridging the gap between the end-user and the software development. It promotes a semi-formal ubiquitous language for executable behavior specification and automated acceptance testing. The BDD infrastructure Cucumber and the language Gherkin have been established in many application domains. This paper discusses their utilization for airborne software engineering with an example application, Class C Terrain Awareness and Warning System, being developed using Rust language with Rust BDD infrastructure. © 2021, American Institute of Aeronautics and Astronautics Inc, AIAA. All rights reserved.		Zaeske W., Beck J., Torrens C., Durak U.	AIAA Scitech 2021 Forum	Behavior Driven Development (BDD) is a test driven development approach which aims at bridging the gap between the end-user and the software development. It promotes a semi-formal ubiquitous language for executable behavior specification and automated acceptance testing. The BDD infrastructure Cucumber and the language Gherkin have been established in many application domains. This paper discusses their utilization for airborne software engineering with an example application, Class C Terrain Awareness and Warning System, being developed using Rust language with Rust BDD infrastructure. © 2021, American Institute of Aeronautics and Astronautics Inc, AIAA. All rights reserved.				Included	Included	new_screen			2						
32	Behave	Predicting Co-Changes between Functionality Specifications and Source Code in Behavior Driven Development	Behavior Driven Development (BDD) is an agile approach that uses .feature files to describe the functionalities of a software system using natural language constructs (English-like phrases). Because of the English-like structure of .feature files, BDD specifications become an evolving documentation that helps all (even non-technical) stakeholders to understand and contribute to a software project. After specifying a .feature files, developers can use a BDD tool (e.g., Cucumber) to automatically generate test cases and implement the code of the specified functionality. However, maintaining traceability between .feature files and source code requires human efforts. Therefore, .feature files can be out-of-date, reducing the advantages of using BDD. Furthermore, existing research do not attempt to improve the traceability between .feature files and source code files. In this paper, we study the co-changes between .feature files and source code files to improve the traceability between .feature files and source code files. Due to the English-like syntax of .feature files, we use natural language processing to identify co-changes, with an accuracy of 79%. We study the characteristics of BDD co-changes and build random forest models to predict when a .feature files should be modified before committing a code change. The random forest model obtains an AUC of 0.77. The model can assist developers in identifying when a .feature files should be modified in code commits. Once the traceability is up-to-date, BDD developers can write test code more efficiently and keep the software documentation up-to-date.	behavior driven development; co-changes; empirical software engineering; traceability	Yang, Aidan Z. H.; da Costa, Daniel Alencar; Zou, Ying	Proceedings of the 16th International Conference on Mining Software Repositories	Behavior Driven Development (BDD) is an agile approach that uses .feature files to describe the functionalities of a software system using natural language constructs (English-like phrases). Because of the English-like structure of .feature files, BDD specifications become an evolving documentation that helps all (even non-technical) stakeholders to understand and contribute to a software project. After specifying a .feature files, developers can use a BDD tool (e.g., Cucumber) to automatically generate test cases and implement the code of the specified functionality. However, maintaining traceability between .feature files and source code requires human efforts. Therefore, .feature files can be out-of-date, reducing the advantages of using BDD. Furthermore, existing research do not attempt to improve the traceability between .feature files and source code files. In this paper, we study the co-changes between .feature files and source code files to improve the traceability between .feature files and source code files. Due to the English-like syntax of .feature files, we use natural language processing to identify co-changes, with an accuracy of 79%. We study the characteristics of BDD co-changes and build random forest models to predict when a .feature files should be modified before committing a code change. The random forest model obtains an AUC of 0.77. The model can assist developers in identifying when a .feature files should be modified in code commits. Once the traceability is up-to-date, BDD developers can write test code more efficiently and keep the software documentation up-to-date.				Included	Included	new_screen			2						
33	Behave	Theoretical Verification of Test Cases for Behavior Driven Development	Behavior Driven Development insists on generation of early test cases during requirements elicitation. These would form the basis for pseudo use cases in TDD. These early test cases for BDD, aka theoretical test cases, are developed using Named Entity Recognition approaches over expanded use cases. This paper proposes the algorithm for theoretical verification of obtaining the original reduced use case sequences from the obtained BDD test cases.	Reduced UC Sequence;Test cases;Usecase Dependency Graph	G. S. Mahalakshmi; V. Vani	2017 Second International Conference on Recent Trends and Challenges in Computational Models (ICRTCCM)	Behavior Driven Development insists on generation of early test cases during requirements elicitation. These would form the basis for pseudo use cases in TDD. These early test cases for BDD, aka theoretical test cases, are developed using Named Entity Recognition approaches over expanded use cases. This paper proposes the algorithm for theoretical verification of obtaining the original reduced use case sequences from the obtained BDD test cases.				Included	Included	new_screen			2						
34	Behave	A Model-Driven Approach for Behavior-Driven GUI Testing	Behavior-driven development (BDD) brings requirement specifications and their test cases closer together by using a ubiquitous language to describe requirements that are automatically mapped to test methods. Although industry-proven tools support this automated requirement mapping, the test methods need to be implemented manually. The approach presented in this paper transforms BDD-like requirement specifications and low fidelity graphical user interface (GUI) descriptions in the format of wireframes into automatically executable graphical user interface test cases. The requirement descriptions are defined in a domain-specific language (DSL) that obeys the rules of the ubiquitous language enhanced by references to screens and widgets in a graphical user interface model. The paper reports on a controlled AB/BA crossover experiment comparing the efficiency of our approach to the industry-proven JBehave tooling. The results show that the introduced approach on average takes 63% less time to specify automated tests and thereby diminishes the problem of graphical user interface test cases being expensive to write. The experimental results were supported by experience made applying the approach in three differently sized components at a large Swiss bank.	behavior-driven development; domain-specific language; GUI test case generation; model-driven engineering	Bünder, Hendrik; Kuchen, Herbert	Proceedings of the 34th ACM/SIGAPP Symposium on Applied Computing	Behavior-driven development (BDD) brings requirement specifications and their test cases closer together by using a ubiquitous language to describe requirements that are automatically mapped to test methods. Although industry-proven tools support this automated requirement mapping, the test methods need to be implemented manually. The approach presented in this paper transforms BDD-like requirement specifications and low fidelity graphical user interface (GUI) descriptions in the format of wireframes into automatically executable graphical user interface test cases. The requirement descriptions are defined in a domain-specific language (DSL) that obeys the rules of the ubiquitous language enhanced by references to screens and widgets in a graphical user interface model. The paper reports on a controlled AB/BA crossover experiment comparing the efficiency of our approach to the industry-proven JBehave tooling. The results show that the introduced approach on average takes 63% less time to specify automated tests and thereby diminishes the problem of graphical user interface test cases being expensive to write. The experimental results were supported by experience made applying the approach in three differently sized components at a large Swiss bank.				Included	Included	new_screen			2						
35	Behave	Evaluating the usage of predefined interactive behaviors for writing user stories: an empirical study with potential product owners	Behavior-driven development (BDD) has gained popularity in agile software development as a means of specifying user requirements through user stories and scenarios for interactive systems under construction. Templates for guiding the writing of such stories are widely employed and can be helpful to ensure that consistent information about the requirements is provided. With the aim of getting preliminary results about how product owners (POs) write their own user stories under a predefined template, we conducted a case study with potential POs at the department in charge of business trips in a French research institute. The participants were invited to write their own user stories to describe a feature they are used to perform. The resultant stories have been analyzed to check their adherence to a template including common interactive behaviors defined by an ontology for interactive systems. Although the participants have followed different specification strategies, we observed an overall high level of adherence to the proposed template (62.26%). The results also pointed out to a wide use of domain-dependent behaviors, with the interactive behaviors defined by the ontology being, to some extent, reproduced by the participants even without prior training in the adopted vocabulary. © 2019, Springer-Verlag London Ltd., part of Springer Nature.		Rocha Silva T., Winckler M., Bach C.	Cognition, Technology and Work	Behavior-driven development (BDD) has gained popularity in agile software development as a means of specifying user requirements through user stories and scenarios for interactive systems under construction. Templates for guiding the writing of such stories are widely employed and can be helpful to ensure that consistent information about the requirements is provided. With the aim of getting preliminary results about how product owners (POs) write their own user stories under a predefined template, we conducted a case study with potential POs at the department in charge of business trips in a French research institute. The participants were invited to write their own user stories to describe a feature they are used to perform. The resultant stories have been analyzed to check their adherence to a template including common interactive behaviors defined by an ontology for interactive systems. Although the participants have followed different specification strategies, we observed an overall high level of adherence to the proposed template (62.26%). The results also pointed out to a wide use of domain-dependent behaviors, with the interactive behaviors defined by the ontology being, to some extent, reproduced by the participants even without prior training in the adopted vocabulary. © 2019, Springer-Verlag London Ltd., part of Springer Nature.				Included	Included	new_screen			2						
36	Behave	On the Empirical Evaluation of BDD Scenarios Quality: Preliminary Findings of an Empirical Study	"Behavior-Driven Development (BDD) is a set of software engineering practices which uses a ubiquitous language, one that business and technical people can understand, to describe and model a system by a series of textual scenarios. However, we believe that the value of those textual scenarios is connected with how well they convey and document the details discussed by the team about the behaviors needed to fulfill customer needs. Thus, there is the need to define what would be a ""good"" BDD scenario and how to evaluate scenarios. On this research design paper, we describe a study designed to understand how known quality attributes from other types of requirements specifications (like use cases or user stories) can be used with BDD scenarios. We also report our preliminary findings after performing it with novice evaluators. Those findings indicate that some of those attributes can be used to support BDD scenarios assessments."	documentation quality;documentation evaluation;behavior-driven development;empirical study	G. Oliveira; S. Marczak	2017 IEEE 25th International Requirements Engineering Conference Workshops (REW)	"Behavior-Driven Development (BDD) is a set of software engineering practices which uses a ubiquitous language, one that business and technical people can understand, to describe and model a system by a series of textual scenarios. However, we believe that the value of those textual scenarios is connected with how well they convey and document the details discussed by the team about the behaviors needed to fulfill customer needs. Thus, there is the need to define what would be a ""good"" BDD scenario and how to evaluate scenarios. On this research design paper, we describe a study designed to understand how known quality attributes from other types of requirements specifications (like use cases or user stories) can be used with BDD scenarios. We also report our preliminary findings after performing it with novice evaluators. Those findings indicate that some of those attributes can be used to support BDD scenarios assessments."				Included	Included	new_screen			2						
37	Behave	On the Applicability of BDD in a Business Intelligence Project: Experience Report	Behavior-driven development (BDD) is a software development technique that in order to succeed relies heavily on the definition of clear acceptance criteria by software developers in the form of behavioral scenarios, later translated into acceptance tests. The adoption of BDD in Business Intelligence (BI) projects requires developers to have a broad acquaintance to business that often even customers themselves do not possess. This article presents an experience report on the use of BDD in the development of a large public health related BI project. Experience suggests that the use of BDD may not be appropriate for BI projects, especially during the early stages of development, when there is still insufficient clarity about business acceptance criteria. The need for broad maturity towards business understanding makes it complex to adopt the behavioral approach within the development process in projects of this nature.	behavior-driven development; business intelligence.; Software quality	Mello, Patrícia; Ximenes, Pablo; Lemos, Rousiany; Bessa, Ana Luíza; Cortés, Mariela I.; Rocha, Cleilton Lima	Proceedings of the 17th Brazilian Symposium on Software Quality	Behavior-driven development (BDD) is a software development technique that in order to succeed relies heavily on the definition of clear acceptance criteria by software developers in the form of behavioral scenarios, later translated into acceptance tests. The adoption of BDD in Business Intelligence (BI) projects requires developers to have a broad acquaintance to business that often even customers themselves do not possess. This article presents an experience report on the use of BDD in the development of a large public health related BI project. Experience suggests that the use of BDD may not be appropriate for BI projects, especially during the early stages of development, when there is still insufficient clarity about business acceptance criteria. The need for broad maturity towards business understanding makes it complex to adopt the behavioral approach within the development process in projects of this nature.				Included	Included	new_screen			2						
38	Behave	BHive: Behavior-Driven development meets B-Method	Behavior-Driven Development (BDD) is an “outside-in” approach to software development built upon semi-formal mediums for specifying the behavior of a system as it would be observed externally. Through the representation of a system as a collection of user stories and scenarios using BDD’s notation, practitioners automate acceptance tests using examples of desired behavior for the envisioned system. A formal model created in concert with BDD tests would provide valuable insight into test validity and enhance the visibility of the problem domain. This work called BHive builds upon the formal underpinnings of BDD scenarios by mapping their “Given,” “When,” and “Then” statements to “Precondition,” “Command,” and “Postcondition” constructs as introduced by Floyd-Hoare logic. We posit that this mapping allows for a B-Method representation to be created and that such a model is useful for exploring system behavior and exposing gaps in requirements and test plans. In this extension of previous work, we outline recent additions to BDD tooling required for the described integration, present a new strategy for test case generation from our approach, and expand on the benefits of the BHive approach to integrating formalism within a BDD project. © 2018, Springer International Publishing AG.		Carter J.D., Gardner W.B.	Advances in Intelligent Systems and Computing	Behavior-Driven Development (BDD) is an “outside-in” approach to software development built upon semi-formal mediums for specifying the behavior of a system as it would be observed externally. Through the representation of a system as a collection of user stories and scenarios using BDD’s notation, practitioners automate acceptance tests using examples of desired behavior for the envisioned system. A formal model created in concert with BDD tests would provide valuable insight into test validity and enhance the visibility of the problem domain. This work called BHive builds upon the formal underpinnings of BDD scenarios by mapping their “Given,” “When,” and “Then” statements to “Precondition,” “Command,” and “Postcondition” constructs as introduced by Floyd-Hoare logic. We posit that this mapping allows for a B-Method representation to be created and that such a model is useful for exploring system behavior and exposing gaps in requirements and test plans. In this extension of previous work, we outline recent additions to BDD tooling required for the described integration, present a new strategy for test case generation from our approach, and expand on the benefits of the BHive approach to integrating formalism within a BDD project. © 2018, Springer International Publishing AG.				Included	Included	new_screen			2						
39	Behave	Automatically generating tests from natural language descriptions of software behavior	"Behavior-Driven Development (BDD) is an emerging agile development approach where all stakeholders (including developers and customers) work together to write user stories in structured natural language to capture a software application's functionality in terms of required ""behaviors."" Developers can then manually write ""glue"" code so that these scenarios can be translated into executable software tests. This glue code represents individual steps within unit and acceptance test cases, and tools exist that automate the mapping from scenario descriptions to manually written code steps (typically using regular expressions). This paper takes the position that, instead of requiring programmers to write manual glue code, it is practical to convert natural language scenario descriptions into executable software tests fully automatically. To show feasibility, this paper presents preliminary results from a tool called Kirby that uses natural language processing techniques to automatically generate executable software tests from structured English scenario descriptions. Kirby relieves the developer from the laborious work of writing code for the individual steps described in scenarios, so that both developers and customers can both focus on the scenarios as pure behavior descriptions (understandable to all, not just programmers). Preliminary results from assessing the performance and accuracy of this technique are presented. Copyright © 2013 SCITEPRESS."		Kamalakar S., Edwards S.H., Dao T.M.	ENASE 2013 - Proceedings of the 8th International Conference on Evaluation of Novel Approaches to Software Engineering	"Behavior-Driven Development (BDD) is an emerging agile development approach where all stakeholders (including developers and customers) work together to write user stories in structured natural language to capture a software application's functionality in terms of required ""behaviors."" Developers can then manually write ""glue"" code so that these scenarios can be translated into executable software tests. This glue code represents individual steps within unit and acceptance test cases, and tools exist that automate the mapping from scenario descriptions to manually written code steps (typically using regular expressions). This paper takes the position that, instead of requiring programmers to write manual glue code, it is practical to convert natural language scenario descriptions into executable software tests fully automatically. To show feasibility, this paper presents preliminary results from a tool called Kirby that uses natural language processing techniques to automatically generate executable software tests from structured English scenario descriptions. Kirby relieves the developer from the laborious work of writing code for the individual steps described in scenarios, so that both developers and customers can both focus on the scenarios as pure behavior descriptions (understandable to all, not just programmers). Preliminary results from assessing the performance and accuracy of this technique are presented. Copyright © 2013 SCITEPRESS."				Included	Included	new_screen			2						
40	Behave	On the Understanding of How to Measure the Benefits of Behavior-Driven Development Adoption: Preliminary Literature Results from a Grey Literature Study	Behavior-Driven Development (BDD) is the integration of a ubiquitous language with Test-Driven Development and Automated Testing. From this integration, BDD supports software teams to build and deliver software. Although the perceived arguments of better results and of a more efficient development process, we still have no consolidated evidence of such benefits and how to measure them. Therefore, this long-term research aims to characterize how BDD adoption benefits can be measured. To do so, our research design includes a Multivocal Literature Review, composed of a Grey Literature to explore how industry tackles the topic and a Systematic Review to gather scientific evidences, followed of a Snowballing Review to supplement the search. Next, we will conduct empirical studies to characterize the topic from practice. This paper introduces our research and presents the results from our exploratory Grey Literature. We learned from these preliminary results that there are no models or frameworks defined to measure BDD adoption benefits but that teams indeed perceive improvements in software quality, communication, rework rates, among others. We also found that these teams also perceive that team engagement improves with the adoption of BDD and that although there is a certain cost (e.g., time and financial) involved, the investment pays off in the end. These results will inform the design of our Systematic Review and of our downstream empirical studies.	Behavior-Driven Development; BDD Adoption; Benefits; Grey Literature Review; Quality Measurement	Couto, Thiciane; Marczak, Sabrina; Gomes, Fabio	19th Brazilian Symposium on Software Quality	Behavior-Driven Development (BDD) is the integration of a ubiquitous language with Test-Driven Development and Automated Testing. From this integration, BDD supports software teams to build and deliver software. Although the perceived arguments of better results and of a more efficient development process, we still have no consolidated evidence of such benefits and how to measure them. Therefore, this long-term research aims to characterize how BDD adoption benefits can be measured. To do so, our research design includes a Multivocal Literature Review, composed of a Grey Literature to explore how industry tackles the topic and a Systematic Review to gather scientific evidences, followed of a Snowballing Review to supplement the search. Next, we will conduct empirical studies to characterize the topic from practice. This paper introduces our research and presents the results from our exploratory Grey Literature. We learned from these preliminary results that there are no models or frameworks defined to measure BDD adoption benefits but that teams indeed perceive improvements in software quality, communication, rework rates, among others. We also found that these teams also perceive that team engagement improves with the adoption of BDD and that although there is a certain cost (e.g., time and financial) involved, the investment pays off in the end. These results will inform the design of our Systematic Review and of our downstream empirical studies.				Excluded	Excluded	new_screen			2						
41	Behave	Behavior-Driven Development: Conference Tutorial	Behavior-driven development is a software development technique in which system behaviors are determined and made into test cases before the software itself is written. Benefits can include a richer and deeper understanding of system requirements in addition to making these requirements executable. Moreover, this technique helps guide software developers in knowing what to test as well as knowing how much to test. In this tutorial, we introduce the fundamentals of this approach, a language for expressing system behaviors, and explain how to use this technique effectively in the undergraduate computer science curriculum.		Kart, Michael	J. Comput. Sci. Coll.	Behavior-driven development is a software development technique in which system behaviors are determined and made into test cases before the software itself is written. Benefits can include a richer and deeper understanding of system requirements in addition to making these requirements executable. Moreover, this technique helps guide software developers in knowing what to test as well as knowing how much to test. In this tutorial, we introduce the fundamentals of this approach, a language for expressing system behaviors, and explain how to use this technique effectively in the undergraduate computer science curriculum.				Excluded	Excluded	new_screen			2						
42	Behave	A Study of the Characteristics of Behaviour Driven Development	Behaviour Driven Development (BDD) has gained increasing attention as an agile development approach in recent years. However, characteristics that constituite the BDD approach are not clearly defined. In this paper, we present a set of main BDD charactersitics identified through an analysis of relevant literature and current BDD toolkits. Our study can provide a basis for understanding BDD, as well as for extending the exisiting BDD toolkits or developing new ones.	Automated Acceptance Testing; Behaviour Driven Development; Test Driven Development; Ubiquitous Language	Solis, Carlos; Wang, Xiaofeng	Proceedings of the 2011 37th EUROMICRO Conference on Software Engineering and Advanced Applications	Behaviour Driven Development (BDD) has gained increasing attention as an agile development approach in recent years. However, characteristics that constituite the BDD approach are not clearly defined. In this paper, we present a set of main BDD charactersitics identified through an analysis of relevant literature and current BDD toolkits. Our study can provide a basis for understanding BDD, as well as for extending the exisiting BDD toolkits or developing new ones.				Included	Included	new_screen			2						
43	Behave	Behave nicely! automatic generation of code for behaviour driven development test suites	Behaviour driven development (BDD) has gained widespread use in the software industry. System specifications can be expressed as test scenarios, describing the circumstances, actions and expected outcomes. These scenarios are written in a structured natural language (Gherkin), with each step in the scenario associated with a corresponding step implementation function in the underlying programming language. A challenge recognised by industry is ensuring that the natural language scenarios, step implementation functions and underlying system implementation remain consistent with one another, requiring on-going maintenance effort as changes are made to a system. To address this, we have developed behave-nicely, a tool, for automatically generating step implementation functions from structured natural language steps, with the intention of eliminating the need for maintaining step implementation functions. We evaluated our approach on a sample of 20 white box and 50 black box projects using behaviour driven development, drawn from GitHub. Our results show that behave-nicely can generate step implementation functions for 80% of the white box and 17% of black box projects. We conclude that (a) there is significant potential for automating the process of code generation for BDD tests and (b) that the development of guidelines for writing tests in Gherkin would significantly improve the results. © 2019 IEEE.		Storer T., Bob R.	Proceedings - 19th IEEE International Working Conference on Source Code Analysis and Manipulation, SCAM 2019	Behaviour driven development (BDD) has gained widespread use in the software industry. System specifications can be expressed as test scenarios, describing the circumstances, actions and expected outcomes. These scenarios are written in a structured natural language (Gherkin), with each step in the scenario associated with a corresponding step implementation function in the underlying programming language. A challenge recognised by industry is ensuring that the natural language scenarios, step implementation functions and underlying system implementation remain consistent with one another, requiring on-going maintenance effort as changes are made to a system. To address this, we have developed behave-nicely, a tool, for automatically generating step implementation functions from structured natural language steps, with the intention of eliminating the need for maintaining step implementation functions. We evaluated our approach on a sample of 20 white box and 50 black box projects using behaviour driven development, drawn from GitHub. Our results show that behave-nicely can generate step implementation functions for 80% of the white box and 17% of black box projects. We conclude that (a) there is significant potential for automating the process of code generation for BDD tests and (b) that the development of guidelines for writing tests in Gherkin would significantly improve the results. © 2019 IEEE.				Included	Included	new_screen			2						
44	Behave	Characterising the Quality of Behaviour Driven Development Specifications	Behaviour Driven Development (BDD) is an agile testing technique that enables software requirements to be specified as example interactions with the system, using structured natural language. While (in theory) being readable by non-technical stakeholders, the examples can also be executed against the code base to identify behaviours that are not yet correctly implemented. Writing good BDD suites, however, is challenging. A typical suite can contain hundreds of individual scenarios, that must correctly specify the system as a whole as well as individually. Despite much discussion amongst practitioners and in the blogosphere, as yet no formal definition of what makes for a high quality BDD suite has been given. To shed light on this, we surveyed BDD practitioners, asking for their opinions on the quality criteria that are important for BDD suites. We proposed, and asked for opinions on, four quality principles, and gave practitioners the option to add more principles of their own. This paper reports on the results of the survey, and presents an approach to defining BDD suite quality. © The Author(s) 2020.		Binamungu L.P., Embury S.M., Konstantinou N.	Lecture Notes in Business Information Processing	Behaviour Driven Development (BDD) is an agile testing technique that enables software requirements to be specified as example interactions with the system, using structured natural language. While (in theory) being readable by non-technical stakeholders, the examples can also be executed against the code base to identify behaviours that are not yet correctly implemented. Writing good BDD suites, however, is challenging. A typical suite can contain hundreds of individual scenarios, that must correctly specify the system as a whole as well as individually. Despite much discussion amongst practitioners and in the blogosphere, as yet no formal definition of what makes for a high quality BDD suite has been given. To shed light on this, we surveyed BDD practitioners, asking for their opinions on the quality criteria that are important for BDD suites. We proposed, and asked for opinions on, four quality principles, and gave practitioners the option to add more principles of their own. This paper reports on the results of the survey, and presents an approach to defining BDD suite quality. © The Author(s) 2020.				Included	Included	new_screen			2						
45	Behave	Behaviour-Driven Development of Foundational UML Components	Behaviour-Driven Development (BDD) focuses all development activities on the delivery of behaviours - what a system should do, described such that developers and domain experts speak the same language. BDD frameworks allow users to represent the required system behaviour as executable user stories and the acceptance criteria as executable scenarios attached to user stories. In this paper we define a UML profile that allows users to create executable Foundational UML (fUML) stories and scenarios. In order to easily construct scenarios we introduce a BDD model library which contains fUML activities for testing equalities and inclusions. We also present an Eclipse-based development tool that supports a BDD approach for developing fUML components. The tool provides developers a concrete syntax for defining executable scenarios, and automatically updates the project status based on verified delivered behaviorus.	acceptance criteria; behaviour-driven development; executable specification; executable UML; user story	Lazr, Ioan; Motogna, Simona; Pírv, Bazil	Electron. Notes Theor. Comput. Sci.	Behaviour-Driven Development (BDD) focuses all development activities on the delivery of behaviours - what a system should do, described such that developers and domain experts speak the same language. BDD frameworks allow users to represent the required system behaviour as executable user stories and the acceptance criteria as executable scenarios attached to user stories. In this paper we define a UML profile that allows users to create executable Foundational UML (fUML) stories and scenarios. In order to easily construct scenarios we introduce a BDD model library which contains fUML activities for testing equalities and inclusions. We also present an Eclipse-based development tool that supports a BDD approach for developing fUML components. The tool provides developers a concrete syntax for defining executable scenarios, and automatically updates the project status based on verified delivered behaviorus.				Included	Included	new_screen			2						
46	Behave	BHive: Towards Behaviour-Driven Development Supported by B-Method	"Behaviour-Driven Development (BDD) is an ""outside-in"" approach to software development built upon semi-formal mediums for specifying the behaviour of a system as it would be observed externally. Through the representation of a system as a collection of user stories and scenarios using BDD's notation, practitioners automate acceptance tests using examples of desired behaviour for the envisioned system. A formal model created in concert with BDD tests would provide valuable insight into test validity and enhance the visibility of the problem domain. This work called BHive builds upon the formal underpinnings of BDD scenarios by mapping their ""Given,"" ""When,"" and ""Then"" statements to ""Precondition,"" ""Command,"" and ""Postcondition"" constructs as introduced by Floyd-Hoare logic. We posit that this mapping allows for a B-Method representation to be created and that such a model is useful for exploring system behaviour and exposing gaps in requirements. We also outline extensions to BDD tooling required for the described integration and present benefits of the BHive approach to integrating formalism within a BDD project."		Carter, J.; Gardner, W. B.	2016 IEEE 17th International Conference on Information Reuse and Integration (IRI)	"Behaviour-Driven Development (BDD) is an ""outside-in"" approach to software development built upon semi-formal mediums for specifying the behaviour of a system as it would be observed externally. Through the representation of a system as a collection of user stories and scenarios using BDD's notation, practitioners automate acceptance tests using examples of desired behaviour for the envisioned system. A formal model created in concert with BDD tests would provide valuable insight into test validity and enhance the visibility of the problem domain. This work called BHive builds upon the formal underpinnings of BDD scenarios by mapping their ""Given,"" ""When,"" and ""Then"" statements to ""Precondition,"" ""Command,"" and ""Postcondition"" constructs as introduced by Floyd-Hoare logic. We posit that this mapping allows for a B-Method representation to be created and that such a model is useful for exploring system behaviour and exposing gaps in requirements. We also outline extensions to BDD tooling required for the described integration and present benefits of the BHive approach to integrating formalism within a BDD project."				Included	Included	new_screen			2						
47	Behave	Empirical Findings on BDD Story Parsing to Support Consistency Assurance between Requirements and Artifacts	Behaviour-Driven Development (BDD) stories have gained considerable attention in recent years as an effective way to specify and test user requirements in agile software development projects. External testing frameworks also allow developers to automate the execution of BDD stories and check whether a fully functional software system behaves as expected. However, other software artifacts may quite often lose synchronization with the stories, and many inconsistencies can arise with respect to requirements representation. This paper reports on preliminary empirical findings regarding the performance of two existing approaches in the literature intended to support consistency assurance between BDD stories and software artifacts. The first approach involves the parsing of BDD stories in order to identify conceptual elements to automatically generate consistent class diagrams, while the second approach seeks to identify interaction elements to automatically assess the consistency of task models and GUI prototypes. We report on the precision of these approaches when applied to a study with BDD stories previously written by Product Owners (POs). Based on the results, we also identify a set of challenges and opportunities for BDD stories in the consistency assurance of such artifacts.		Silva, Thiago Rocha; Fitzgerald, Brian	Evaluation and Assessment in Software Engineering	Behaviour-Driven Development (BDD) stories have gained considerable attention in recent years as an effective way to specify and test user requirements in agile software development projects. External testing frameworks also allow developers to automate the execution of BDD stories and check whether a fully functional software system behaves as expected. However, other software artifacts may quite often lose synchronization with the stories, and many inconsistencies can arise with respect to requirements representation. This paper reports on preliminary empirical findings regarding the performance of two existing approaches in the literature intended to support consistency assurance between BDD stories and software artifacts. The first approach involves the parsing of BDD stories in order to identify conceptual elements to automatically generate consistent class diagrams, while the second approach seeks to identify interaction elements to automatically assess the consistency of task models and GUI prototypes. We report on the precision of these approaches when applied to a study with BDD stories previously written by Product Owners (POs). Based on the results, we also identify a set of challenges and opportunities for BDD stories in the consistency assurance of such artifacts.				Included	Included	new_screen			2						
48	Behave	Blockchain smart contracts formalization: Approaches and challenges to address vulnerabilities	Blockchain as a distributed computing platform enables users to deploy pieces of software (known as smart contracts) for a wealth of next-generation decentralized applications without involving a trusted third-party. The advantages of smart contracts do, however, come at a price. As with most technologies, there are potential security threats, vulnerabilities and various other issues associated with smart contracts. Writing secure and safe smart contracts can be extremely difficult due to various business logics, as well as platform vulnerabilities and limitations. Formal methods have recently been advocated to mitigate these vulnerabilities. This paper aims to provide a first-time study on current formalization research on all smart contract-related platforms on blockchains, which is scarce in the literature. To this end, a timely and rigorous systematic review to examine the state-of-the-art research and achievements published between 2015 and July 2019 is provided. This study is based on a comprehensive review of a set of 35 research papers that have been extracted from eight major online digital databases. The results indicate that the most common formalization technique is theorem proving, which is most often used to verify security properties relating to smart contracts, while other techniques such as symbolic execution and model checking were also frequently used. These techniques were most commonly used to verify the functional correctness of smart contracts. From the language and automation point of views, there were 12 languages (domain specific/specification/general purpose) proposed or used for the formalization of smart contracts on blockchains, while 15 formal method-specific automated tools/frameworks were identified for mitigating various vulnerabilities of smart contracts. From the results of this work, we further highlight three open issues for future research in this emerging domain including: formal testing, automated verification of smart contracts, and domain specific languages (DSLs) for Ethereum. These issues suggest the need for additional, in-depth research. Our study also provides possible future research directions.	Blockchain, Smart contracts, Formal methods, Verification, Systematic review	Singh, Amritraj; Parizi, Reza M.; Zhang, Qi; Choo, Kim-Kwang Raymond; Dehghantanha, Ali	Computers & Security	Blockchain as a distributed computing platform enables users to deploy pieces of software (known as smart contracts) for a wealth of next-generation decentralized applications without involving a trusted third-party. The advantages of smart contracts do, however, come at a price. As with most technologies, there are potential security threats, vulnerabilities and various other issues associated with smart contracts. Writing secure and safe smart contracts can be extremely difficult due to various business logics, as well as platform vulnerabilities and limitations. Formal methods have recently been advocated to mitigate these vulnerabilities. This paper aims to provide a first-time study on current formalization research on all smart contract-related platforms on blockchains, which is scarce in the literature. To this end, a timely and rigorous systematic review to examine the state-of-the-art research and achievements published between 2015 and July 2019 is provided. This study is based on a comprehensive review of a set of 35 research papers that have been extracted from eight major online digital databases. The results indicate that the most common formalization technique is theorem proving, which is most often used to verify security properties relating to smart contracts, while other techniques such as symbolic execution and model checking were also frequently used. These techniques were most commonly used to verify the functional correctness of smart contracts. From the language and automation point of views, there were 12 languages (domain specific/specification/general purpose) proposed or used for the formalization of smart contracts on blockchains, while 15 formal method-specific automated tools/frameworks were identified for mitigating various vulnerabilities of smart contracts. From the results of this work, we further highlight three open issues for future research in this emerging domain including: formal testing, automated verification of smart contracts, and domain specific languages (DSLs) for Ethereum. These issues suggest the need for additional, in-depth research. Our study also provides possible future research directions.				Excluded	Excluded	new_screen			2						
49	Behave	Survey on blockchain based smart contracts: Applications, opportunities and challenges	Blockchain is one of the disruptive technical innovation in the recent computing paradigm. Many applications already notoriously hard and complex are fortunate to ameliorate the service with the blessings of blockchain and smart contracts. The decentralized and autonomous execution with in-built transparency of blockchain based smart contracts revolutionize most of the applications with optimum and effective functionality. The paper explores the significant applications which already benefited from the smart contracts. We also highlight the future potential of the blockchain based smart contracts in these applications perspective.	Blockchain, Smart contracts, Applications, DLT, Hyperledger Fabric, Ethereum, Corda, Stellar	Hewa, Tharaka; Ylianttila, Mika; Liyanage, Madhusanka	Journal of Network and Computer Applications	Blockchain is one of the disruptive technical innovation in the recent computing paradigm. Many applications already notoriously hard and complex are fortunate to ameliorate the service with the blessings of blockchain and smart contracts. The decentralized and autonomous execution with in-built transparency of blockchain based smart contracts revolutionize most of the applications with optimum and effective functionality. The paper explores the significant applications which already benefited from the smart contracts. We also highlight the future potential of the blockchain based smart contracts in these applications perspective.				Excluded	Excluded	new_screen			2						
50	Behave	End-to-End Automatic Business Process Validation	Business Process Testing is the act of validating that end-to-end transactions through enterprise systems continue to work correctly as the underlying packaged applications evolve. End-to-end automatic business process validation can be a challenging task, but an important way to check that business rules continue to work properly and that problems are detected and corrected as soon as possible. This paper presents the design of a test automation platform, ETAP-Pro, to test end-to-end business processes that aims to overcome some challenges in validating business processes.	Business Process Testing; End-to-end Process Testing; Model Based Testing; Software Testing	Paiva, Ana C.R.; Flores, Nuno H.; Faria, Joo P.; Marques, Jos M.G.	Procedia Comput. Sci.	Business Process Testing is the act of validating that end-to-end transactions through enterprise systems continue to work correctly as the underlying packaged applications evolve. End-to-end automatic business process validation can be a challenging task, but an important way to check that business rules continue to work properly and that problems are detected and corrected as soon as possible. This paper presents the design of a test automation platform, ETAP-Pro, to test end-to-end business processes that aims to overcome some challenges in validating business processes.				Excluded	Excluded	new_screen			2						
51	Behave	A Reusable Automated Acceptance Testing Architecture for Microservices in Behavior-Driven Development	Cloud Computing and Mobile Cloud Computing are reshaping the way applications are being developed and deployed due to their unique needs such as massive scalability, guaranteed fault tolerance, near zero downtime, etc. and also daunting challenges such as security, reliability, continuous deployment and update capability. Microservices architecture, where application is composed of a set of independently deployable services, is increasingly becoming popular due to its capability to address most of these needs and challenges. In recent years, the Behavior-Driven Development (BDD) has become one of the most popular agile software development processes, and frequently used in microservices development. The key to success of BDD is the executable acceptance tests that describe the expected behavior of a feature and its acceptance criteria in the form of scenarios using simple and business people readable syntax. The reusability, auditability, and maintainability become some of the major concerns when BDD test framework is applied for each microservice repository and no previous research addresses these concerns. In this paper, we present a reusable automated acceptance testing architecture to address all these concerns.	behavior-driven development; Gherkin; executable automated acceptance testing; functional testing; microservice	Rahman, Mazedur; Gao, Jerry	Proceedings of the 2015 IEEE Symposium on Service-Oriented System Engineering	Cloud Computing and Mobile Cloud Computing are reshaping the way applications are being developed and deployed due to their unique needs such as massive scalability, guaranteed fault tolerance, near zero downtime, etc. and also daunting challenges such as security, reliability, continuous deployment and update capability. Microservices architecture, where application is composed of a set of independently deployable services, is increasingly becoming popular due to its capability to address most of these needs and challenges. In recent years, the Behavior-Driven Development (BDD) has become one of the most popular agile software development processes, and frequently used in microservices development. The key to success of BDD is the executable acceptance tests that describe the expected behavior of a feature and its acceptance criteria in the form of scenarios using simple and business people readable syntax. The reusability, auditability, and maintainability become some of the major concerns when BDD test framework is applied for each microservice repository and no previous research addresses these concerns. In this paper, we present a reusable automated acceptance testing architecture to address all these concerns.				Excluded	Excluded	new_screen			2						
52	Behave	A reusable automated acceptance testing architecture for microservices in behavior-driven development	Cloud Computing and Mobile Cloud Computing are reshaping the way applications are being developed and deployed due to their unique needs such as massive scalability, guaranteed fault tolerance, near zero downtime, etc. and also daunting challenges such as security, reliability, continuous deployment and update capability. Microservices architecture, where application is composed of a set of independently deployable services, is increasingly becoming popular due to its capability to address most of these needs and challenges. In recent years, the Behavior-Driven Development (BDD) has become one of the most popular agile software development processes, and frequently used in microservices development. The key to success of BDD is the executable acceptance tests that describe the expected behavior of a feature and its acceptance criteria in the form of scenarios using simple and business people readable syntax. The reusability, auditability, and maintainability become some of the major concerns when BDD test framework is applied for each microservice repository and no previous research addresses these concerns. In this paper, we present a reusable automated acceptance testing architecture to address all these concerns. © 2015 IEEE.		Rahman M., Gao J.	Proceedings - 9th IEEE International Symposium on Service-Oriented System Engineering, IEEE SOSE 2015	Cloud Computing and Mobile Cloud Computing are reshaping the way applications are being developed and deployed due to their unique needs such as massive scalability, guaranteed fault tolerance, near zero downtime, etc. and also daunting challenges such as security, reliability, continuous deployment and update capability. Microservices architecture, where application is composed of a set of independently deployable services, is increasingly becoming popular due to its capability to address most of these needs and challenges. In recent years, the Behavior-Driven Development (BDD) has become one of the most popular agile software development processes, and frequently used in microservices development. The key to success of BDD is the executable acceptance tests that describe the expected behavior of a feature and its acceptance criteria in the form of scenarios using simple and business people readable syntax. The reusability, auditability, and maintainability become some of the major concerns when BDD test framework is applied for each microservice repository and no previous research addresses these concerns. In this paper, we present a reusable automated acceptance testing architecture to address all these concerns. © 2015 IEEE.				Included	Included	new_screen			2						
53	Behave	Generating educational mobile applications using UIDPs identified by artificial intelligence techniques	Commercial mobile devices vary in brand, size, and functionalities, but they all allow people to interact with educational applications. In software engineering, application development techniques, approaches, methodologies, and processes (e.g., BBD, FDD, RAD, DDD) are often time consuming, costly, or aim at expert developers – which implies that users outside the software development field (e.g., teachers) need great practice to become experienced application developers. This work proposes an artificial-intelligence-based process for generating educational mobile apps from freehand-generated images. The images’ design is based on User Interface Design Pattern (UIDP) representations. As a proof of concept, we introduce EduMatic, an application development tool. To test our process, we assessed Wiki-Comp, an application built with EduMatic, along with three other external educational applications: Khan Academy, Wiki encyclopedia, and Kiwix. According to the evaluation results, Wiki-Comp outstands in functionality, usability, and performance aspects.	Mobile development, Automatic code generation, Image processing, Educational apps, User interface design pattern	Sánchez-Morales, Laura Nely; Alor-Hernández, Giner; Rosales-Morales, Viviana Yarel; Cortes-Camarillo, Cesar Augusto; Sánchez-Cervantes, José Luis	Computer Standards & Interfaces	Commercial mobile devices vary in brand, size, and functionalities, but they all allow people to interact with educational applications. In software engineering, application development techniques, approaches, methodologies, and processes (e.g., BBD, FDD, RAD, DDD) are often time consuming, costly, or aim at expert developers – which implies that users outside the software development field (e.g., teachers) need great practice to become experienced application developers. This work proposes an artificial-intelligence-based process for generating educational mobile apps from freehand-generated images. The images’ design is based on User Interface Design Pattern (UIDP) representations. As a proof of concept, we introduce EduMatic, an application development tool. To test our process, we assessed Wiki-Comp, an application built with EduMatic, along with three other external educational applications: Khan Academy, Wiki encyclopedia, and Kiwix. According to the evaluation results, Wiki-Comp outstands in functionality, usability, and performance aspects.				Excluded	Excluded	new_screen			2						
54	Behave	Concurrent development and verification of an all-software baseband for satellite ground operations	Communication systems are adopting all-software architectures, because of their scalability, extensibility, flexibility, and cost-effectiveness. This paper introduces a concurrent approach to the development and verification of baseband systems for satellite ground operations based on the behaviour-driven development methodology. The open-source GNU Radio development kit is used for developing the software-defined radio baseband signal processing, as well as simulating the satellite and realistic channel impairments. The system performance at the end shows deviations of less than 1 dB with respect to the ideal performance and the Green Book standards specified by the Consultative Committee for Space Data Systems. © 2019 John Wiley & Sons, Ltd.		Mwakyanjala M.B., Nieto-Peroy C., Emami M.R., van de Beek J.	International Journal of Satellite Communications and Networking	Communication systems are adopting all-software architectures, because of their scalability, extensibility, flexibility, and cost-effectiveness. This paper introduces a concurrent approach to the development and verification of baseband systems for satellite ground operations based on the behaviour-driven development methodology. The open-source GNU Radio development kit is used for developing the software-defined radio baseband signal processing, as well as simulating the satellite and realistic channel impairments. The system performance at the end shows deviations of less than 1 dB with respect to the ideal performance and the Green Book standards specified by the Consultative Committee for Space Data Systems. © 2019 John Wiley & Sons, Ltd.				Included	Included	new_screen			2						
55	Behave	Automation Support for Mobile App Quality Assurance – A Tool Landscape	Competitive pressure in app stores, as well as direct and transparent feedback of app store reviews have resulted in an increased demand for outstanding app quality and user experience. At the same time, reduced time-to-market, decreased budgets and time available for quality assurance, and careful user experience design have to be considered. In response, an enormous market for mobile app quality and user experience measurement tools has grown around the mobile app store ecosystems. Developers following lean and agile development approaches continuously produce new features and ready-to-ship software increments. In those settings, budgets for evaluation and familiarization into new tools are very limited. Currently there are alone more than 28 tools and frameworks for functional test automation and more than 16 different device clouds available. For most of the software developing companies, it is impossible to evaluate and test all of them. In this paper, we present a classification in order to help navigation through the mobile app quality tools landscape for easier selection and more targeted evaluation of tools.	Mobile Applications, Quality, Quality Assurance, User Experience	Braun, Susanne; Elberzhager, Frank; Holl, Konstantin	Procedia Computer Science	Competitive pressure in app stores, as well as direct and transparent feedback of app store reviews have resulted in an increased demand for outstanding app quality and user experience. At the same time, reduced time-to-market, decreased budgets and time available for quality assurance, and careful user experience design have to be considered. In response, an enormous market for mobile app quality and user experience measurement tools has grown around the mobile app store ecosystems. Developers following lean and agile development approaches continuously produce new features and ready-to-ship software increments. In those settings, budgets for evaluation and familiarization into new tools are very limited. Currently there are alone more than 28 tools and frameworks for functional test automation and more than 16 different device clouds available. For most of the software developing companies, it is impossible to evaluate and test all of them. In this paper, we present a classification in order to help navigation through the mobile app quality tools landscape for easier selection and more targeted evaluation of tools.				Excluded	Excluded	new_screen			2						
56	Behave	CIaaS - computational intelligence as a service with Athena	Computational Intelligence (CI) is a sub-branch of Artificial Intelligence (AI) that focus on studying adaptive mechanisms to enable intelligent behavior in complex environments. CI techniques have been successful in solving complex problems in many different knowledge areas. However, despite their usefulness, developing solutions based on CI techniques is not a trivial activity, since it involves the codification/adaptation of algorithms to specific context and problems. In this paper, we present and validate through a quasi-experiment a new paradigm to develop CI-based solutions using a more mature version of Athena (2.0): Computational Intelligence as a Service (CIaaS). Using this tool, both researchers and practitioners can design and evaluate CI-based solutions by dragging and dropping components in a visual environment, in a cloud-based platform. The results of the quasi-experiment suggest that our approach can help researchers to design and evaluate CI-based systems in a simple, reliable and fast way.	Computational intelligence, Tool, Visual programming	Oliveira, Pedro; Santos Neto, Pedro; Britto, Ricardo; Rabêlo, Ricardo; Braga, Ronyerison; Souza, Matheus	Computer Languages, Systems & Structures	Computational Intelligence (CI) is a sub-branch of Artificial Intelligence (AI) that focus on studying adaptive mechanisms to enable intelligent behavior in complex environments. CI techniques have been successful in solving complex problems in many different knowledge areas. However, despite their usefulness, developing solutions based on CI techniques is not a trivial activity, since it involves the codification/adaptation of algorithms to specific context and problems. In this paper, we present and validate through a quasi-experiment a new paradigm to develop CI-based solutions using a more mature version of Athena (2.0): Computational Intelligence as a Service (CIaaS). Using this tool, both researchers and practitioners can design and evaluate CI-based solutions by dragging and dropping components in a visual environment, in a cloud-based platform. The results of the quasi-experiment suggest that our approach can help researchers to design and evaluate CI-based systems in a simple, reliable and fast way.				Excluded	Excluded	new_screen			2						
57	Behave	Optimizing stock assessment workflows by applying software development methodology	Considering that stock assessment requires iterative work including exploratory calculations and discussion, efficiency in completing projects is the key to a successful contribution to stock management. However, if the production speed of each process of the project is inconsistent, a faster process may be worse than a slower process because a large amount of information produced by a faster process induces human error. To coordinate the production speed of each process, we applied software development methodology to the whole assessment project, including small important tasks such as scenario selection, debugging, and yearly updates. First, we established a continuously integrated (CI) document system that monitors project files and triggers report generation when they are updated. The system is composed of four cloud services: a code hosting service, a cloud computing service, cloud storage, and a website hosting service. Because of the CI document system, all the following iterative work was reflected in the report without creating any unused output. The workflow benefited not only from the collaboration but also from the maintainability of the project because work progress and the discussion remained visible for all collaborators. We discuss the effectiveness of a workflow by Lean manufacturing that allows us to focus on the essential problem of the assessment project.	Continuous integration, Lean manufacturing, Open science, Reproducible research	Hayashi, Akira; Ichinokawa, Momoko; Kinoshita, Junji; Manabe, Akihiro	Fisheries Research	Considering that stock assessment requires iterative work including exploratory calculations and discussion, efficiency in completing projects is the key to a successful contribution to stock management. However, if the production speed of each process of the project is inconsistent, a faster process may be worse than a slower process because a large amount of information produced by a faster process induces human error. To coordinate the production speed of each process, we applied software development methodology to the whole assessment project, including small important tasks such as scenario selection, debugging, and yearly updates. First, we established a continuously integrated (CI) document system that monitors project files and triggers report generation when they are updated. The system is composed of four cloud services: a code hosting service, a cloud computing service, cloud storage, and a website hosting service. Because of the CI document system, all the following iterative work was reflected in the report without creating any unused output. The workflow benefited not only from the collaboration but also from the maintainability of the project because work progress and the discussion remained visible for all collaborators. We discuss the effectiveness of a workflow by Lean manufacturing that allows us to focus on the essential problem of the assessment project.				Excluded	Excluded	new_screen			2						
58	Behave	Architecting with microservices: A systematic mapping study	Context A microservice architecture is composed of a set of small services, each running in its own process and communicating with lightweight mechanisms. Many aspects on architecting with microservices are still unexplored and existing research is still far from being crispy clear. Objective We aim at identifying, classifying, and evaluating the state of the art on architecting with microservices from the following perspectives: publication trends, focus of research, and potential for industrial adoption. Method We apply the systematic mapping methodology. We rigorously selected 103 primary studies and we defined and applied a classification framework to them for extracting key information for subsequent analysis. We synthesized the obtained data and produced a clear overview of the state of the art. Results This work contributes with (i) a classification framework for research studies on architecting with microservices, (ii) a systematic map of current research of the field, (iii) an evaluation of the potential for industrial adoption of research results, and (iv) a discussion of emerging findings and implications for future research. Conclusion This study provides a solid, rigorous, and replicable picture of the state of the art on architecting with microservices. Its results can benefit both researchers and practitioners of the field.	Microservices, Software architecture, Systematic mapping study	Di Francesco, Paolo; Lago, Patricia; Malavolta, Ivano	Journal of Systems and Software	Context A microservice architecture is composed of a set of small services, each running in its own process and communicating with lightweight mechanisms. Many aspects on architecting with microservices are still unexplored and existing research is still far from being crispy clear. Objective We aim at identifying, classifying, and evaluating the state of the art on architecting with microservices from the following perspectives: publication trends, focus of research, and potential for industrial adoption. Method We apply the systematic mapping methodology. We rigorously selected 103 primary studies and we defined and applied a classification framework to them for extracting key information for subsequent analysis. We synthesized the obtained data and produced a clear overview of the state of the art. Results This work contributes with (i) a classification framework for research studies on architecting with microservices, (ii) a systematic map of current research of the field, (iii) an evaluation of the potential for industrial adoption of research results, and (iv) a discussion of emerging findings and implications for future research. Conclusion This study provides a solid, rigorous, and replicable picture of the state of the art on architecting with microservices. Its results can benefit both researchers and practitioners of the field.				Excluded	Excluded	new_screen			2						
59	Behave	Design from detail: Analyzing data from a global day of coderetreat	Context Coderetreats are reflective communities of practice, where participants congregate informally to apply their coding abilities to a clearly defined problem setting with the aim of developing their software design skills. One of these events is the global day of coderetreat (GDCR) involving more than two thousand software developers worldwide. Objective The GDCR provided an opportunity to explore the ways that the coderetreat activity is perceived by its participants as a medium for reflective practice, and to suggest ways that we can enhance the design of coderetreats for improving both the experience and learning outcomes. Method We conducted both quantitative and qualitative surveys from a number of participants in the GDCR to understand how software developers hone their craft in the context of a coderetreat. Results Our study indicates that future coderetreats, particularly those that are likely to attract less experienced developers, should consider providing more structural scaffolding to the initial processes of test driven development. Conclusion We believe that all coderetreats should more explicitly encourage practice and reflection on the four elements of simple design. We suggest a more sustained approach throughout the coderetreat with provision of more structural scaffolding. Accordingly, we have derived a set of recommended practices to make the coderetreat more effective for less experienced developers.	Global day of coderetreat, Survey, Simple design, Test driven development, Legacy coderetreat	Parsons, David; Susnjak, Teo; Mathrani, Anuradha	Information and Software Technology	Context Coderetreats are reflective communities of practice, where participants congregate informally to apply their coding abilities to a clearly defined problem setting with the aim of developing their software design skills. One of these events is the global day of coderetreat (GDCR) involving more than two thousand software developers worldwide. Objective The GDCR provided an opportunity to explore the ways that the coderetreat activity is perceived by its participants as a medium for reflective practice, and to suggest ways that we can enhance the design of coderetreats for improving both the experience and learning outcomes. Method We conducted both quantitative and qualitative surveys from a number of participants in the GDCR to understand how software developers hone their craft in the context of a coderetreat. Results Our study indicates that future coderetreats, particularly those that are likely to attract less experienced developers, should consider providing more structural scaffolding to the initial processes of test driven development. Conclusion We believe that all coderetreats should more explicitly encourage practice and reflection on the four elements of simple design. We suggest a more sustained approach throughout the coderetreat with provision of more structural scaffolding. Accordingly, we have derived a set of recommended practices to make the coderetreat more effective for less experienced developers.				Excluded	Excluded	new_screen			2						
60	Behave	A multi-case study of agile requirements engineering and the use of test cases as requirements	Context It is an enigma that agile projects can succeed ‘without requirements’ when weak requirements engineering is a known cause for project failures. While agile development projects often manage well without extensive requirements test cases are commonly viewed as requirements and detailed requirements are documented as test cases. Objective We have investigated this agile practice of using test cases as requirements to understand how test cases can support the main requirements activities, and how this practice varies. Method We performed an iterative case study at three companies and collected data through 14 interviews and two focus groups. Results The use of test cases as requirements poses both benefits and challenges when eliciting, validating, verifying, and managing requirements, and when used as a documented agreement. We have identified five variants of the test-cases-as-requirements practice, namely de facto, behaviour-driven, story-test driven, stand-alone strict and stand-alone manual for which the application of the practice varies concerning the time frame of requirements documentation, the requirements format, the extent to which the test cases are a machine executable specification and the use of tools which provide specific support for the practice of using test cases as requirements. Conclusions The findings provide empirical insight into how agile development projects manage and communicate requirements. The identified variants of the practice of using test cases as requirements can be used to perform in-depth investigations into agile requirements engineering. Practitioners can use the provided recommendations as a guide in designing and improving their agile requirements practices based on project characteristics such as number of stakeholders and rate of change. © 2016 Elsevier B.V.		Bjarnason E., Unterkalmsteiner M., Borg M., Engström E.	Information and Software Technology	Context It is an enigma that agile projects can succeed ‘without requirements’ when weak requirements engineering is a known cause for project failures. While agile development projects often manage well without extensive requirements test cases are commonly viewed as requirements and detailed requirements are documented as test cases. Objective We have investigated this agile practice of using test cases as requirements to understand how test cases can support the main requirements activities, and how this practice varies. Method We performed an iterative case study at three companies and collected data through 14 interviews and two focus groups. Results The use of test cases as requirements poses both benefits and challenges when eliciting, validating, verifying, and managing requirements, and when used as a documented agreement. We have identified five variants of the test-cases-as-requirements practice, namely de facto, behaviour-driven, story-test driven, stand-alone strict and stand-alone manual for which the application of the practice varies concerning the time frame of requirements documentation, the requirements format, the extent to which the test cases are a machine executable specification and the use of tools which provide specific support for the practice of using test cases as requirements. Conclusions The findings provide empirical insight into how agile development projects manage and communicate requirements. The identified variants of the practice of using test cases as requirements can be used to perform in-depth investigations into agile requirements engineering. Practitioners can use the provided recommendations as a guide in designing and improving their agile requirements practices based on project characteristics such as number of stakeholders and rate of change. © 2016 Elsevier B.V.				Excluded	Excluded	new_screen			2						
61	Behave	NLP-assisted software testing: A systematic mapping of the literature	Context To reduce manual effort of extracting test cases from natural-language requirements, many approaches based on Natural Language Processing (NLP) have been proposed in the literature. Given the large amount of approaches in this area, and since many practitioners are eager to utilize such techniques, it is important to synthesize and provide an overview of the state-of-the-art in this area. Objective Our objective is to summarize the state-of-the-art in NLP-assisted software testing which could benefit practitioners to potentially utilize those NLP-based techniques. Moreover, this can benefit researchers in providing an overview of the research landscape. Method To address the above need, we conducted a survey in the form of a systematic literature mapping (classification). After compiling an initial pool of 95 papers, we conducted a systematic voting, and our final pool included 67 technical papers. Results This review paper provides an overview of the contribution types presented in the papers, types of NLP approaches used to assist software testing, types of required input requirements, and a review of tool support in this area. Some key results we have detected are: (1) only four of the 38 tools (11%) presented in the papers are available for download; (2) a larger ratio of the papers (30 of 67) provided a shallow exposure to the NLP aspects (almost no details). Conclusion This paper would benefit both practitioners and researchers by serving as an “index” to the body of knowledge in this area. The results could help practitioners utilizing the existing NLP-based techniques; this in turn reduces the cost of test-case design and decreases the amount of human resources spent on test activities. After sharing this review with some of our industrial collaborators, initial insights show that this review can indeed be useful and beneficial to practitioners.	Software testing, Natural Language Processing (NLP), Systematic literature mapping, Systematic literature review	Garousi, Vahid; Bauer, Sara; Felderer, Michael	Information and Software Technology	Context To reduce manual effort of extracting test cases from natural-language requirements, many approaches based on Natural Language Processing (NLP) have been proposed in the literature. Given the large amount of approaches in this area, and since many practitioners are eager to utilize such techniques, it is important to synthesize and provide an overview of the state-of-the-art in this area. Objective Our objective is to summarize the state-of-the-art in NLP-assisted software testing which could benefit practitioners to potentially utilize those NLP-based techniques. Moreover, this can benefit researchers in providing an overview of the research landscape. Method To address the above need, we conducted a survey in the form of a systematic literature mapping (classification). After compiling an initial pool of 95 papers, we conducted a systematic voting, and our final pool included 67 technical papers. Results This review paper provides an overview of the contribution types presented in the papers, types of NLP approaches used to assist software testing, types of required input requirements, and a review of tool support in this area. Some key results we have detected are: (1) only four of the 38 tools (11%) presented in the papers are available for download; (2) a larger ratio of the papers (30 of 67) provided a shallow exposure to the NLP aspects (almost no details). Conclusion This paper would benefit both practitioners and researchers by serving as an “index” to the body of knowledge in this area. The results could help practitioners utilizing the existing NLP-based techniques; this in turn reduces the cost of test-case design and decreases the amount of human resources spent on test activities. After sharing this review with some of our industrial collaborators, initial insights show that this review can indeed be useful and beneficial to practitioners.				Excluded	Excluded	new_screen			2						
62	Behave	Speed up BDD for Safety Verification in Agile Development: A Partially Replicated Controlled Experiment	Context: Agile development has aroused interest in developing safety-critical systems. Problem statement: However, an increasingly changing architecture makes traditional safety assurance, especially safety analysis and verification, difficult to work. Recently, we proposed STPA-BDD (System-Theoretic Process Analysis-Behaviour Driven Development) for safety analysis and verification in agile development. It showed a good communication effectiveness in a controlled experiment with 44 undergraduate students. However, productivity, test thoroughness and fault detection effectiveness show no statistically significant difference in comparison with UAT (User Acceptance Testing). Objective: In this article, we aim to speed up STPA-BDD through improving productivity, test thoroughness and fault detection effectiveness of STPA-BDD. We develop a semi-automated tool to speed up BDD for safety verification. Method: We evaluate the semi-automated tool concerning productivity, test thoroughness and fault detection effectiveness in a replicated experiment with 11 additional undergraduate students by comparing them with the results from 22 students in the original experiment. Results: The results turn out that productivity is more than 7 times greater, while test thoroughness is more than 1.5 times greater and fault detection effectiveness is more than 2 times greater by using this semi-automated tool than without using it. Conclusion: BDD for safety verification has beed sped up by using this semi-automated tool. Using professionals instead of students as subjects might provide a clearer impact.	agile development; safety verification; controlled experiment	Wang, Yang; Degutis, Daniel Ryan; Wagner, Stefan	Proceedings of the 19th International Conference on Agile Software Development: Companion	Context: Agile development has aroused interest in developing safety-critical systems. Problem statement: However, an increasingly changing architecture makes traditional safety assurance, especially safety analysis and verification, difficult to work. Recently, we proposed STPA-BDD (System-Theoretic Process Analysis-Behaviour Driven Development) for safety analysis and verification in agile development. It showed a good communication effectiveness in a controlled experiment with 44 undergraduate students. However, productivity, test thoroughness and fault detection effectiveness show no statistically significant difference in comparison with UAT (User Acceptance Testing). Objective: In this article, we aim to speed up STPA-BDD through improving productivity, test thoroughness and fault detection effectiveness of STPA-BDD. We develop a semi-automated tool to speed up BDD for safety verification. Method: We evaluate the semi-automated tool concerning productivity, test thoroughness and fault detection effectiveness in a replicated experiment with 11 additional undergraduate students by comparing them with the results from 22 students in the original experiment. Results: The results turn out that productivity is more than 7 times greater, while test thoroughness is more than 1.5 times greater and fault detection effectiveness is more than 2 times greater by using this semi-automated tool than without using it. Conclusion: BDD for safety verification has beed sped up by using this semi-automated tool. Using professionals instead of students as subjects might provide a clearer impact.				Included	Included	new_screen			2						
63	Behave	Combining STPA and BDD for safety analysis and verification in agile development: A controlled experiment	Context: Agile development is in widespread use, even in safety-critical domains. Motivation: However, there is a lack of an appropriate safety analysis and verification method in agile development. Objective: In this paper, we investigate the use of Behavior Driven Development (BDD) instead of standard User Acceptance Testing (UAT) for safety verification with System-Theoretic Process Analysis (STPA) for safety analysis in agile development. Method: We evaluate the effect of this combination in a controlled experiment with 44 students in terms of productivity, test thoroughness, fault detection effectiveness and communication effectiveness. Results: The results show that BDD is more effective for safety verification regarding the impact on communication effectiveness than standard UAT, whereas productivity, test thoroughness and fault detection effectiveness show no statistically significant difference in our controlled experiment. Conclusion: The combination of BDD and STPA seems promising with an enhancement on communication, but its impact needs more research. © The Author(s) 2018.		Wang Y., Wagner S.	Lecture Notes in Business Information Processing	Context: Agile development is in widespread use, even in safety-critical domains. Motivation: However, there is a lack of an appropriate safety analysis and verification method in agile development. Objective: In this paper, we investigate the use of Behavior Driven Development (BDD) instead of standard User Acceptance Testing (UAT) for safety verification with System-Theoretic Process Analysis (STPA) for safety analysis in agile development. Method: We evaluate the effect of this combination in a controlled experiment with 44 students in terms of productivity, test thoroughness, fault detection effectiveness and communication effectiveness. Results: The results show that BDD is more effective for safety verification regarding the impact on communication effectiveness than standard UAT, whereas productivity, test thoroughness and fault detection effectiveness show no statistically significant difference in our controlled experiment. Conclusion: The combination of BDD and STPA seems promising with an enhancement on communication, but its impact needs more research. © The Author(s) 2018.				Included	Included	new_screen			2						
64	Behave	Is business domain language support beneficial for creating test case specifications: A controlled experiment	Context: Behavior Driven Development (BDD), widely used in modern software development, enables easy creation of acceptance test case specifications and serves as a communication basis between business- and technical-oriented stakeholders. BDD is largely facilitated through simple domain specific languages (DSL) and usually restricted to technical test domain concepts. Integrating business domain concepts to implement a ubiquitous language for all members of the development team is an appealing test language improvement issue. But the integration of business domain concepts into BDD toolkits has so far not been investigated. Objective: The objective of the study presented in this paper is to examine whether supporting the ubiquitous language features inside a DSL, by extending a DSL with business domain concepts, is beneficial over using a DSL without those concepts. In the context of the study, benefit is measured in terms of perceived quality, creation time and length of the created test case specifications. In addition, we analyze if participants feel supported when using predefined business domain concepts. Method: We investigate the creation of test case specifications, similar to BDD, in a controlled student experiment performed with graduate students based on a novel platform for DSL experimentation. The experiment was carried out by two groups, each solving a similar comparable test case, one with the simple DSL, the other one with the DSL that includes business domain concepts. A crossover design was chosen for evaluating the perceived quality of the resulting specifications. Results: Our experiment indicates that a business domain aware language allows significant faster creation of documents without lowering the perceived quality. Subjects felt better supported by the DSL with business concepts. Conclusion: Based on our findings we propose that existing BDD toolkits could be further improved by integrating business domain concepts.	Domain Specific Languages (DSL), Behavior driven development, Controlled experiment, Software testing, Student experiment	Häser, Florian; Felderer, Michael; Breu, Ruth	Information and Software Technology	Context: Behavior Driven Development (BDD), widely used in modern software development, enables easy creation of acceptance test case specifications and serves as a communication basis between business- and technical-oriented stakeholders. BDD is largely facilitated through simple domain specific languages (DSL) and usually restricted to technical test domain concepts. Integrating business domain concepts to implement a ubiquitous language for all members of the development team is an appealing test language improvement issue. But the integration of business domain concepts into BDD toolkits has so far not been investigated. Objective: The objective of the study presented in this paper is to examine whether supporting the ubiquitous language features inside a DSL, by extending a DSL with business domain concepts, is beneficial over using a DSL without those concepts. In the context of the study, benefit is measured in terms of perceived quality, creation time and length of the created test case specifications. In addition, we analyze if participants feel supported when using predefined business domain concepts. Method: We investigate the creation of test case specifications, similar to BDD, in a controlled student experiment performed with graduate students based on a novel platform for DSL experimentation. The experiment was carried out by two groups, each solving a similar comparable test case, one with the simple DSL, the other one with the DSL that includes business domain concepts. A crossover design was chosen for evaluating the perceived quality of the resulting specifications. Results: Our experiment indicates that a business domain aware language allows significant faster creation of documents without lowering the perceived quality. Subjects felt better supported by the DSL with business concepts. Conclusion: Based on our findings we propose that existing BDD toolkits could be further improved by integrating business domain concepts.				Included	Included	new_screen			2						
65	Behave	Supporting refactoring of BDD specifications—An empirical study	Context: Behavior-driven development (BDD) is a variant of test-driven development where specifications are described in a structured domain-specific natural language. Although refactoring is a crucial activity of BDD, little research is available on the topic. Objective: To support practitioners in refactoring BDD specifications by (1) proposing semi-automated approaches to identify refactoring candidates; (2) defining refactoring techniques for BDD specifications; and (3) evaluating the proposed identification approaches in an industry context. Method: Using Action Research, we have developed an approach for identifying refactoring candidates in BDD specifications based on two measures of similarity and applied the approach in two projects of a large software organization. The accuracy of the measures for identifying refactoring candidates was then evaluated against an approach based on machine learning and a manual approach based on practitioner perception. Results: We proposed two measures of similarity to support the identification of refactoring candidates in a BDD specification base; (1) normalized compression similarity (NCS) and (2) similarity ratio (SR). A semi-automated approach based on NCS and SR was developed and applied to two industrial cases to identify refactoring candidates. Our results show that our approach can identify candidates for refactoring 6o times faster than a manual approach. Our results furthermore showed that our measures accurately identified refactoring candidates compared with a manual identification by software practitioners and outperformed an ML-based text classification approach. We also described four types of refactoring techniques applicable to BDD specifications; merging candidates, restructuring candidates, deleting duplicates, and renaming specification titles. Conclusion: Our results show that NCS and SR can help practitioners in accurately identifying BDD specifications that are suitable candidates for refactoring, which also decreases the time for identifying refactoring candidates.	Refactoring, Normalized Compression Distance (NCD), Normalized Compression Similarity (NCS), Reuse, Similarity ratio (SR), BDD, Behavior-driven development, Specifications, Testing	Irshad, Mohsin; Börstler, Jürgen; Petersen, Kai	Information and Software Technology	Context: Behavior-driven development (BDD) is a variant of test-driven development where specifications are described in a structured domain-specific natural language. Although refactoring is a crucial activity of BDD, little research is available on the topic. Objective: To support practitioners in refactoring BDD specifications by (1) proposing semi-automated approaches to identify refactoring candidates; (2) defining refactoring techniques for BDD specifications; and (3) evaluating the proposed identification approaches in an industry context. Method: Using Action Research, we have developed an approach for identifying refactoring candidates in BDD specifications based on two measures of similarity and applied the approach in two projects of a large software organization. The accuracy of the measures for identifying refactoring candidates was then evaluated against an approach based on machine learning and a manual approach based on practitioner perception. Results: We proposed two measures of similarity to support the identification of refactoring candidates in a BDD specification base; (1) normalized compression similarity (NCS) and (2) similarity ratio (SR). A semi-automated approach based on NCS and SR was developed and applied to two industrial cases to identify refactoring candidates. Our results show that our approach can identify candidates for refactoring 6o times faster than a manual approach. Our results furthermore showed that our measures accurately identified refactoring candidates compared with a manual identification by software practitioners and outperformed an ML-based text classification approach. We also described four types of refactoring techniques applicable to BDD specifications; merging candidates, restructuring candidates, deleting duplicates, and renaming specification titles. Conclusion: Our results show that NCS and SR can help practitioners in accurately identifying BDD specifications that are suitable candidates for refactoring, which also decreases the time for identifying refactoring candidates.				Excluded	Excluded	new_screen			2						
66	Behave	B-Refactoring: Automatic test code refactoring to improve dynamic analysis	Context: Developers design test suites to verify that software meets its expected behaviors. Many dynamic analysis techniques are performed on the exploitation of execution traces from test cases. In practice, one test case may imply various behaviors. However, the execution of a test case only yields one trace, which can hide the others. Objective: In this article, we propose a new technique of test code refactoring, called B-Refactoring. The idea behind B-Refactoring is to split a test case into small test fragments, which cover a simpler part of the control flow to provide better support for dynamic analysis. Method: For a given dynamic analysis technique, B-Refactoring monitors the execution of test cases and constructs small test cases without loss of the testability. We apply B-Refactoring to assist two existing analysis tasks: automatic repair of if-condition bugs and automatic analysis of exception contracts. Results: Experimental results show that B-Refactoring can effectively improve the execution traces of the test suite. Real-world bugs that could not be previously fixed with the original test suites are fixed after applying B-Refactoring; meanwhile, exception contracts are better verified via applying B-Refactoring to original test suites. Conclusions: We conclude that applying B-Refactoring improves the execution traces of test cases for dynamic analysis. This improvement can enhance existing dynamic analysis tasks.		Xuan, Jifeng; Cornu, Benoit; Martinez, Matias; Baudry, Benoit; Seinturier, Lionel; Monperrus, Martin	Information and Software Technology	Context: Developers design test suites to verify that software meets its expected behaviors. Many dynamic analysis techniques are performed on the exploitation of execution traces from test cases. In practice, one test case may imply various behaviors. However, the execution of a test case only yields one trace, which can hide the others. Objective: In this article, we propose a new technique of test code refactoring, called B-Refactoring. The idea behind B-Refactoring is to split a test case into small test fragments, which cover a simpler part of the control flow to provide better support for dynamic analysis. Method: For a given dynamic analysis technique, B-Refactoring monitors the execution of test cases and constructs small test cases without loss of the testability. We apply B-Refactoring to assist two existing analysis tasks: automatic repair of if-condition bugs and automatic analysis of exception contracts. Results: Experimental results show that B-Refactoring can effectively improve the execution traces of the test suite. Real-world bugs that could not be previously fixed with the original test suites are fixed after applying B-Refactoring; meanwhile, exception contracts are better verified via applying B-Refactoring to original test suites. Conclusions: We conclude that applying B-Refactoring improves the execution traces of test cases for dynamic analysis. This improvement can enhance existing dynamic analysis tasks.				Excluded	Excluded	new_screen			2						
67	Behave	Adapting Behavior Driven Development (BDD) for large-scale software systems	Context: Large-scale software projects require interaction between many stakeholders. Behavior-driven development (BDD) facilitates collaboration between stakeholders, and an adapted BDD process can help improve cooperation in a large-scale project. Objective: The objective of this study is to propose and empirically evaluate a BDD based process adapted for large-scale projects. Method: A technology transfer model was used to propose a BDD based process for large-scale projects. We conducted six workshop sessions to understand the challenges and benefits of BDD. Later, an industrial evaluation was performed for the process with the help of practitioners. Results: From our investigations, understanding of a business aspect of requirements, their improved quality, a guide to system-level use-cases, reuse of artifacts, and help for test organization are found as benefits of BDD. Practitioners identified the following challenges: specification and ownership of behaviors, adoption of new tools, the software projects’ scale, and versioning of behaviors. We proposed a process to address these challenges and evaluated the process with the help of practitioners. Conclusion: The evaluation proved that BDD could be adapted and used to facilitate interaction in large-scale software projects in the software industry. The feedback from the practitioners helped in improving the proposed process.	Behavior-driven, Large-scale, BDD, Software processes, System of systems	Irshad, Mohsin; Britto, Ricardo; Petersen, Kai	Journal of Systems and Software	Context: Large-scale software projects require interaction between many stakeholders. Behavior-driven development (BDD) facilitates collaboration between stakeholders, and an adapted BDD process can help improve cooperation in a large-scale project. Objective: The objective of this study is to propose and empirically evaluate a BDD based process adapted for large-scale projects. Method: A technology transfer model was used to propose a BDD based process for large-scale projects. We conducted six workshop sessions to understand the challenges and benefits of BDD. Later, an industrial evaluation was performed for the process with the help of practitioners. Results: From our investigations, understanding of a business aspect of requirements, their improved quality, a guide to system-level use-cases, reuse of artifacts, and help for test organization are found as benefits of BDD. Practitioners identified the following challenges: specification and ownership of behaviors, adoption of new tools, the software projects’ scale, and versioning of behaviors. We proposed a process to address these challenges and evaluated the process with the help of practitioners. Conclusion: The evaluation proved that BDD could be adapted and used to facilitate interaction in large-scale software projects in the software industry. The feedback from the practitioners helped in improving the proposed process.				Included	Included	new_screen			2						
68	Behave	Design, monitoring, and testing of microservices systems: The practitioners’ perspective	Context: Microservices Architecture (MSA) has received significant attention in the software industry. However, little empirical evidence exists on design, monitoring, and testing of microservices systems. Objective: This research aims to gain a deep understanding of how microservices systems are designed, monitored, and tested in the industry. Methods: A mixed-methods study was conducted with 106 survey responses and 6 interviews from microservices practitioners. Results: The main findings are: (1) a combination of domain-driven design and business capability is the most used strategy to decompose an application into microservices, (2) over half of the participants used architecture evaluation and architecture implementation when designing microservices systems, (3) API gateway and Backend for frontend patterns are the most used MSA patterns, (4) resource usage and load balancing as monitoring metrics, log management and exception tracking as monitoring practices are widely used, (5) unit and end-to-end testing are the most used testing strategies, and (6) the complexity of microservices systems poses challenges for their design, monitoring, and testing, for which there are no dedicated solutions. Conclusions: Our findings reveal that more research is needed to (1) deal with microservices complexity at the design level, (2) handle security in microservices systems, and (3) address the monitoring and testing challenges through dedicated solutions.	Microservices architecture, Design, Monitoring, Testing, Industrial survey	Waseem, Muhammad; Liang, Peng; Shahin, Mojtaba; Di Salle, Amleto; Márquez, Gastón	Journal of Systems and Software	Context: Microservices Architecture (MSA) has received significant attention in the software industry. However, little empirical evidence exists on design, monitoring, and testing of microservices systems. Objective: This research aims to gain a deep understanding of how microservices systems are designed, monitored, and tested in the industry. Methods: A mixed-methods study was conducted with 106 survey responses and 6 interviews from microservices practitioners. Results: The main findings are: (1) a combination of domain-driven design and business capability is the most used strategy to decompose an application into microservices, (2) over half of the participants used architecture evaluation and architecture implementation when designing microservices systems, (3) API gateway and Backend for frontend patterns are the most used MSA patterns, (4) resource usage and load balancing as monitoring metrics, log management and exception tracking as monitoring practices are widely used, (5) unit and end-to-end testing are the most used testing strategies, and (6) the complexity of microservices systems poses challenges for their design, monitoring, and testing, for which there are no dedicated solutions. Conclusions: Our findings reveal that more research is needed to (1) deal with microservices complexity at the design level, (2) handle security in microservices systems, and (3) address the monitoring and testing challenges through dedicated solutions.				Excluded	Excluded	new_screen			2						
69	Behave	Big Data analytics in Agile software development: A systematic mapping study	Context: Over the last decade, Agile methods have changed the software development process in an unparalleled way and with the increasing popularity of Big Data, optimizing development cycles through data analytics is becoming a commodity. Objective: Although a myriad of research exists on software analytics as well as on Agile software development (ASD) practice on itself, there exists no systematic overview of the research done on ASD from a data analytics perspective. Therefore, the objective of this work is to make progress by linking ASD with Big Data analytics (BDA). Method: As the primary method to find relevant literature on the topic, we performed manual search and snowballing on papers published between 2011 and 2019. Results: In total, 88 primary studies were selected and analyzed. Our results show that BDA is employed throughout the whole ASD lifecycle. The results reveal that data-driven software development is focused on the following areas: code repository analytics, defects/bug fixing, testing, project management analytics, and application usage analytics. Conclusions: As BDA and ASD are fast-developing areas, improving the productivity of software development teams is one of the most important objectives BDA is facing in the industry. This study provides scholars with information about the state of software analytics research and the current trends as well as applications in the business environment. Whereas, thanks to this literature review, practitioners should be able to understand better how to obtain actionable insights from their software artifacts and on which aspects of data analytics to focus when investing in such initiatives.	Agile software development, Software analytics, Data analytics, Machine learning, Artificial intelligence, Literature review	Biesialska, Katarzyna; Franch, Xavier; Muntés-Mulero, Victor	Information and Software Technology	Context: Over the last decade, Agile methods have changed the software development process in an unparalleled way and with the increasing popularity of Big Data, optimizing development cycles through data analytics is becoming a commodity. Objective: Although a myriad of research exists on software analytics as well as on Agile software development (ASD) practice on itself, there exists no systematic overview of the research done on ASD from a data analytics perspective. Therefore, the objective of this work is to make progress by linking ASD with Big Data analytics (BDA). Method: As the primary method to find relevant literature on the topic, we performed manual search and snowballing on papers published between 2011 and 2019. Results: In total, 88 primary studies were selected and analyzed. Our results show that BDA is employed throughout the whole ASD lifecycle. The results reveal that data-driven software development is focused on the following areas: code repository analytics, defects/bug fixing, testing, project management analytics, and application usage analytics. Conclusions: As BDA and ASD are fast-developing areas, improving the productivity of software development teams is one of the most important objectives BDA is facing in the industry. This study provides scholars with information about the state of software analytics research and the current trends as well as applications in the business environment. Whereas, thanks to this literature review, practitioners should be able to understand better how to obtain actionable insights from their software artifacts and on which aspects of data analytics to focus when investing in such initiatives.				Excluded	Excluded	new_screen			2						
70	Behave	Documentation of Quality Requirements in Agile Software Development	Context: Quality requirements (QRs) have a significant role in the success of software projects. In agile software development (ASD), where working software is valued over comprehensive documentation, QRs are often under-specified or not documented. Consequently, they may be handled improperly and result in degraded software quality and increased maintenance costs. Investigating the documentation of QRs in ASD, would provide evidence on existing practices, tools and aspects considered in ASD that other practitioners might utilize to improve documentation and management of QRs in ASD. Although there are some studies examining documentation in ASD, those that specifically investigate the documentation of QRs in depth are lacking.Method: we conducted a multiple case study by interviewing 15 practitioners of four ASD cases, to provide empirical evidence on documentation of QRs in ASD. We also run workshops with two of the cases, to identify important aspects that ASD practitioners consider when documenting QRs in requirements management repositories.Result and conclusions: ASD companies approach documentation of QRs to fit the needs of their context. They used tools, backlogs, iterative prototypes, and artifacts such as epic, and stories to document QRs, or utilized face-face communication without documenting QRs. We observed that documentation of QRs in ASD is affected by factors such as context (e.g. product domain, and size) and the experience of practitioners. Some tools used to document QRs also enhanced customer collaboration, enabling customers report and document QRs. Aspects such as levels of abstraction, the traceability of QRs, optimal details of information of QRs and verification and validation are deemed important when documenting QRs in ASD requirements management repositories.	documentation; agile software development; non-functional requirements; Quality requirement	Behutiye, Woubshet; Seppänen, Pertti; Rodríguez, Pilar; Oivo, Markku	Proceedings of the Evaluation and Assessment in Software Engineering	Context: Quality requirements (QRs) have a significant role in the success of software projects. In agile software development (ASD), where working software is valued over comprehensive documentation, QRs are often under-specified or not documented. Consequently, they may be handled improperly and result in degraded software quality and increased maintenance costs. Investigating the documentation of QRs in ASD, would provide evidence on existing practices, tools and aspects considered in ASD that other practitioners might utilize to improve documentation and management of QRs in ASD. Although there are some studies examining documentation in ASD, those that specifically investigate the documentation of QRs in depth are lacking.Method: we conducted a multiple case study by interviewing 15 practitioners of four ASD cases, to provide empirical evidence on documentation of QRs in ASD. We also run workshops with two of the cases, to identify important aspects that ASD practitioners consider when documenting QRs in requirements management repositories.Result and conclusions: ASD companies approach documentation of QRs to fit the needs of their context. They used tools, backlogs, iterative prototypes, and artifacts such as epic, and stories to document QRs, or utilized face-face communication without documenting QRs. We observed that documentation of QRs in ASD is affected by factors such as context (e.g. product domain, and size) and the experience of practitioners. Some tools used to document QRs also enhanced customer collaboration, enabling customers report and document QRs. Aspects such as levels of abstraction, the traceability of QRs, optimal details of information of QRs and verification and validation are deemed important when documenting QRs in ASD requirements management repositories.				Excluded	Excluded	new_screen			2						
71	Behave	Improving the delivery cycle: A multiple-case study of the toolchains in Finnish software intensive enterprises	Context: Software companies seek to gain benefit from agile development approaches in order to meet evolving market needs without losing their innovative edge. Agile practices emphasize frequent releases with the help of an automated toolchain from code to delivery. Objective: We investigate, which tools are used in software delivery, what are the reasons omitting certain parts of the toolchain and what implications toolchains have on how rapidly software gets delivered to customers. Method: We present a multiple-case study of the toolchains currently in use in Finnish software-intensive organizations interested in improving their delivery frequency. We conducted qualitative semi-structured interviews in 18 case organizations from various software domains. The interviewees were key representatives of their organization, considering delivery activities. Results: Commodity tools, such as version control and continuous integration, were used in almost every organization. Modestly used tools, such as UI testing and performance testing, were more distinctly missing from some organizations. Uncommon tools, such as artifact repository and acceptance testing, were used only in a minority of the organizations. Tool usage is affected by the state of current workflows, manual work and relevancy of tools. Organizations whose toolchains were more automated and contained fewer manual steps were able to deploy software more rapidly. Conclusions: There is variety in the need for tool support in different development steps as there are domain-specific differences in the goals of the case organizations. Still, a well-founded toolchain supports speedy delivery of new software.	Continuous deployment, Continuous delivery, Software development tools, Deployment pipeline, Agile software development	Mäkinen, Simo; Leppänen, Marko; Kilamo, Terhi; Mattila, Anna-Liisa; Laukkanen, Eero; Pagels, Max; Männistö, Tomi	Information and Software Technology	Context: Software companies seek to gain benefit from agile development approaches in order to meet evolving market needs without losing their innovative edge. Agile practices emphasize frequent releases with the help of an automated toolchain from code to delivery. Objective: We investigate, which tools are used in software delivery, what are the reasons omitting certain parts of the toolchain and what implications toolchains have on how rapidly software gets delivered to customers. Method: We present a multiple-case study of the toolchains currently in use in Finnish software-intensive organizations interested in improving their delivery frequency. We conducted qualitative semi-structured interviews in 18 case organizations from various software domains. The interviewees were key representatives of their organization, considering delivery activities. Results: Commodity tools, such as version control and continuous integration, were used in almost every organization. Modestly used tools, such as UI testing and performance testing, were more distinctly missing from some organizations. Uncommon tools, such as artifact repository and acceptance testing, were used only in a minority of the organizations. Tool usage is affected by the state of current workflows, manual work and relevancy of tools. Organizations whose toolchains were more automated and contained fewer manual steps were able to deploy software more rapidly. Conclusions: There is variety in the need for tool support in different development steps as there are domain-specific differences in the goals of the case organizations. Still, a well-founded toolchain supports speedy delivery of new software.				Excluded	Excluded	new_screen			2						
72	Behave	Demystifying the adoption of behavior-driven development in open source projects	Context:Behavior-Driven Development (BDD) features the capability, through appropriate domain-specific languages, of specifying acceptance test cases and making them executable. The availability of frameworks such as Cucumber or RSpec makes the application of BDD possible in practice. However, it is unclear to what extent developers use such frameworks, and whether they use them for actually performing BDD, or, instead, for other purposes such as unit testing. Objective:In this paper, we conduct an empirical investigation about the use of BDD tools in open source, and how, when a BDD tool is in place, BDD specifications co-evolve with source code. Method:Our investigation includes three different phases: (i) a large-scale analysis to understand the extent to which BDD frameworks are used in 50,000 popular open-source projects written in five programming languages; (ii) a study on the co-evolution of scenarios, fixtures and production code in a sample of 20 Ruby projects, through the Granger’s causality test, and (iii) a survey with 31 developers to understand how they use BDD frameworks. Results:Results of the study indicate that  ≃  27% of the sampled projects use BDD frameworks, with a prevalence in Ruby projects (68%). In about 37% of the cases, we found a co-evolution between scenarios/fixtures and production code. Specifically, changes to scenarios and fixtures often happen together or after changes to source code. Moreover, survey respondents indicate that, while they understand the intended purpose of BDD frameworks, most of them write tests while/after coding rather than strictly applying BDD. Conclusions:Even if the BDD frameworks usage is widespread among open source projects, in many cases they are used for different purposes such as unit testing activities. This mainly happens because developers felt BDD remains quite effort-prone, and its application goes beyond the simple adoption of a BDD framework.	Behavior-driven development, Acceptance testing, Empirical study, Co-evolution	Zampetti, Fiorella; Di Sorbo, Andrea; Visaggio, Corrado Aaron; Canfora, Gerardo; Di Penta, Massimiliano	Information and Software Technology	Context:Behavior-Driven Development (BDD) features the capability, through appropriate domain-specific languages, of specifying acceptance test cases and making them executable. The availability of frameworks such as Cucumber or RSpec makes the application of BDD possible in practice. However, it is unclear to what extent developers use such frameworks, and whether they use them for actually performing BDD, or, instead, for other purposes such as unit testing. Objective:In this paper, we conduct an empirical investigation about the use of BDD tools in open source, and how, when a BDD tool is in place, BDD specifications co-evolve with source code. Method:Our investigation includes three different phases: (i) a large-scale analysis to understand the extent to which BDD frameworks are used in 50,000 popular open-source projects written in five programming languages; (ii) a study on the co-evolution of scenarios, fixtures and production code in a sample of 20 Ruby projects, through the Granger’s causality test, and (iii) a survey with 31 developers to understand how they use BDD frameworks. Results:Results of the study indicate that  ≃  27% of the sampled projects use BDD frameworks, with a prevalence in Ruby projects (68%). In about 37% of the cases, we found a co-evolution between scenarios/fixtures and production code. Specifically, changes to scenarios and fixtures often happen together or after changes to source code. Moreover, survey respondents indicate that, while they understand the intended purpose of BDD frameworks, most of them write tests while/after coding rather than strictly applying BDD. Conclusions:Even if the BDD frameworks usage is widespread among open source projects, in many cases they are used for different purposes such as unit testing activities. This mainly happens because developers felt BDD remains quite effort-prone, and its application goes beyond the simple adoption of a BDD framework.				Included	Included	new_screen			2						
73	Behave	A Multi-Case Study of Agile Requirements Engineering and the Use of Test Cases as Requirements	ContextIt is an enigma that agile projects can succeed 'without requirements' when weak requirements engineering is a known cause for project failures. While agile development projects often manage well without extensive requirements test cases are commonly viewed as requirements and detailed requirements are documented as test cases. ObjectiveWe have investigated this agile practice of using test cases as requirements to understand how test cases can support the main requirements activities, and how this practice varies. MethodWe performed an iterative case study at three companies and collected data through 14 interviews and two focus groups. ResultsThe use of test cases as requirements poses both benefits and challenges when eliciting, validating, verifying, and managing requirements, and when used as a documented agreement. We have identified five variants of the test-cases-as-requirements practice, namely de facto, behaviour-driven, story-test driven, stand-alone strict and stand-alone manual for which the application of the practice varies concerning the time frame of requirements documentation, the requirements format, the extent to which the test cases are a machine executable specification and the use of tools which provide specific support for the practice of using test cases as requirements. ConclusionsThe findings provide empirical insight into how agile development projects manage and communicate requirements. The identified variants of the practice of using test cases as requirements can be used to perform in-depth investigations into agile requirements engineering. Practitioners can use the provided recommendations as a guide in designing and improving their agile requirements practices based on project characteristics such as number of stakeholders and rate of change.	Acceptance test; Agile development; Behaviour-driven development; Case study; Empirical software engineering; Requirements; Test-driven development; Test-first development; Testing	Bjarnason, Elizabeth; Unterkalmsteiner, Michael; Borg, Markus; Engström, Emelie	Inf. Softw. Technol.	ContextIt is an enigma that agile projects can succeed 'without requirements' when weak requirements engineering is a known cause for project failures. While agile development projects often manage well without extensive requirements test cases are commonly viewed as requirements and detailed requirements are documented as test cases. ObjectiveWe have investigated this agile practice of using test cases as requirements to understand how test cases can support the main requirements activities, and how this practice varies. MethodWe performed an iterative case study at three companies and collected data through 14 interviews and two focus groups. ResultsThe use of test cases as requirements poses both benefits and challenges when eliciting, validating, verifying, and managing requirements, and when used as a documented agreement. We have identified five variants of the test-cases-as-requirements practice, namely de facto, behaviour-driven, story-test driven, stand-alone strict and stand-alone manual for which the application of the practice varies concerning the time frame of requirements documentation, the requirements format, the extent to which the test cases are a machine executable specification and the use of tools which provide specific support for the practice of using test cases as requirements. ConclusionsThe findings provide empirical insight into how agile development projects manage and communicate requirements. The identified variants of the practice of using test cases as requirements can be used to perform in-depth investigations into agile requirements engineering. Practitioners can use the provided recommendations as a guide in designing and improving their agile requirements practices based on project characteristics such as number of stakeholders and rate of change.				Included	Included	new_screen			2						
74	Behave	Continuous Delivery: Overcoming adoption challenges	Continuous Delivery (CD) is a relatively new software development approach. Companies that have adopted CD have reported significant benefits. Motivated by these benefits, many companies would like to adopt CD. However, adopting CD can be very challenging for a number of reasons, such as obtaining buy-in from a wide range of stakeholders whose goals may seemingly be different from—or even conflict with—our own; gaining sustained support in a dynamic complex enterprise environment; maintaining an application development team's momentum when their application's migration to CD requires an additional strenuous effort over a long period of time; and so on. To help overcome the adoption challenges, I present six strategies: (1) selling CD as a painkiller; (2) establishing a dedicated team with multi-disciplinary members; (3) continuous delivery of continuous delivery; (4) starting with the easy but important applications; (5) visual CD pipeline skeleton; (6) expert drop. These strategies were derived from four years of experience in implementing CD at a multi-billion-euro company. Additionally, our experience led to the identification of eight further challenges for research. The information contributes toward building a body of knowledge for CD adoption.	Agile Software Development, Continuous Delivery, Continuous Deployment, Continuous Software Engineering, DevOps, Adoption	Chen, Lianping	Journal of Systems and Software	Continuous Delivery (CD) is a relatively new software development approach. Companies that have adopted CD have reported significant benefits. Motivated by these benefits, many companies would like to adopt CD. However, adopting CD can be very challenging for a number of reasons, such as obtaining buy-in from a wide range of stakeholders whose goals may seemingly be different from—or even conflict with—our own; gaining sustained support in a dynamic complex enterprise environment; maintaining an application development team's momentum when their application's migration to CD requires an additional strenuous effort over a long period of time; and so on. To help overcome the adoption challenges, I present six strategies: (1) selling CD as a painkiller; (2) establishing a dedicated team with multi-disciplinary members; (3) continuous delivery of continuous delivery; (4) starting with the easy but important applications; (5) visual CD pipeline skeleton; (6) expert drop. These strategies were derived from four years of experience in implementing CD at a multi-billion-euro company. Additionally, our experience led to the identification of eight further challenges for research. The information contributes toward building a body of knowledge for CD adoption.				Excluded	Excluded	new_screen			2						
75	Behave	Transition towards Continuous Delivery in the Healthcare Domain	Continuous Delivery is meanwhile well-established in many parts of the software industry. In a transition towards continuous delivery in the healthcare domain, there are a number of additional challenges that should be addressed. We present how we have addressed some of these challenges and highlight some potential research topics that could be addressed in this space to make further progress in this important area. Although our focus is on the healthcare domain, the approach and the research topics are applicable also to a broad range of other application domains.	behavior-driven development; agile; continuous delivery; deployment pipeline; domain-driven design; pair-programming; test automation; test-driven development	Giorgi, Fabio; Paulisch, Frances	Proceedings of the 41st International Conference on Software Engineering: Software Engineering in Practice	Continuous Delivery is meanwhile well-established in many parts of the software industry. In a transition towards continuous delivery in the healthcare domain, there are a number of additional challenges that should be addressed. We present how we have addressed some of these challenges and highlight some potential research topics that could be addressed in this space to make further progress in this important area. Although our focus is on the healthcare domain, the approach and the research topics are applicable also to a broad range of other application domains.				Excluded	Excluded	new_screen			2						
76	Behave	Transition Towards Continuous Delivery in the Healthcare Domain	Continuous Delivery is meanwhile well-established in many parts of the software industry. In a transition towards continuous delivery in the healthcare domain, there are a number of additional challenges that should be addressed. We present how we have addressed some of these challenges and highlight some potential research topics that could be addressed in this space to make further progress in this important area. Although our focus is on the healthcare domain, the approach and the research topics are applicable also to a broad range of other application domains.	continuous delivery, agile, test-driven development, behavior-driven development, domain-driven design, test automation, pair-programming, deployment pipeline	F. Giorgi; F. Paulisch	2019 IEEE/ACM 41st International Conference on Software Engineering: Software Engineering in Practice (ICSE-SEIP)	Continuous Delivery is meanwhile well-established in many parts of the software industry. In a transition towards continuous delivery in the healthcare domain, there are a number of additional challenges that should be addressed. We present how we have addressed some of these challenges and highlight some potential research topics that could be addressed in this space to make further progress in this important area. Although our focus is on the healthcare domain, the approach and the research topics are applicable also to a broad range of other application domains.				Included	Included	new_screen			2						
77	Behave	Learning Behavior-Driven Development with JavaScript	Create powerful yet simple-to-code BDD test suites in JavaScript using the most popular tools in the community About This BookMaster the most popular testing tools in the JavaScript ecosystem, such as CucumberJS, Mocha, SinonJS, and more.Learn how Behavior-driven development can help you to write software that is more modular and has less defects.Avoid common mistakes in testing, simplify your test suites, and make them more maintainable using a very pragmatic approach to BDD.Who This Book Is ForTThis book is ideal for any JavaScript developer who is interested in producing well-tested code. If you have no prior experience with testing, Node.js, or any other tool, do not worry, as they will be explained from scratch. In Detail JavaScript is not only widely used to create attractive user interfaces for the Web, but with the advent of Node.js, it is also becoming a very popular and powerful language to write server-side applications. Using behavior-driven development and some common testing patterns and best practices, you will be able to avoid these traps.This book will show you how to do BDD in a practical way. We will start with a basic introduction of what BDD is and why the classical approach to testing has failed. Afterwards, we will dive directly into an introduction to Node.js, Mocha, and Sinon.JS. Finally, we will cover more advanced subjects such as how to write a fast and effective test suite for a RESTful web API, and how to do the same with a rich UI using Cucumber.js and Protractor.This book will give you great insight into how to architect your system to make it more testable and modular, but at the same time avoid the nightmare of abusing mock objects.		Amodeo, Enrique		Create powerful yet simple-to-code BDD test suites in JavaScript using the most popular tools in the community About This BookMaster the most popular testing tools in the JavaScript ecosystem, such as CucumberJS, Mocha, SinonJS, and more.Learn how Behavior-driven development can help you to write software that is more modular and has less defects.Avoid common mistakes in testing, simplify your test suites, and make them more maintainable using a very pragmatic approach to BDD.Who This Book Is ForTThis book is ideal for any JavaScript developer who is interested in producing well-tested code. If you have no prior experience with testing, Node.js, or any other tool, do not worry, as they will be explained from scratch. In Detail JavaScript is not only widely used to create attractive user interfaces for the Web, but with the advent of Node.js, it is also becoming a very popular and powerful language to write server-side applications. Using behavior-driven development and some common testing patterns and best practices, you will be able to avoid these traps.This book will show you how to do BDD in a practical way. We will start with a basic introduction of what BDD is and why the classical approach to testing has failed. Afterwards, we will dive directly into an introduction to Node.js, Mocha, and Sinon.JS. Finally, we will cover more advanced subjects such as how to write a fast and effective test suite for a RESTful web API, and how to do the same with a rich UI using Cucumber.js and Protractor.This book will give you great insight into how to architect your system to make it more testable and modular, but at the same time avoid the nightmare of abusing mock objects.				Excluded	Excluded	new_screen			2						
78	Behave	SS-BDD: Automated Acceptance Testing for Spreadsheets	Current Spreadsheet Applications, such as Excel and Google Sheets, provide innumerous built-in facilities, including arithmetic, financial and statistical operations, as well as conditional expressions. Thus, users with little or no formal training in programming can use Spreadsheet Applications to implement their own Spreadsheet Programs. In fact, Spreadsheet Applications have become one of the most popular end-user programming environments nowadays. However, these applications also ease the introduction of errors in Spreadsheet Programs. Minor mistakes in formulas can mislead decisionmaking processes, resulting in uncountable costs to organizations. In general, end-user programmers are unaware of the potential risks that the uncontrolled construction of Spreadsheet Programs can cause. Therefore, a major focus of this paper is to offer an automated approach that makes programmers aware of introduced faults, so that they can build high quality Spreadsheet Programs. In particular, we propose SS-BDD, a framework for building and running Spreadsheets test scenarios, which relies on the use of Behavior Driven Development (BDD). We used SS-BDD to test three different Spreadsheet Programs. Our experience shows that SS-BDD can be used to build end-user friendly test scenarios which can achieve high fault-detection effectiveness.	Behavior Driven Development; Software Testing Tool; Spreadsheet Testing	Almeida, Lara; Cirilo, Elder; Barbosa, Eiji Adachi	Proceedings of the 1st Brazilian Symposium on Systematic and Automated Software Testing	Current Spreadsheet Applications, such as Excel and Google Sheets, provide innumerous built-in facilities, including arithmetic, financial and statistical operations, as well as conditional expressions. Thus, users with little or no formal training in programming can use Spreadsheet Applications to implement their own Spreadsheet Programs. In fact, Spreadsheet Applications have become one of the most popular end-user programming environments nowadays. However, these applications also ease the introduction of errors in Spreadsheet Programs. Minor mistakes in formulas can mislead decisionmaking processes, resulting in uncountable costs to organizations. In general, end-user programmers are unaware of the potential risks that the uncontrolled construction of Spreadsheet Programs can cause. Therefore, a major focus of this paper is to offer an automated approach that makes programmers aware of introduced faults, so that they can build high quality Spreadsheet Programs. In particular, we propose SS-BDD, a framework for building and running Spreadsheets test scenarios, which relies on the use of Behavior Driven Development (BDD). We used SS-BDD to test three different Spreadsheet Programs. Our experience shows that SS-BDD can be used to build end-user friendly test scenarios which can achieve high fault-detection effectiveness.				Included	Included	new_screen			2						
79	Behave	BMT: Behavior Driven Development-based Metamorphic Testing for Autonomous Driving Models	Deep Neural Network based models are widely used for perception and control in autonomous driving. Recent work leverages metamorphic testing to improve defect detection but is limited to using only an equality-based metamorphic relation. Thus, it does not provide sufficient expressiveness for users to define custom metamorphic relations nor means to automatically generate meaningful inputs based on such expressive metamorphic relations that reflect real-world traffic behaviors. In this paper, we preliminarily design and evaluate a declarative Behaviour-Driven Development (BDD)-based metamorphic testing framework BMT, which enables domain experts to specify custom traffic behaviors-a car shall decelerate by x% when a bicycle is in front, etc. It then automatically translates a human-written behavior to a corresponding metamorphic relation and synthesizes meaningful test inputs using a variety of image and graphics processing techniques. Our preliminary evaluation shows that BMT can detect a significant number of erroneous predictions of three driving models for speed predictions. These detected erroneous predictions are manually examined and confirmed by six human judges as meaningful traffic violations. By automating test generation from custom behaviors, BMT enables experts to easily express domain-specific constraints and finds violations of such constraints.	Metamorphic Testing;Autonomous Driving;Deep Learning Models;Software Testing and Verification	Y. Deng; G. Lou; X. Zheng; T. Zhang; M. Kim; H. Liu; C. Wang; T. Y. Chen	2021 IEEE/ACM 6th International Workshop on Metamorphic Testing (MET)	Deep Neural Network based models are widely used for perception and control in autonomous driving. Recent work leverages metamorphic testing to improve defect detection but is limited to using only an equality-based metamorphic relation. Thus, it does not provide sufficient expressiveness for users to define custom metamorphic relations nor means to automatically generate meaningful inputs based on such expressive metamorphic relations that reflect real-world traffic behaviors. In this paper, we preliminarily design and evaluate a declarative Behaviour-Driven Development (BDD)-based metamorphic testing framework BMT, which enables domain experts to specify custom traffic behaviors-a car shall decelerate by x% when a bicycle is in front, etc. It then automatically translates a human-written behavior to a corresponding metamorphic relation and synthesizes meaningful test inputs using a variety of image and graphics processing techniques. Our preliminary evaluation shows that BMT can detect a significant number of erroneous predictions of three driving models for speed predictions. These detected erroneous predictions are manually examined and confirmed by six human judges as meaningful traffic violations. By automating test generation from custom behaviors, BMT enables experts to easily express domain-specific constraints and finds violations of such constraints.				Included	Included	new_screen			2						
80	Behave	3DEvent: A Framework Using Event-Sourcing Approach for 3D Web-Based Collaborative Design in P2P	Despite recent advances, especially in web-based Collaborative Virtual Environments (CVEs) using real-time 3D content, Web technology still requires an efficient way to distribute and stream large-scale 3D data. In this paper, we present 3DEvent: an event-driven framework to collaboratively manipulate predesigned 3D content in real-time on a web-based platform. This work introduces a new approach in achieving 3D object manipulation tasks during collaborative design stages using event-sourcing. Usually, a client-server architecture supports updates to the 3D environment state. Peer-to-peer (P2P) allows direct communication between teammates reducing response times during collaboration and decreasing server load, reducing the costs of providers. 3DEvent enables P2P-assisted delivery of 3D dynamic content in a web browser via WebRTC. By combining concepts from distributed event-processing and mesh-processing, 3D independent rendering and event-based synchronization, we present 3DEvent framework and potential uses associated that support history-aware 3D applications into a unified distributed processing solution for 3D web-based CVEs.	collaborative manipulation; distributed application; event-driven architecture; Web 3D; WebRTC	Desprat, Caroline; Jessel, Jean-Pierre; Luga, Hervé	Proceedings of the 21st International Conference on Web3D Technology	Despite recent advances, especially in web-based Collaborative Virtual Environments (CVEs) using real-time 3D content, Web technology still requires an efficient way to distribute and stream large-scale 3D data. In this paper, we present 3DEvent: an event-driven framework to collaboratively manipulate predesigned 3D content in real-time on a web-based platform. This work introduces a new approach in achieving 3D object manipulation tasks during collaborative design stages using event-sourcing. Usually, a client-server architecture supports updates to the 3D environment state. Peer-to-peer (P2P) allows direct communication between teammates reducing response times during collaboration and decreasing server load, reducing the costs of providers. 3DEvent enables P2P-assisted delivery of 3D dynamic content in a web browser via WebRTC. By combining concepts from distributed event-processing and mesh-processing, 3D independent rendering and event-based synchronization, we present 3DEvent framework and potential uses associated that support history-aware 3D applications into a unified distributed processing solution for 3D web-based CVEs.				Excluded	Excluded	new_screen			2						
81	Behave	Test-Driven Development of Relational Databases	Developers can use a test-driven development with database schema just as they use it with application code. Implementing test-driven database development (TDDD) involves three relatively simple steps: database refactoring, database regression testing, and continuous database integration. In database refactoring, developers make a simple change to a database to improve the design without changing its semantics. In database regression testing, they run a comprehensive test suite that validates the database regularly-ideally, whenever developers change the database schema or access the database in a different way. In continuous database integration, developers rebuild and retest the database schema whenever it changes. From a technical viewpoint, TDDD is straightforward. However, cultural challenges can make it difficult to adopt.	BDD; behavior-driven development; test-driven development; database refactoring; database testing; relational database; TDD; test-driven database design	Ambler, Scott W.	IEEE Softw.	Developers can use a test-driven development with database schema just as they use it with application code. Implementing test-driven database development (TDDD) involves three relatively simple steps: database refactoring, database regression testing, and continuous database integration. In database refactoring, developers make a simple change to a database to improve the design without changing its semantics. In database regression testing, they run a comprehensive test suite that validates the database regularly-ideally, whenever developers change the database schema or access the database in a different way. In continuous database integration, developers rebuild and retest the database schema whenever it changes. From a technical viewpoint, TDDD is straightforward. However, cultural challenges can make it difficult to adopt.				Excluded	Excluded	new_screen			2						
82	Behave	Automatic production of end user documentation for DSLs	Domain-specific languages (DSL) are developed for answering specific problems by leveraging the expertise of domain stakeholders. The development of DSLs requires a significant software engineering effort: editors, code generators, etc, must be developed to make a DSL usable. Documenting a DSL is also a major and time-consuming task required to promote it and address its learning curve. Recent research work in software language engineering focus on easing the development of DSLs. This work focuses on easing the production of documentation of textual DSLs. The API documentation domain identified challenges we adapted to DSL documentation. Based on these challenges we propose a model-driven approach that relies on DSL artifacts to extract information required to build documentation. Our implementation, called Docywood, targets two platforms: Markdown documentation for static web sites and Xtext code fragments for live documentation while modeling. We used Docywood on two DSLs, namely ThingML and Target Platform Definition. Feedback from end users and language designers exhibits qualitative benefits of the proposal with regard to the DSL documentation challenges. End user experiments conducted on ThingML and Target Platform Definition show benefits on the correctness of the created models when using Docywood on ThingML.	Software documentation, Domain-specific language, Model slicing	Le Moulec, Gwendal; Blouin, Arnaud; Gouranton, Valérie; Arnaldi, Bruno	Computer Languages, Systems & Structures	Domain-specific languages (DSL) are developed for answering specific problems by leveraging the expertise of domain stakeholders. The development of DSLs requires a significant software engineering effort: editors, code generators, etc, must be developed to make a DSL usable. Documenting a DSL is also a major and time-consuming task required to promote it and address its learning curve. Recent research work in software language engineering focus on easing the development of DSLs. This work focuses on easing the production of documentation of textual DSLs. The API documentation domain identified challenges we adapted to DSL documentation. Based on these challenges we propose a model-driven approach that relies on DSL artifacts to extract information required to build documentation. Our implementation, called Docywood, targets two platforms: Markdown documentation for static web sites and Xtext code fragments for live documentation while modeling. We used Docywood on two DSLs, namely ThingML and Target Platform Definition. Feedback from end users and language designers exhibits qualitative benefits of the proposal with regard to the DSL documentation challenges. End user experiments conducted on ThingML and Target Platform Definition show benefits on the correctness of the created models when using Docywood on ThingML.				Excluded	Excluded	new_screen			2						
83	Behave	A Process for Evidence-Based Engineering of Domain-Specific Languages	Domain-specific languages (DSLs) are mainly designed ad-hoc and gut feeling resulting in languages that are often not well suited for their users and engineers. In this paper we develop a process for evidence-based language engineering to design domain-specific languages based on empirical evidence to support decision in language engineering. The developed process comprises an iterative execution of the phases DSL engineering, issue identification, data collection and evidence appraisal. We exemplify the concept by designing a DSL for Gherkin, a language test-driven acceptance testing in Xtext. The required evidence is derived by mining and analyzing all GitHub projects until July 1, 2017 that apply Gherkin.	domain-specific languages; DSL engineering; empirical research; evidence-based software engineering; repository mining	Felderer, Michael; Jeschko, Fabian	Proceedings of the 22nd International Conference on Evaluation and Assessment in Software Engineering 2018	Domain-specific languages (DSLs) are mainly designed ad-hoc and gut feeling resulting in languages that are often not well suited for their users and engineers. In this paper we develop a process for evidence-based language engineering to design domain-specific languages based on empirical evidence to support decision in language engineering. The developed process comprises an iterative execution of the phases DSL engineering, issue identification, data collection and evidence appraisal. We exemplify the concept by designing a DSL for Gherkin, a language test-driven acceptance testing in Xtext. The required evidence is derived by mining and analyzing all GitHub projects until July 1, 2017 that apply Gherkin.				Excluded	Excluded	new_screen			2						
84	Behave	Reproducing Failures Based on Semiformal Failure Scenario Descriptions	Due to the increasing size and complexity of software systems, it becomes hard to test these systems exhaustively. As a result, some faults can be left undetected. Undetected faults can lead to failures in deployed systems. Such failures are usually reported by the users from the field or test engineers back to developers. It requires considerable time and effort to analyze and reproduce the reported failures because their descriptions are not always complete, structured and formal. In this paper, we introduce a novel approach for automatically reproducing failures to aid their debugging. Our approach relies on semi-structured failure scenario descriptions that employ a set of keywords. These descriptions are preprocessed and mapped to a set of predefined test case templates with valid input sets. Then, test cases are generated and executed to reproduce the reported failure scenarios. The approach is evaluated with an industrial case study performed in a company from the telecommunications domain. Several failures were successfully reproduced. The approach is also adopted in the quality assurance process of the company. After one-time preparation of reusable test case templates and training of test engineers, 24.9 % of the reported failures (and 40 % of those that were manually reproducible) could be reproduced without any manual effort.	Behavior-driven development; Automated test case generation; Failure reproduction; Industrial case study	Karagöz, Gün; Sözer, Hasan	Software Quality Journal	Due to the increasing size and complexity of software systems, it becomes hard to test these systems exhaustively. As a result, some faults can be left undetected. Undetected faults can lead to failures in deployed systems. Such failures are usually reported by the users from the field or test engineers back to developers. It requires considerable time and effort to analyze and reproduce the reported failures because their descriptions are not always complete, structured and formal. In this paper, we introduce a novel approach for automatically reproducing failures to aid their debugging. Our approach relies on semi-structured failure scenario descriptions that employ a set of keywords. These descriptions are preprocessed and mapped to a set of predefined test case templates with valid input sets. Then, test cases are generated and executed to reproduce the reported failure scenarios. The approach is evaluated with an industrial case study performed in a company from the telecommunications domain. Several failures were successfully reproduced. The approach is also adopted in the quality assurance process of the company. After one-time preparation of reusable test case templates and training of test engineers, 24.9 % of the reported failures (and 40 % of those that were manually reproducible) could be reproduced without any manual effort.				Included	Included	new_screen			2						
85	Behave	Behaviour-driven requirements engineering for agile product line engineering	Due to the need of the software development community to integrate the flexibility and the high responsiveness of agile software development with the economic advantages, of reuse and mass customisation, offered by product lines, agile product line engineering has been gaining a momentum of attention from both researchers and practitioners. Developing and managing the different requirements engineering phases of product lines present is a dilemma that the efforts done in the literature was not able to effectively and efficiently resolve. To realise the full potential of agile product line engineering in practice, a complete, consistent, correct, and unambiguous user requirements must be produced without investing that huge amount of time in the upfront domain engineering phase of a traditional software product line. In this proposal, a behaviour-driven cloud-based framework is introduced to develop and maintain software product lines in an agile-based environment. The approach relies on upfront automated testing to derive and manage core assets and variations of an agile-based software product line. The model is validated through an empirical study and the preliminary results are very promising. © 2019 IEEE.		Elshandidy H.	Proceedings of the IEEE International Conference on Requirements Engineering	Due to the need of the software development community to integrate the flexibility and the high responsiveness of agile software development with the economic advantages, of reuse and mass customisation, offered by product lines, agile product line engineering has been gaining a momentum of attention from both researchers and practitioners. Developing and managing the different requirements engineering phases of product lines present is a dilemma that the efforts done in the literature was not able to effectively and efficiently resolve. To realise the full potential of agile product line engineering in practice, a complete, consistent, correct, and unambiguous user requirements must be produced without investing that huge amount of time in the upfront domain engineering phase of a traditional software product line. In this proposal, a behaviour-driven cloud-based framework is introduced to develop and maintain software product lines in an agile-based environment. The approach relies on upfront automated testing to derive and manage core assets and variations of an agile-based software product line. The model is validated through an empirical study and the preliminary results are very promising. © 2019 IEEE.				Included	Included	new_screen			2						
86	Behave	From Requirements to Source Code: A Model-Driven Engineering Approach for RESTful Web Services	During the last few years, the REST architectural style has drastically changed the way web services are developed. Due to its transparent resource-oriented model, the RESTful paradigm has been incorporated into several development frameworks that allow rapid development and aspire to automate parts of the development process. However, most of the frameworks lack automation of essential web service functionality, such as authentication or database searching, while the end product is usually not fully compliant to REST. Furthermore, most frameworks rely heavily on domain specific modeling and require developers to be familiar with the employed modeling technologies. In this paper, we present a Model-Driven Engineering (MDE) engine that supports fast design and implementation of web services with advanced functionality. Our engine provides a front-end interface that allows developers to design their envisioned system through software requirements in multimodal formats. Input in the form of textual requirements and graphical storyboards is analyzed using natural language processing techniques and semantics, to semi-automatically construct the input model for the MDE engine. The engine subsequently applies model-to-model transformations to produce a RESTful, ready-to-deploy web service. The procedure is traceable, ensuring that changes in software requirements propagate to the underlying software artefacts and models. Upon assessing our methodology through a case study and measuring the effort reduction of using our tools, we conclude that our system can be effective for the fast design and implementation of web services, while it allows easy wrapping of services that have been engineered with traditional methods to the MDE realm.	Automated Software Engineering; Model-Driven Engineering; RESTful web services; Software requirements	Zolotas, Christoforos; Diamantopoulos, Themistoklis; Chatzidimitriou, Kyriakos C.; Symeonidis, Andreas L.	Automated Software Engg.	During the last few years, the REST architectural style has drastically changed the way web services are developed. Due to its transparent resource-oriented model, the RESTful paradigm has been incorporated into several development frameworks that allow rapid development and aspire to automate parts of the development process. However, most of the frameworks lack automation of essential web service functionality, such as authentication or database searching, while the end product is usually not fully compliant to REST. Furthermore, most frameworks rely heavily on domain specific modeling and require developers to be familiar with the employed modeling technologies. In this paper, we present a Model-Driven Engineering (MDE) engine that supports fast design and implementation of web services with advanced functionality. Our engine provides a front-end interface that allows developers to design their envisioned system through software requirements in multimodal formats. Input in the form of textual requirements and graphical storyboards is analyzed using natural language processing techniques and semantics, to semi-automatically construct the input model for the MDE engine. The engine subsequently applies model-to-model transformations to produce a RESTful, ready-to-deploy web service. The procedure is traceable, ensuring that changes in software requirements propagate to the underlying software artefacts and models. Upon assessing our methodology through a case study and measuring the effort reduction of using our tools, we conclude that our system can be effective for the fast design and implementation of web services, while it allows easy wrapping of services that have been engineered with traditional methods to the MDE realm.				Excluded	Excluded	new_screen			2						
87	Behave	Analysing Requirements Communication Using Use Case Specification and User Stories	Effective requirements communication is essential in software development projects due to the importance of understanding the requirements throughout the software development cycle. Software requirements can be specified in different formats, for instance using free texts or more structured forms, such as use cases and user stories used in Behavior Driven Development (BDD). We present a comparative analysis on the requirements communication dynamics using use case specification and user stories as the basis for mockups creation. We carried out an exploratory empirical study involving 16 students. The study comprised 3 steps: requirements specification, mockups construction, and inspection to investigate whether the mockups were in accordance with the specifications. Results show that there is no significant difference in using use case specification or user stories to communicate software requirements. Our findings suggest that different specification formats can provide similar results while communicating requirements, nonetheless the human factor should not be neglected.	Behavior Driven Development; experimental study; Requirements communication; requirements specification; use case	Oran, Ana Carolina; Nascimento, Elizamary; Santos, Gleison; Conte, Tayana	Proceedings of the 31st Brazilian Symposium on Software Engineering	Effective requirements communication is essential in software development projects due to the importance of understanding the requirements throughout the software development cycle. Software requirements can be specified in different formats, for instance using free texts or more structured forms, such as use cases and user stories used in Behavior Driven Development (BDD). We present a comparative analysis on the requirements communication dynamics using use case specification and user stories as the basis for mockups creation. We carried out an exploratory empirical study involving 16 students. The study comprised 3 steps: requirements specification, mockups construction, and inspection to investigate whether the mockups were in accordance with the specifications. Results show that there is no significant difference in using use case specification or user stories to communicate software requirements. Our findings suggest that different specification formats can provide similar results while communicating requirements, nonetheless the human factor should not be neglected.				Included	Included	new_screen			2						
88	Behave	Generating Testing Codes for Behavior-Driven Development from Problem Diagrams: A Tool-Based Approach	Eliciting requirements in their real-world contexts and creating and transforming visual models which can help lead to early designs of software is a challenging and time-consuming step in software engineering processes. In order to support the creation of these models and generate artifacts useful for software designs, we have developed the Problem-to-Design tool (PROD) based on Jackson's Problem Frames approach. The tool has been inspired by the work in the behavior-driven development community, which recommends that testing codes be generated as early as in the requirements engineering phase. The tool provides an open portal where multiple stakeholders can draw their own problem diagrams online, which can be used to generate use case narratives and testing codes for further behavior-driven development.	Problem Frames;problem progression;behavior-driven development	N. Gao; Z. Li	2016 IEEE 24th International Requirements Engineering Conference (RE)	Eliciting requirements in their real-world contexts and creating and transforming visual models which can help lead to early designs of software is a challenging and time-consuming step in software engineering processes. In order to support the creation of these models and generate artifacts useful for software designs, we have developed the Problem-to-Design tool (PROD) based on Jackson's Problem Frames approach. The tool has been inspired by the work in the behavior-driven development community, which recommends that testing codes be generated as early as in the requirements engineering phase. The tool provides an open portal where multiple stakeholders can draw their own problem diagrams online, which can be used to generate use case narratives and testing codes for further behavior-driven development.				Included	Included	new_screen			2						
89	Behave	Behavior-driven Development for Real-time Embedded Systems	Embedded systems are a class of computer systems that are typically characterized by a tight interaction with the physical environment. Various methodologies have been adopted for the development of such systems, ranging from traditional waterfall to modern agile techniques. One of the agile techniques that has recently attracted increasing attention is Behavior-Driven Development (BDD). BDD promotes the engagement of all stakeholders in every development iteration to minimize the misunderstanding between technical and non-technical stakeholders and, consequently, to speed up the development process and lower the costs. In this paper, we investigate the application of BDD to the development of embedded systems, especially focusing on the testing of timing requirements for real-time embedded software. In particular, we extend BDD with time-related concepts and propose an approach to generate test code for the verification of timing behavior of real-time embedded systems. Our approach offers more automation for the development of test code compared to existing BDD tools, thus minimizing the risk of timing faults and reducing development costs and time-to-market.		A. S. Nezhad; J. J. Lukkien; R. H. Mak	2018 IEEE 23rd International Conference on Emerging Technologies and Factory Automation (ETFA)	Embedded systems are a class of computer systems that are typically characterized by a tight interaction with the physical environment. Various methodologies have been adopted for the development of such systems, ranging from traditional waterfall to modern agile techniques. One of the agile techniques that has recently attracted increasing attention is Behavior-Driven Development (BDD). BDD promotes the engagement of all stakeholders in every development iteration to minimize the misunderstanding between technical and non-technical stakeholders and, consequently, to speed up the development process and lower the costs. In this paper, we investigate the application of BDD to the development of embedded systems, especially focusing on the testing of timing requirements for real-time embedded software. In particular, we extend BDD with time-related concepts and propose an approach to generate test code for the verification of timing behavior of real-time embedded systems. Our approach offers more automation for the development of test code compared to existing BDD tools, thus minimizing the risk of timing faults and reducing development costs and time-to-market.				Included	Included	new_screen			2						
90	Behave	Benchmark Driven Framework for Development of Emotion Sensing Support Systems	Emotion sensing support system to assist human decision making during interview scenario is a developing research field. This paper presents a new framework for the development of emotion sensing support systems that is a complete, easily extendible, flexible, and configurable environment with intensive benchmark capabilities. The design of the framework was inspired by behavior-driven development, agile software development technique. It provides: 1) effective collaboration platform between technological and psychological researches, and 2) intensive benchmarking capabilities to test the performance of the entire system as well as individual algorithms.	behavior-driven development; affect; emotion detection; sensor fusion	Polikovsky, Senya; Quiros-Ramirez, Maria Alejandra; Kameda, Yoshinori; Ohta, Yuichi; Burgoon, Judee	Proceedings of the 2012 European Intelligence and Security Informatics Conference	Emotion sensing support system to assist human decision making during interview scenario is a developing research field. This paper presents a new framework for the development of emotion sensing support systems that is a complete, easily extendible, flexible, and configurable environment with intensive benchmark capabilities. The design of the framework was inspired by behavior-driven development, agile software development technique. It provides: 1) effective collaboration platform between technological and psychological researches, and 2) intensive benchmarking capabilities to test the performance of the entire system as well as individual algorithms.				Excluded	Excluded	new_screen			2						
91	Behave	Benchmark Driven Framework for Development of Emotion Sensing Support Systems	Emotion sensing support system to assist human decision making during interview scenario is a developing research field. This paper presents a new framework for the development of emotion sensing support systems that is a complete, easily extendible, flexible, and configurable environment with intensive benchmark capabilities. The design of the framework was inspired by behavior-driven development, agile software development technique. It provides: (1) effective collaboration platform between technological and psychological researches, and (2) intensive benchmarking capabilities to test the performance of the entire system as well as individual algorithms.	affect;emotion detection;behavior-driven development;sensor fusion	S. Polikovsky; M. A. Quiros-Ramirez; Y. Kameda; Y. Ohta; J. Burgoon	2012 European Intelligence and Security Informatics Conference	Emotion sensing support system to assist human decision making during interview scenario is a developing research field. This paper presents a new framework for the development of emotion sensing support systems that is a complete, easily extendible, flexible, and configurable environment with intensive benchmark capabilities. The design of the framework was inspired by behavior-driven development, agile software development technique. It provides: (1) effective collaboration platform between technological and psychological researches, and (2) intensive benchmarking capabilities to test the performance of the entire system as well as individual algorithms.				Excluded	Excluded	new_screen			2						
92	Behave	Beyond Page Objects: Testing Web Applications with State Objects: Use States to Drive Your Tests	End-to-end testing of Web applications typically involves tricky interactions with Web pages by means of a framework such as Selenium WebDriver. The recommended method for hiding such Web-page intricacies is to use page objects, but there are questions to answer first: Which page objects should you create when testing Web applications? What actions should you include in a page object? Which test scenarios should you specify, given your page objects?		van Deursen, Arie	Queue	End-to-end testing of Web applications typically involves tricky interactions with Web pages by means of a framework such as Selenium WebDriver. The recommended method for hiding such Web-page intricacies is to use page objects, but there are questions to answer first: Which page objects should you create when testing Web applications? What actions should you include in a page object? Which test scenarios should you specify, given your page objects?				Excluded	Excluded	new_screen			2						
93	Behave	Ensuring the Consistency Between User Requirements and Graphical User Interfaces: A Behavior-Based Automated Approach	Ensuring the consistency between Graphical User Interfaces (GUIs) and user requirements is a critical aspect of the design process since it is through the GUIs that users perceive the system and experience the available features in order to achieve their goals. This paper presents an approach based on Behavior-Driven Development (BDD) which employs an ontology in order to provide automated assessment for web GUIs. The approach has been evaluated by exploiting user requirements described by a group of experts in the flight tickets e-commerce domain. Such requirements gave rise to a set of User Stories that have been used to automatically assess the GUIs of an existing web system for booking business trips. The results have shown our approach was able to identify different types of inconsistencies in the set of GUIs analyzed, allowing to build an effective correspondence between user requirements and their representation on the GUI. © 2019, Springer Nature Switzerland AG.		Rocha Silva T., Winckler M., Trætteberg H.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	Ensuring the consistency between Graphical User Interfaces (GUIs) and user requirements is a critical aspect of the design process since it is through the GUIs that users perceive the system and experience the available features in order to achieve their goals. This paper presents an approach based on Behavior-Driven Development (BDD) which employs an ontology in order to provide automated assessment for web GUIs. The approach has been evaluated by exploiting user requirements described by a group of experts in the flight tickets e-commerce domain. Such requirements gave rise to a set of User Stories that have been used to automatically assess the GUIs of an existing web system for booking business trips. The results have shown our approach was able to identify different types of inconsistencies in the set of GUIs analyzed, allowing to build an effective correspondence between user requirements and their representation on the GUI. © 2019, Springer Nature Switzerland AG.				Included	Included	new_screen			2						
94	Behave	A Practical Method for API Testing in the Context of Continuous Delivery and Behavior Driven Development	Enterprises are increasingly adopting an API-first approach to connect and expose software services. Saxo Bank is no exception to this. Crafting test suites for such APIs can seem straight forward due to the headless nature, but our experience shows that test suites often have two problems. The first problem is that execution of tests tends to fail and pass in seemingly nondeterministic ways (tests are flaky). The second problem is that functional coverage is not clearly documented. We have found that both problems stem from a lack of explicit focus on initial context (IC), a concept from behavior driven development. When a test is flaky it is often because actual IC in the test environment is not as required by the test. When functional coverage is not clear, it is most often because a systematic analysis involving IC was not performed. We propose a method for test analysis in which we include IC in the input space when analyzing functional coverage for an API, thereby including anything which can influence the outcome of test cases. Establishing IC is in general a hard problem. We have found that focus on the bounded context, a concept from domain driven design, of the system under test is a practical way to establish relevant IC. Experience with Saxo Bank's Open API shows that this method allows testers and developers to cooperate continuously, producing test plan documents which include the reasoning behind functional coverage. Explicit focus on IC in automated test case implementations turns flaky tests into tests which report on required IC in a test environment. The method easily generalizes to all levels of API tests.	Combinatorial Testing;API Testing;Behavior Driven Development;Domain Driven Design;Continuous Delivery;Industry;Application	B. E. Bennett	2021 IEEE International Conference on Software Testing, Verification and Validation Workshops (ICSTW)	Enterprises are increasingly adopting an API-first approach to connect and expose software services. Saxo Bank is no exception to this. Crafting test suites for such APIs can seem straight forward due to the headless nature, but our experience shows that test suites often have two problems. The first problem is that execution of tests tends to fail and pass in seemingly nondeterministic ways (tests are flaky). The second problem is that functional coverage is not clearly documented. We have found that both problems stem from a lack of explicit focus on initial context (IC), a concept from behavior driven development. When a test is flaky it is often because actual IC in the test environment is not as required by the test. When functional coverage is not clear, it is most often because a systematic analysis involving IC was not performed. We propose a method for test analysis in which we include IC in the input space when analyzing functional coverage for an API, thereby including anything which can influence the outcome of test cases. Establishing IC is in general a hard problem. We have found that focus on the bounded context, a concept from domain driven design, of the system under test is a practical way to establish relevant IC. Experience with Saxo Bank's Open API shows that this method allows testers and developers to cooperate continuously, producing test plan documents which include the reasoning behind functional coverage. Explicit focus on IC in automated test case implementations turns flaky tests into tests which report on required IC in a test environment. The method easily generalizes to all levels of API tests.				Excluded	Excluded	new_screen			2						
95	Behave	Ensuring the Consistency between User Requirements and Task Models: A Behavior-Based Automated Approach	Evaluating and ensuring the consistency between user requirements and modeling artifacts is a long-time issue for model-based software design. Conflicts in requirements specifications can lead to many design errors and have a decisive impact on the quality of systems under development. This article presents an approach based on Behavior-Driven Development (BDD) to provide automated assessment for task models, which are intended to model the flow of user and system tasks in an interactive system. The approach has been evaluated by exploiting user requirements described by a group of experts in the domain of business trips. Such requirements gave rise to a set of BDD stories that have been used to automatically assess scenarios extracted from task models that were reengineered from an existing web system for booking business trips. The results have shown our approach, by performing a static analysis of the source files, was able to identify different types of inconsistencies between the user requirements and the set of task models analyzed.	automated requirements assessment; behavior-driven development (BDD); task models; user stories	Rocha Silva, Thiago; Winckler, Marco; Trætteberg, Hallvard	Proc. ACM Hum.-Comput. Interact.	Evaluating and ensuring the consistency between user requirements and modeling artifacts is a long-time issue for model-based software design. Conflicts in requirements specifications can lead to many design errors and have a decisive impact on the quality of systems under development. This article presents an approach based on Behavior-Driven Development (BDD) to provide automated assessment for task models, which are intended to model the flow of user and system tasks in an interactive system. The approach has been evaluated by exploiting user requirements described by a group of experts in the domain of business trips. Such requirements gave rise to a set of BDD stories that have been used to automatically assess scenarios extracted from task models that were reengineered from an existing web system for booking business trips. The results have shown our approach, by performing a static analysis of the source files, was able to identify different types of inconsistencies between the user requirements and the set of task models analyzed.				Included	Included	new_screen			2						
96	Behave	Ensuring the Consistency between User Requirements and Task Models: A Behavior-Based Automated Approach	Evaluating and ensuring the consistency between user requirements and modeling artifacts is a long-time issue for model-based software design. Conflicts in requirements specifications can lead to many design errors and have a decisive impact on the quality of systems under development. This article presents an approach based on Behavior-Driven Development (BDD) to provide automated assessment for task models, which are intended to model the flow of user and system tasks in an interactive system. The approach has been evaluated by exploiting user requirements described by a group of experts in the domain of business trips. Such requirements gave rise to a set of BDD stories that have been used to automatically assess scenarios extracted from task models that were reengineered from an existing web system for booking business trips. The results have shown our approach, by performing a static analysis of the source files, was able to identify different types of inconsistencies between the user requirements and the set of task models analyzed. © 2020 ACM.		Rocha Silva T., Winckler M., Trætteberg H.	Proceedings of the ACM on Human-Computer Interaction	Evaluating and ensuring the consistency between user requirements and modeling artifacts is a long-time issue for model-based software design. Conflicts in requirements specifications can lead to many design errors and have a decisive impact on the quality of systems under development. This article presents an approach based on Behavior-Driven Development (BDD) to provide automated assessment for task models, which are intended to model the flow of user and system tasks in an interactive system. The approach has been evaluated by exploiting user requirements described by a group of experts in the domain of business trips. Such requirements gave rise to a set of BDD stories that have been used to automatically assess scenarios extracted from task models that were reengineered from an existing web system for booking business trips. The results have shown our approach, by performing a static analysis of the source files, was able to identify different types of inconsistencies between the user requirements and the set of task models analyzed. © 2020 ACM.				Included	Included	new_screen			2						
97	Behave	A Study of Value in Agile Software Development Organizations	Examines how Value is interpreted in 14 agile software development organizations.Data is collected from 13 project managers and 10 product owners.Sixteen categories of Value Aspects are identified and prioritized.The most important Value Aspect is Delivery process w.r.t. time.The most used activity to achieve Value is activities related to agile practices. The Agile manifesto focuses on the delivery of valuable software. In Lean, the principles emphasise value, where every activity that does not add value is seen as waste. Despite the strong focus on value, and that the primary critical success factor for software intensive product development lies in the value domain, no empirical study has investigated specifically what value is. This paper presents an empirical study that investigates how value is interpreted and prioritised, and how value is assured and measured. Data was collected through semi-structured interviews with 23 participants from 14 agile software development organisations. The contribution of this study is fourfold. First, it examines how value is perceived amongst agile software development organisations. Second, it compares the perceptions and priorities of the perceived values by domains and roles. Third, it includes an examination of what practices are used to achieve value in industry, and what hinders the achievement of value. Fourth, it characterises what measurements are used to assure, and evaluate value-creation activities.	Agile software development; Empirical; Value	Alahyari, Hiva; Berntsson Svensson, Richard; Gorschek, Tony	J. Syst. Softw.	Examines how Value is interpreted in 14 agile software development organizations.Data is collected from 13 project managers and 10 product owners.Sixteen categories of Value Aspects are identified and prioritized.The most important Value Aspect is Delivery process w.r.t. time.The most used activity to achieve Value is activities related to agile practices. The Agile manifesto focuses on the delivery of valuable software. In Lean, the principles emphasise value, where every activity that does not add value is seen as waste. Despite the strong focus on value, and that the primary critical success factor for software intensive product development lies in the value domain, no empirical study has investigated specifically what value is. This paper presents an empirical study that investigates how value is interpreted and prioritised, and how value is assured and measured. Data was collected through semi-structured interviews with 23 participants from 14 agile software development organisations. The contribution of this study is fourfold. First, it examines how value is perceived amongst agile software development organisations. Second, it compares the perceptions and priorities of the perceived values by domains and roles. Third, it includes an examination of what practices are used to achieve value in industry, and what hinders the achievement of value. Fourth, it characterises what measurements are used to assure, and evaluate value-creation activities.				Excluded	Excluded	new_screen			2						
98	Behave	Domain-specific scenarios for refinement-based methods	Formal methods use abstraction and rigorously verified refinement to manage the design of complex systems, ensuring that they satisfy important invariant properties. However, formal verification is not sufficient: models must also be tested to ensure that they behave according to the informal requirements and validated by domain experts who may not be expert in formal modelling. This can be satisfied by scenarios that complement the requirements specification. The model can be animated to check whether the scenario is feasible in the model and that the model reaches the states expected in the scenario. However, there are two problems with this approach. 1) The natural language used to describe the scenarios is often verbose, ambiguous and therefore difficult to understand; especially if the modeller is not a domain expert. 2) Provided scenarios are typically at the most concrete level corresponding to the full requirements and cannot be used until all the refinements have been completed in the model. We show by example how a precise and concise domain specific language can be used for writing these abstract scenarios in a style that can be easily understood by the domain expert (for validation purposes) as well as the modeller (for behavioural verification) and can be used as the persistence for automated tool support. We propose two alternative approaches to using scenarios during formal modelling: A method of refining scenarios before the model is refined so that the scenarios guide the modelling, and a method of abstracting scenarios from provided concrete ones so that they can be used to test early refinements of the model. We illustrate the two approaches on the ‘Tokeneer’ secure enclave example and the ERTMS/ETCS Hybrid Level 3 specification for railway controls. We base our approach on the Cucumber framework for scenarios and the Event-B modelling language and tool set. We have developed a new ‘Scenario Checker’ plugin to manage the animation of scenarios.11The example model and scenario scripts supporting this paper are openly available at https://doi.org/10.5258/SOTON/D1026.	Event-B, Cucumber, Validation, Domain specific language	Snook, Colin; Hoang, Thai Son; Dghaym, Dana; Fathabadi, Asieh Salehi; Butler, Michael	Journal of Systems Architecture	Formal methods use abstraction and rigorously verified refinement to manage the design of complex systems, ensuring that they satisfy important invariant properties. However, formal verification is not sufficient: models must also be tested to ensure that they behave according to the informal requirements and validated by domain experts who may not be expert in formal modelling. This can be satisfied by scenarios that complement the requirements specification. The model can be animated to check whether the scenario is feasible in the model and that the model reaches the states expected in the scenario. However, there are two problems with this approach. 1) The natural language used to describe the scenarios is often verbose, ambiguous and therefore difficult to understand; especially if the modeller is not a domain expert. 2) Provided scenarios are typically at the most concrete level corresponding to the full requirements and cannot be used until all the refinements have been completed in the model. We show by example how a precise and concise domain specific language can be used for writing these abstract scenarios in a style that can be easily understood by the domain expert (for validation purposes) as well as the modeller (for behavioural verification) and can be used as the persistence for automated tool support. We propose two alternative approaches to using scenarios during formal modelling: A method of refining scenarios before the model is refined so that the scenarios guide the modelling, and a method of abstracting scenarios from provided concrete ones so that they can be used to test early refinements of the model. We illustrate the two approaches on the ‘Tokeneer’ secure enclave example and the ERTMS/ETCS Hybrid Level 3 specification for railway controls. We base our approach on the Cucumber framework for scenarios and the Event-B modelling language and tool set. We have developed a new ‘Scenario Checker’ plugin to manage the animation of scenarios.11The example model and scenario scripts supporting this paper are openly available at https://doi.org/10.5258/SOTON/D1026.				Excluded	Excluded	new_screen			2						
99	Behave	Behaviour-driven formal model development	Formal systems modelling offers a rigorous system-level analysis resulting in a precise and reliable specification. However, some issues remain: Modellers need to understand the requirements in order to formulate the models, formal verification may focus on safety properties rather than temporal behaviour, domain experts need to validate the final models to ensure they fit the needs of stakeholders. In this paper we discuss how the principles of Behaviour-Driven Development (BDD) can be applied to formal systems modelling and validation. We propose a process where manually authored scenarios are used initially to support the requirements and help the modeller. The same scenarios are used to verify behavioural properties of the model. The model is then mutated to automatically generate scenarios that have a more complete coverage than the manual ones. These automatically generated scenarios are used to animate the model in a final acceptance stage. For this acceptance stage, it is important that a domain expert decides whether or not the behaviour is useful. © Springer Nature Switzerland AG 2018.		Snook C., Hoang T.S., Dghyam D., Butler M., Fischer T., Schlick R., Wang K.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	Formal systems modelling offers a rigorous system-level analysis resulting in a precise and reliable specification. However, some issues remain: Modellers need to understand the requirements in order to formulate the models, formal verification may focus on safety properties rather than temporal behaviour, domain experts need to validate the final models to ensure they fit the needs of stakeholders. In this paper we discuss how the principles of Behaviour-Driven Development (BDD) can be applied to formal systems modelling and validation. We propose a process where manually authored scenarios are used initially to support the requirements and help the modeller. The same scenarios are used to verify behavioural properties of the model. The model is then mutated to automatically generate scenarios that have a more complete coverage than the manual ones. These automatically generated scenarios are used to animate the model in a final acceptance stage. For this acceptance stage, it is important that a domain expert decides whether or not the behaviour is useful. © Springer Nature Switzerland AG 2018.				Included	Included	new_screen			2						
100	Behave	The Merb Way	Foy is a gifted writer and his descriptions of the philosophies that( impacted the design and implementation of Merb are definitely useful to( everyone affected by the changes in Rails 3. Obie Fernandez, Series Editor The Expert Guide to Building Merb Applications Thousands of Ruby and Rails developers are discovering the extraordinary scalability, agility, flexibility, and performance offered by the new Merb MVC framework. The Merb Way is the first comprehensive guide to using, extending, and deploying Merb. Like the bestseller The Rails Way (Addison-Wesley, 2008), this book can either be read cover-to-cover as a tutorial or used for modular coverage that makes it an ideal task reference. Foy Savas systematically covers everything developers need to know to build production-quality Merb applications, offering detailed code examples for jumpstarting virtually any project. Savas is not only involved in the Merb project as an open source contributor: He uses Merb every day as a professional developer. Drawing on his extensive practical expertise, he delves deeply into the Merb frameworks architecture and source code, revealing its elegance and offering powerful best practices for using it. To maximize this books practical value, he also covers the tools most widely used alongside Merb, including the DataMapper ORM, the RSpec tester (and associated behavior-driven development techniques), and several leading Merb plugins. The Merb Way will help you Master Merb innovations that will be incorporated into Rails 3 Understand the fundamentals of Merb development, one step at a time Use Merbs sophisticated application router to guide incoming requests Explore the Merb stack, master its configuration options, and dive into its internals Use Merb controllers to integrate application code, handle responses, and manage sessions, filters, and exceptions Build templates with both ERB (Erubis) and HAML Use the DataMapper ORM to represent object properties and behaviors Learn best practices for RESTful development with Merb Leverage Helpers to simplify many common development tasks Refactor code, encapsulate it in gems, and share it across multiple applications Customize the responses your application sends to each user Gain a deep, practical understanding of Merb plugins and extensibility Authenticate users with Merbs modular authentication plugin Configure, generate, describe, and test Merb mailers Use the merb-parts gem to create component-like regions on Web pages Cache content to relieve stress on Web servers Make the most of Behavior Driven Development and testing with RSpec		Savas, Foy		Foy is a gifted writer and his descriptions of the philosophies that( impacted the design and implementation of Merb are definitely useful to( everyone affected by the changes in Rails 3. Obie Fernandez, Series Editor The Expert Guide to Building Merb Applications Thousands of Ruby and Rails developers are discovering the extraordinary scalability, agility, flexibility, and performance offered by the new Merb MVC framework. The Merb Way is the first comprehensive guide to using, extending, and deploying Merb. Like the bestseller The Rails Way (Addison-Wesley, 2008), this book can either be read cover-to-cover as a tutorial or used for modular coverage that makes it an ideal task reference. Foy Savas systematically covers everything developers need to know to build production-quality Merb applications, offering detailed code examples for jumpstarting virtually any project. Savas is not only involved in the Merb project as an open source contributor: He uses Merb every day as a professional developer. Drawing on his extensive practical expertise, he delves deeply into the Merb frameworks architecture and source code, revealing its elegance and offering powerful best practices for using it. To maximize this books practical value, he also covers the tools most widely used alongside Merb, including the DataMapper ORM, the RSpec tester (and associated behavior-driven development techniques), and several leading Merb plugins. The Merb Way will help you Master Merb innovations that will be incorporated into Rails 3 Understand the fundamentals of Merb development, one step at a time Use Merbs sophisticated application router to guide incoming requests Explore the Merb stack, master its configuration options, and dive into its internals Use Merb controllers to integrate application code, handle responses, and manage sessions, filters, and exceptions Build templates with both ERB (Erubis) and HAML Use the DataMapper ORM to represent object properties and behaviors Learn best practices for RESTful development with Merb Leverage Helpers to simplify many common development tasks Refactor code, encapsulate it in gems, and share it across multiple applications Customize the responses your application sends to each user Gain a deep, practical understanding of Merb plugins and extensibility Authenticate users with Merbs modular authentication plugin Configure, generate, describe, and test Merb mailers Use the merb-parts gem to create component-like regions on Web pages Cache content to relieve stress on Web servers Make the most of Behavior Driven Development and testing with RSpec				Excluded	Excluded	new_screen			2						
101	Behave	“BDD Assemble!”: A Paper-Based Game Proposal for Behavior Driven Development Design Learning	Game-based learning represents a promising alternative to teach computing in higher education. This paper presents “BDD Assemble!”, a paper-based game proposal for teaching Behavior Driven Development (BDD) competences. For this, the proposed game and the evaluation approach with software engineering students are described. As a result, a simple, interactive and colaborative game was provided, able to teach BDD concepts in a practical, competitive and fun way. © IFIP International Federation for Information Processing, 2019.		Sarinho V.T.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	Game-based learning represents a promising alternative to teach computing in higher education. This paper presents “BDD Assemble!”, a paper-based game proposal for teaching Behavior Driven Development (BDD) competences. For this, the proposed game and the evaluation approach with software engineering students are described. As a result, a simple, interactive and colaborative game was provided, able to teach BDD concepts in a practical, competitive and fun way. © IFIP International Federation for Information Processing, 2019.				Excluded	Excluded	new_screen			2						
102	Behave	JavaScript Testing with Jasmine: JavaScript Behavior-Driven Development	Get a concise introduction to Jasmine, the popular behavior-driven testing framework for JavaScript. This practical guide shows you how to write unit tests with Jasmine that automatically check for bugs in your application. Learn how to write specifications for individual components, and then use those specs to test the code you write.Throughout the book, author Evan Hahn focuses primarily on methods for testing browser-based JavaScript applications, but youll also discover how to use Jasmine with CoffeeScript, Node.js, Ruby on Rails, and Ruby without Rails. You wont find a more in-depth source for Jasmine anywhere.Get an overview of both test-driven and behavior-driven development Write useful specs by determining what you need to testand what you dont Test the behavior of new and existing code against the specs you create Apply Jasmine matchers and discover how to build your own Organize code suites into groups and subgroups as your code becomes more complex Use a Jasmine spy in place of a function or an objectand learn why its valuable		Hahn, Evan		Get a concise introduction to Jasmine, the popular behavior-driven testing framework for JavaScript. This practical guide shows you how to write unit tests with Jasmine that automatically check for bugs in your application. Learn how to write specifications for individual components, and then use those specs to test the code you write.Throughout the book, author Evan Hahn focuses primarily on methods for testing browser-based JavaScript applications, but youll also discover how to use Jasmine with CoffeeScript, Node.js, Ruby on Rails, and Ruby without Rails. You wont find a more in-depth source for Jasmine anywhere.Get an overview of both test-driven and behavior-driven development Write useful specs by determining what you need to testand what you dont Test the behavior of new and existing code against the specs you create Apply Jasmine matchers and discover how to build your own Organize code suites into groups and subgroups as your code becomes more complex Use a Jasmine spy in place of a function or an objectand learn why its valuable				Excluded	Excluded	new_screen			2						
103	Behave	A real-life application of multi-agent systems for fault diagnosis in the provision of an Internet business service	Given that telecommunications networks are constantly growing in complexity and heterogeneity, management systems have to work with incomplete data, handle uncertain situations and deal with dynamic environments. In addition, the high competitiveness in the telecommunications market requires cost cutting and customer retention by providing reliable systems. Thus, improving fault diagnosis systems and reducing the mean time to repair with automatic systems is an important area of research for telecommunications companies. This paper presents a Fault Diagnosis Multi-Agent System (MAS) applied for the management of a business service of Telefónica Czech Republic. The proposed MAS is based on an extended Belief-Desire-Intention (BDI) model that combines heterogeneous reasoning processes, ontology-based reasoning and Bayesian reasoning. This hybrid diagnostic technique is described in detail in the paper. The system has been evaluated with data collected during one and a half years of system operation on a live network. The main benefits of the system have been a significant reduction in both the average incident solution time and the mean diagnosis time.	Network management, Agent, Bayesian network, Diagnosis, Uncertainty, BDI	Carrera, Álvaro; Iglesias, Carlos A.; García-Algarra, Javier; Kolařík, Dušan	Journal of Network and Computer Applications	Given that telecommunications networks are constantly growing in complexity and heterogeneity, management systems have to work with incomplete data, handle uncertain situations and deal with dynamic environments. In addition, the high competitiveness in the telecommunications market requires cost cutting and customer retention by providing reliable systems. Thus, improving fault diagnosis systems and reducing the mean time to repair with automatic systems is an important area of research for telecommunications companies. This paper presents a Fault Diagnosis Multi-Agent System (MAS) applied for the management of a business service of Telefónica Czech Republic. The proposed MAS is based on an extended Belief-Desire-Intention (BDI) model that combines heterogeneous reasoning processes, ontology-based reasoning and Bayesian reasoning. This hybrid diagnostic technique is described in detail in the paper. The system has been evaluated with data collected during one and a half years of system operation on a live network. The main benefits of the system have been a significant reduction in both the average incident solution time and the mean diagnosis time.				Excluded	Excluded	new_screen			2						
104	Behave	Behavior-driven development (BDD) Cucumber Katalon for Automation GUI testing case CURA and Swag Labs	Graphical user interface (GUI) is widely used in software applications. About 50% of the application code is for GUI implementation. Because labor costs are high and demands for high-quality software are increasing, automation GUI testing will be a good investment for any software company. We will apply the Behavior-driven development (BDD) method for automation GUI testing with the Cucumber framework on the CURA and Swag Labs web applications. The BDD methodology used is based on the NLP (natural language program) concept. Where the information of semi-automatically produce a step definition and code framework. The scenarios are given on the natural language and then applied to Software Testing. Class diagrams and sequence diagrams are also applied to each represent a code framework automatically. The author uses Katalon Studio software. It was found that the results of the test case automation GUI testing on the CURA website with 210 steps passed, 3 step warnings with average responses times in the test case were 1.92 minutes. The results of the test case automation GUI testing on the Swag Labs web with 87 where 36 steps failed, 4 step warning and 44 step passed with an average responses times in the test case are 2,122 minutes.	Empirical Software Engineering;Software Testing Automation;GUI Testing;Behavior-driven Development;Cucumber	R. Broer Bahaweres; E. Oktaviani; L. Kesuma Wardhani; I. Hermadi; A. Suroso; I. Permana Solihin; Y. Arkeman	2020 International Conference on Informatics, Multimedia, Cyber and Information System (ICIMCIS)	Graphical user interface (GUI) is widely used in software applications. About 50% of the application code is for GUI implementation. Because labor costs are high and demands for high-quality software are increasing, automation GUI testing will be a good investment for any software company. We will apply the Behavior-driven development (BDD) method for automation GUI testing with the Cucumber framework on the CURA and Swag Labs web applications. The BDD methodology used is based on the NLP (natural language program) concept. Where the information of semi-automatically produce a step definition and code framework. The scenarios are given on the natural language and then applied to Software Testing. Class diagrams and sequence diagrams are also applied to each represent a code framework automatically. The author uses Katalon Studio software. It was found that the results of the test case automation GUI testing on the CURA website with 210 steps passed, 3 step warnings with average responses times in the test case were 1.92 minutes. The results of the test case automation GUI testing on the Swag Labs web with 87 where 36 steps failed, 4 step warning and 44 step passed with an average responses times in the test case are 2,122 minutes.				Included	Included	new_screen			2						
105	Behave	Behaviour driven development for hardware design	Hardware verification requires a lot of effort. A recent study showed that on average, there are more verification engineers working on a project than design engineers. Hence, one of the biggest challenges in design and verification today is to find new ways to increase the productivity. For software development the agile methodology as an incremental approach has been proposed and is heavily used. Behavior Driven Development (BDD) as an agile technique additionally enables a direct link to natural language based testing. In this article, we show how BDD can be extended to make it viable for hardware design. In addition, we present a two-fold strategy which allows to specify textual acceptance tests and textual formal properties. Finally, this strategy is complemented by methods to generalize tests to properties, and to enhance design understanding by presenting debug and witness scenarios in natural language. © 2018 Information Processing Society of Japan.		Diepenbeck M., Kühne U., Soeken M., Grosse D., Drechsler R.	IPSJ Transactions on System LSI Design Methodology	Hardware verification requires a lot of effort. A recent study showed that on average, there are more verification engineers working on a project than design engineers. Hence, one of the biggest challenges in design and verification today is to find new ways to increase the productivity. For software development the agile methodology as an incremental approach has been proposed and is heavily used. Behavior Driven Development (BDD) as an agile technique additionally enables a direct link to natural language based testing. In this article, we show how BDD can be extended to make it viable for hardware design. In addition, we present a two-fold strategy which allows to specify textual acceptance tests and textual formal properties. Finally, this strategy is complemented by methods to generalize tests to properties, and to enhance design understanding by presenting debug and witness scenarios in natural language. © 2018 Information Processing Society of Japan.				Included	Included	new_screen			2						
106	Behave	Using acceptance tests to predict files changed by programming tasks	In a collaborative development context, conflicting code changes might compromise software quality and developers productivity. To reduce conflicts, one could avoid the parallel execution of potentially conflicting tasks. Although hopeful, this strategy is challenging because it relies on the prediction of the required file changes to complete a task. As predicting such file changes is hard, we investigate its feasibility for BDD (Behaviour-Driven Development) projects, which write automated acceptance tests before implementing features. We develop a tool that, for a given task, statically analyzes Cucumber tests and infers test-based interfaces (files that could be executed by the tests), approximating files that would be changed by the task. To assess the accuracy of this approximation, we measure precision and recall of test-based interfaces of 513 tasks from 18 Rails projects on GitHub. We also compare such interfaces with randomly defined interfaces, interfaces obtained by textual similarity of test specifications with past tasks, and interfaces computed by executing tests. Our results give evidence that, in the specific context of BDD, Cucumber tests might help to predict files changed by tasks. We find that the better the test coverage, the better the predictive power. A hybrid approach for computing test-based interfaces is promising.	Collaborative development, Task scheduling, Behaviour-driven development, File change prediction	Rocha, Thaís; Borba, Paulo; Santos, João Pedro	Journal of Systems and Software	In a collaborative development context, conflicting code changes might compromise software quality and developers productivity. To reduce conflicts, one could avoid the parallel execution of potentially conflicting tasks. Although hopeful, this strategy is challenging because it relies on the prediction of the required file changes to complete a task. As predicting such file changes is hard, we investigate its feasibility for BDD (Behaviour-Driven Development) projects, which write automated acceptance tests before implementing features. We develop a tool that, for a given task, statically analyzes Cucumber tests and infers test-based interfaces (files that could be executed by the tests), approximating files that would be changed by the task. To assess the accuracy of this approximation, we measure precision and recall of test-based interfaces of 513 tasks from 18 Rails projects on GitHub. We also compare such interfaces with randomly defined interfaces, interfaces obtained by textual similarity of test specifications with past tasks, and interfaces computed by executing tests. Our results give evidence that, in the specific context of BDD, Cucumber tests might help to predict files changed by tasks. We find that the better the test coverage, the better the predictive power. A hybrid approach for computing test-based interfaces is promising.				Included	Included	new_screen			2						
107	Behave	Ensuring the Consistency Between User Requirements and GUI Prototypes: A Behavior-Based Automated Approach	In a user-centered design process, graphical user interface (GUI) prototypes may be seen as an important early artifact to design and validate user requirements before making strong commitments with a full-fledged version of the user interface. Ensuring the consistency of GUI prototypes with other representations of the user requirements is then a critical aspect of the design process. This paper presents an approach which extends Behavior-Driven Development (BDD) by employing an ontology in order to provide automated assessment for GUI prototypes as design artifacts. The approach has been evaluated by exploiting user requirements described by a group of experts in the flight tickets e-commerce domain. Such requirements gave rise to a set of User Stories that have been used to automatically check the consistency of Balsamiq prototypes which were reengineered from an existing web system for booking business trips. The results have shown our approach was able to identify different types of inconsistencies in the set of analyzed artifacts, allowing to build an effective correspondence between user requirements and their representation in GUI prototypes. © IFIP International Federation for Information Processing 2019.		Rocha Silva T., Winckler M., Trætteberg H.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	In a user-centered design process, graphical user interface (GUI) prototypes may be seen as an important early artifact to design and validate user requirements before making strong commitments with a full-fledged version of the user interface. Ensuring the consistency of GUI prototypes with other representations of the user requirements is then a critical aspect of the design process. This paper presents an approach which extends Behavior-Driven Development (BDD) by employing an ontology in order to provide automated assessment for GUI prototypes as design artifacts. The approach has been evaluated by exploiting user requirements described by a group of experts in the flight tickets e-commerce domain. Such requirements gave rise to a set of User Stories that have been used to automatically check the consistency of Balsamiq prototypes which were reengineered from an existing web system for booking business trips. The results have shown our approach was able to identify different types of inconsistencies in the set of analyzed artifacts, allowing to build an effective correspondence between user requirements and their representation in GUI prototypes. © IFIP International Federation for Information Processing 2019.				Included	Included	new_screen			2						
108	Behave	Definition of a Behavior-Driven Model for Requirements Specification and Testing of Interactive Systems	In a user-centered development process, artifacts are aimed to evolve in iterative cycles until they meet users' requirements and then become the final product. Every cycle gives the opportunity to revise the design and to introduce new requirements which might affect the specification of artifacts that have been set in former development phases. Testing the consistency of multiple artifacts used to develop interactive systems every time that a new requirement is introduced it is a cumbersome and time consuming activity, especially if it should be done manually. For that we propose an approach based on Behavior-Driven Development (BDD) to support the automated assessment of artifacts along the development process of interactive systems. In order to prevent that test should be written to every type of artifact, we investigate the use of ontologies for specifying the test once and then run it in all artifacts sharing the ontological concepts.	Automated Requirements Checking;Behavior-Driven Development;Ontological Modeling;Prototyping;Multi-Artifact Testing	T. R. Silva	2016 IEEE 24th International Requirements Engineering Conference (RE)	In a user-centered development process, artifacts are aimed to evolve in iterative cycles until they meet users' requirements and then become the final product. Every cycle gives the opportunity to revise the design and to introduce new requirements which might affect the specification of artifacts that have been set in former development phases. Testing the consistency of multiple artifacts used to develop interactive systems every time that a new requirement is introduced it is a cumbersome and time consuming activity, especially if it should be done manually. For that we propose an approach based on Behavior-Driven Development (BDD) to support the automated assessment of artifacts along the development process of interactive systems. In order to prevent that test should be written to every type of artifact, we investigate the use of ontologies for specifying the test once and then run it in all artifacts sharing the ontological concepts.				Excluded	Excluded	new_screen			2						
109	Behave	Testing prototypes and final user interfaces through an ontological perspective for behavior-driven development	In a user-centered development process, prototypes evolve in iterative cycles until they meet users’ requirements and then become the final product. Every cycle gives the opportunity to revise the design and to introduce new requirements which might affect the specification of artifacts that have been set in former development phases. Testing the consistency of multiple artifacts used to develop interactive systems every time that a new requirement is introduced is a cumbersome activity, especially if it is done manually. This paper proposes an approach based on Behavior-Driven Development (BDD) to support the automated assessment of artifacts along the development process of interactive systems. The paper uses an ontology for specifying tests that can run over multiple artifacts sharing similar concepts. A case study testing Prototypes and Final User Interfaces is presented to demonstrate the feasibility of this approach in early phases of the design process, providing a continuous quality assurance of requirements, and helping clients and development teams to identify potential problems and inconsistencies before commitments with software implementation. © IFIP International Federation for Information Processing 2016.		Silva T.R., Hak J.-L., Winckler M.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	In a user-centered development process, prototypes evolve in iterative cycles until they meet users’ requirements and then become the final product. Every cycle gives the opportunity to revise the design and to introduce new requirements which might affect the specification of artifacts that have been set in former development phases. Testing the consistency of multiple artifacts used to develop interactive systems every time that a new requirement is introduced is a cumbersome activity, especially if it is done manually. This paper proposes an approach based on Behavior-Driven Development (BDD) to support the automated assessment of artifacts along the development process of interactive systems. The paper uses an ontology for specifying tests that can run over multiple artifacts sharing similar concepts. A case study testing Prototypes and Final User Interfaces is presented to demonstrate the feasibility of this approach in early phases of the design process, providing a continuous quality assurance of requirements, and helping clients and development teams to identify potential problems and inconsistencies before commitments with software implementation. © IFIP International Federation for Information Processing 2016.				Included	Included	new_screen			2						
110	Behave	A Domain Specific Test Language for Systems Integration	In avionic context, systems are complex, embedded, critical, reactive and real time. In this context, testing activities are predominant in a V development process. We propose to bring in some features coming from agile methods. System integration testing that means systems are tested individually and together in order to ensure that they all operate correctly. We focus on functional and system integration testing just before the ground testing phase. Nowadays, test procedures and test plans we studied are described in textual manner and are executed manually. We aim to provide a common specific language that improves communications for the team of test designers and between test designers and test performers. In the same manner as agile test frameworks, this language allows to structure the test procedures. Moreover, this language tends to facilitate the automatic execution of some parts of the procedures. We choose a domain specific language approach to design a first domain specific test language dedicated to networks system integration.	Domain Specific Language; Test procedure; Test system	Bussenot, Robin; Leblanc, Hervé; Percebois, Christian	Proceedings of the Scientific Workshop Proceedings of XP2016	In avionic context, systems are complex, embedded, critical, reactive and real time. In this context, testing activities are predominant in a V development process. We propose to bring in some features coming from agile methods. System integration testing that means systems are tested individually and together in order to ensure that they all operate correctly. We focus on functional and system integration testing just before the ground testing phase. Nowadays, test procedures and test plans we studied are described in textual manner and are executed manually. We aim to provide a common specific language that improves communications for the team of test designers and between test designers and test performers. In the same manner as agile test frameworks, this language allows to structure the test procedures. Moreover, this language tends to facilitate the automatic execution of some parts of the procedures. We choose a domain specific language approach to design a first domain specific test language dedicated to networks system integration.				Excluded	Excluded	new_screen			2						
111	Behave	Assisted Behavior Driven Development Using Natural Language Processing	In Behavior Driven Development (BDD), acceptance tests provide the starting point for the software design flow and serve as a basis for the communication between designers and stakeholders. In this agile software development technique, acceptance tests are written in natural language in order to ensure a common understanding between all members of the project. As a consequence, mapping the sentences to actual source code is the first step of the design flow, which is usually done manually.However, the scenarios described by the acceptance tests provide enough information in order to automatize the extraction of both the structure of the implementation and the test cases. In this work, we propose an assisted flow for BDD where the user enters into a dialog with the computer which suggests code pieces extracted from the sentences. For this purpose, natural language processing techniques are exploited. This allows for a semi-automatic transformation from acceptance tests to source code stubs and thus provides a first step towards an automatization of BDD.		Soeken, Mathias; Wille, Robert; Drechsler, Rolf	Proceedings of the 50th International Conference on Objects, Models, Components, Patterns	In Behavior Driven Development (BDD), acceptance tests provide the starting point for the software design flow and serve as a basis for the communication between designers and stakeholders. In this agile software development technique, acceptance tests are written in natural language in order to ensure a common understanding between all members of the project. As a consequence, mapping the sentences to actual source code is the first step of the design flow, which is usually done manually.However, the scenarios described by the acceptance tests provide enough information in order to automatize the extraction of both the structure of the implementation and the test cases. In this work, we propose an assisted flow for BDD where the user enters into a dialog with the computer which suggests code pieces extracted from the sentences. For this purpose, natural language processing techniques are exploited. This allows for a semi-automatic transformation from acceptance tests to source code stubs and thus provides a first step towards an automatization of BDD.				Included	Included	new_screen			2						
112	Behave	Maintaining behaviour driven development specifications: Challenges and opportunities	"In Behaviour-Driven Development (BDD) the behaviour of a software system is specified as a set of example interactions with the system using a ""Given-When-Then"" structure. These examples are expressed in high level domain-specific terms, and are executable. They thus act both as a specification of requirements and as tests that can verify whether the current system implementation provides the desired behaviour or not. This approach has many advantages but also presents some problems. When the number of examples grows, BDD specifications can become costly to maintain and extend. Some teams find that parts of the system are effectively frozen due to the challenges of finding and modifying the examples associated with them. We surveyed 75 BDD practitioners from 26 countries to understand the extent of BDD use, its benefits and challenges, and specifically the challenges of maintaining BDD specifications in practice. We found that BDD is in active use amongst respondents, and that the use of domain specific terms, improving communication among stakeholders, the executable nature of BDD specifications, and facilitating comprehension of code intentions are the main benefits of BDD. The results also showed that BDD specifications suffer the same maintenance challenges found in automated test suites more generally. We map the survey results to the literature, and propose 10 research opportunities in this area."	behaviour-driven development;test suite maintenance;test suite evolution	L. P. Binamungu; S. M. Embury; N. Konstantinou	2018 IEEE 25th International Conference on Software Analysis, Evolution and Reengineering (SANER)	"In Behaviour-Driven Development (BDD) the behaviour of a software system is specified as a set of example interactions with the system using a ""Given-When-Then"" structure. These examples are expressed in high level domain-specific terms, and are executable. They thus act both as a specification of requirements and as tests that can verify whether the current system implementation provides the desired behaviour or not. This approach has many advantages but also presents some problems. When the number of examples grows, BDD specifications can become costly to maintain and extend. Some teams find that parts of the system are effectively frozen due to the challenges of finding and modifying the examples associated with them. We surveyed 75 BDD practitioners from 26 countries to understand the extent of BDD use, its benefits and challenges, and specifically the challenges of maintaining BDD specifications in practice. We found that BDD is in active use amongst respondents, and that the use of domain specific terms, improving communication among stakeholders, the executable nature of BDD specifications, and facilitating comprehension of code intentions are the main benefits of BDD. The results also showed that BDD specifications suffer the same maintenance challenges found in automated test suites more generally. We map the survey results to the literature, and propose 10 research opportunities in this area."				Included	Included	new_screen			2						
113	Behave	Detecting duplicate examples in behaviour driven development specifications	In Behaviour-Driven Development (BDD), the behaviour of the software to be built is specified as a set of example interactions with the system, expressed using a “Given-When-Then” structure. The examples are written using customer language, and are readable by end-users. They are also executable, and act as tests that determine whether the implementation matches the desired behaviour or not. This approach can be effective in building a common understanding of the requirements, but it can also face problems. When the suites of examples grow large, they can be difficult and expensive to change. Duplication can creep in, and can be challenging to detect manually. Current tools for detecting duplication in code are also not effective for BDD examples. Moreover, human concerns of readability and clarity can rise. We present an approach for detecting duplication in BDD suites that is based around dynamic tracing, and describe an evaluation based on three open source systems.	behaviour-driven development;duplication detection;dynamic tracing	L. P. Binamungu; S. M. Embury; N. Konstantinou	2018 IEEE Workshop on Validation, Analysis and Evolution of Software Tests (VST)	In Behaviour-Driven Development (BDD), the behaviour of the software to be built is specified as a set of example interactions with the system, expressed using a “Given-When-Then” structure. The examples are written using customer language, and are readable by end-users. They are also executable, and act as tests that determine whether the implementation matches the desired behaviour or not. This approach can be effective in building a common understanding of the requirements, but it can also face problems. When the suites of examples grow large, they can be difficult and expensive to change. Duplication can creep in, and can be challenging to detect manually. Current tools for detecting duplication in code are also not effective for BDD examples. Moreover, human concerns of readability and clarity can rise. We present an approach for detecting duplication in BDD suites that is based around dynamic tracing, and describe an evaluation based on three open source systems.				Included	Included	new_screen			2						
114	Behave	Integrating Behavior Driven Development and Programming by Contract to Improve Correctness in Computer Programs	"In many professional development settings, Test Driven Development (TDD), and its evolutionary descendent, Behavior Driven Development (BDD) are increasingly being used to improve code quality and reducing error rates. While very valuable, they are considerably less rigorous than formal methodologies of program correctness via formal logic. A less rigorous methodology utilizing the ideas of formal methods but without requiring an actual full proof are also in use called ""Design by Contract"" (DBC) or ""Programming by Contract."" (PBC) This thesis will examine extending and combining the ideas behind TDD, BDD and DBC to improve the overall stability and quality of a system. It will examine using both TDD/BDD (hereinafter referred to as TDD) and PBC to enhance the quality of development throughout the software development life cycle, while aiding in the development and stabilization of sound architecture. A result of this examination is a tool that attempts to derive unit tests automatically by analyzing human written specifications for preconditions and post-conditions when coupled with data definitions. These results will be used to generate code to be run by a unit testing framework before deployment, either as part of a continuous integration environment or by individual developers. The tool will also attempt to generate wireframe classes implementing pre and post-conditions within the code and using runtime contract analysis to generate information when an exception occurs, thereby helping to automate verification of bug fixes. Ultimately, the tool produced would be useful in a non-academic environment as a utility to extend the benefit of design by contract combined with TDD to the agile space."		Schoeneman, Larry		"In many professional development settings, Test Driven Development (TDD), and its evolutionary descendent, Behavior Driven Development (BDD) are increasingly being used to improve code quality and reducing error rates. While very valuable, they are considerably less rigorous than formal methodologies of program correctness via formal logic. A less rigorous methodology utilizing the ideas of formal methods but without requiring an actual full proof are also in use called ""Design by Contract"" (DBC) or ""Programming by Contract."" (PBC) This thesis will examine extending and combining the ideas behind TDD, BDD and DBC to improve the overall stability and quality of a system. It will examine using both TDD/BDD (hereinafter referred to as TDD) and PBC to enhance the quality of development throughout the software development life cycle, while aiding in the development and stabilization of sound architecture. A result of this examination is a tool that attempts to derive unit tests automatically by analyzing human written specifications for preconditions and post-conditions when coupled with data definitions. These results will be used to generate code to be run by a unit testing framework before deployment, either as part of a continuous integration environment or by individual developers. The tool will also attempt to generate wireframe classes implementing pre and post-conditions within the code and using runtime contract analysis to generate information when an exception occurs, thereby helping to automate verification of bug fixes. Ultimately, the tool produced would be useful in a non-academic environment as a utility to extend the benefit of design by contract combined with TDD to the agile space."				Excluded	Excluded	new_screen			2						
115	Behave	Leveraging Natural-Language Requirements for Deriving Better Acceptance Criteria from Models	In many software and systems development projects, analysts specify requirements using a combination of modeling and natural language (NL). In such situations, systematic acceptance testing poses a challenge because defining the acceptance criteria (AC) to be met by the system under test has to account not only for the information in the (requirements) model but also that in the NL requirements. In other words, neither models nor NL requirements per se provide a complete picture of the information content relevant to AC. Our work in this paper is prompted by the observation that a reconciliation of the information content in NL requirements and models is necessary for obtaining precise AC. We perform such reconciliation by devising an approach that automatically extracts AC-related information from NL requirements and helps modelers enrich their model with the extracted information. An existing AC derivation technique is then applied to the model that has now been enriched by the information extracted from NL requirements.Using a real case study from the financial domain, we evaluate the usefulness of the AC-related model enrichments recommended by our approach. Our evaluation results are very promising: Over our case study system, a group of five domain experts found 89% of the recommended enrichments relevant to AC and yet absent from the original model (precision of 89%). Furthermore, the experts could not pinpoint any additional information in the NL requirements which was relevant to AC but which had not already been brought to their attention by our approach (recall of 100%).	acceptance criteria; gherkin; UML; acceptance testing; controlled natural language; requirements validation and verification	Veizaga, Alvaro; Alferez, Mauricio; Torre, Damiano; Sabetzadeh, Mehrdad; Briand, Lionel; Pitskhelauri, Elene	Proceedings of the 23rd ACM/IEEE International Conference on Model Driven Engineering Languages and Systems	In many software and systems development projects, analysts specify requirements using a combination of modeling and natural language (NL). In such situations, systematic acceptance testing poses a challenge because defining the acceptance criteria (AC) to be met by the system under test has to account not only for the information in the (requirements) model but also that in the NL requirements. In other words, neither models nor NL requirements per se provide a complete picture of the information content relevant to AC. Our work in this paper is prompted by the observation that a reconciliation of the information content in NL requirements and models is necessary for obtaining precise AC. We perform such reconciliation by devising an approach that automatically extracts AC-related information from NL requirements and helps modelers enrich their model with the extracted information. An existing AC derivation technique is then applied to the model that has now been enriched by the information extracted from NL requirements.Using a real case study from the financial domain, we evaluate the usefulness of the AC-related model enrichments recommended by our approach. Our evaluation results are very promising: Over our case study system, a group of five domain experts found 89% of the recommended enrichments relevant to AC and yet absent from the original model (precision of 89%). Furthermore, the experts could not pinpoint any additional information in the NL requirements which was relevant to AC but which had not already been brought to their attention by our approach (recall of 100%).				Excluded	Excluded	new_screen			2						
116	Behave	Toward A Service Platform for Developing Smart Contracts on Blockchain in BDD and TDD Styles	In recent years, Blockchain technology has been highly valued, and the related applications have begun to be developed in large numbers. A smart contract is a software component encompass business logics and transactions that run on a blockchain. Thus, verifying whether the contract logics fully reflect the business requirements are one of the most important software engineering issues in blockchain application development. Currently, developing smart contracts is still a challenging task even for experienced programmers due to the lacking of an integrated tool for developing and testing. In response to this challenge, this paper presents a service platform that supports BDD-style (Behavior-Driven Development) smart contract development, testing, and deployment for the Ethereum-based blockchains. This platform focuses on providing and resolving the cross-cutting concerns across the life-cycle of smart contract development. The feasibility of this platform is shown by demonstrating how an application scenario, namely, loyalty points exchange, can be implemented using the proposed platform. Our experiences indicate that the burdens of developers when developing smart contracts can be effectively reduced and thus increases the quality of contracts.	Blockchain;Smart contract;Behavior-Driven Development;Test-Driven Development	C. Liao; C. Cheng; K. Chen; C. Lai; T. Chiu; C. Wu-Lee	2017 IEEE 10th Conference on Service-Oriented Computing and Applications (SOCA)	In recent years, Blockchain technology has been highly valued, and the related applications have begun to be developed in large numbers. A smart contract is a software component encompass business logics and transactions that run on a blockchain. Thus, verifying whether the contract logics fully reflect the business requirements are one of the most important software engineering issues in blockchain application development. Currently, developing smart contracts is still a challenging task even for experienced programmers due to the lacking of an integrated tool for developing and testing. In response to this challenge, this paper presents a service platform that supports BDD-style (Behavior-Driven Development) smart contract development, testing, and deployment for the Ethereum-based blockchains. This platform focuses on providing and resolving the cross-cutting concerns across the life-cycle of smart contract development. The feasibility of this platform is shown by demonstrating how an application scenario, namely, loyalty points exchange, can be implemented using the proposed platform. Our experiences indicate that the burdens of developers when developing smart contracts can be effectively reduced and thus increases the quality of contracts.				Included	Included	new_screen			2						
117	Behave	Proposing Regulatory-Driven Automated Test Suites for Electronic Health Record Systems	In regulated domains such as finance and health care, failure to comply with regulation can lead to financial, civil and criminal penalties. While systems vary from organization to organization, regulations apply across organizations. We propose the use of Behavior-Driven-Development (BDD) scenarios as the basis of an automated compliance test suite for standards such as regulation and interoperability. Such test suites could become a shared asset for use by all systems subject to these regulations and standards. Each system, then, need only create their own system-specific test driver code to automate their compliance checks. The goal of this research is to enable organizations to compare their systems to regulation in a repeatable and traceable way through the use of BDD. To evaluate our proposal, we developed an abbreviated HIPAA test suite and applied it to three open-source electronic health record systems. The scenarios covered all security behavior defined by the selected regulation. The system-specific test driver code covered all security behavior defined in the scenarios, and identified where the tested system lacked such behavior.	software engineering; behavior-driven-development; healthcare it; regulatory compliance; security; software testing	Morrison, Patrick; Holmgreen, Casper; Massey, Aaron; Williams, Laurie	Proceedings of the 5th International Workshop on Software Engineering in Health Care	In regulated domains such as finance and health care, failure to comply with regulation can lead to financial, civil and criminal penalties. While systems vary from organization to organization, regulations apply across organizations. We propose the use of Behavior-Driven-Development (BDD) scenarios as the basis of an automated compliance test suite for standards such as regulation and interoperability. Such test suites could become a shared asset for use by all systems subject to these regulations and standards. Each system, then, need only create their own system-specific test driver code to automate their compliance checks. The goal of this research is to enable organizations to compare their systems to regulation in a repeatable and traceable way through the use of BDD. To evaluate our proposal, we developed an abbreviated HIPAA test suite and applied it to three open-source electronic health record systems. The scenarios covered all security behavior defined by the selected regulation. The system-specific test driver code covered all security behavior defined in the scenarios, and identified where the tested system lacked such behavior.				Included	Included	new_screen			2						
118	Behave	Proposing Regulatory-Driven Automated Test Suites	In regulated domains such as finance and health care, failure to comply with regulation can lead to financial, civil and criminal penalties. While systems vary from organization to organization, the same regulations apply for all systems. As a result, efficiencies could be gained if the commonalities between systems could be captured in public, shared, test suites for regulations. We propose the use of Behavior-Driven-Development (BDD) technology to create these test suites. With BDD, desired system behavior with respect to regulatory requirements can be captured as constrained natural language 'scenarios'. The scenarios can then be automated through system-specific test drivers. The goal of this research is to enable organizations to compare their systems to regulation in a repeatable and traceable way through the use of BDD. To evaluate our approach, we developed seven scenarios based on the HITECH Act Meaningful Use (MU) regulations for healthcare. We then created system-specific code for three open-source electronic health record systems. We found that it was possible to create scenarios and system-specific code supporting scenario execution on three systems, that iTrust can be shown to be noncompliant, and that emergency access procedures are not defined clearly enough by the regulation to determine compliance or non-compliance.	Software Testing; Security; Software Engineering; Behavior-Driven-Development; Healthcare IT; Regulatory Compliance	Morrison, Patrick; Holmgreen, Casper; Massey, Aaron; Williams, Laurie	Proceedings of the 2013 Agile Conference	In regulated domains such as finance and health care, failure to comply with regulation can lead to financial, civil and criminal penalties. While systems vary from organization to organization, the same regulations apply for all systems. As a result, efficiencies could be gained if the commonalities between systems could be captured in public, shared, test suites for regulations. We propose the use of Behavior-Driven-Development (BDD) technology to create these test suites. With BDD, desired system behavior with respect to regulatory requirements can be captured as constrained natural language 'scenarios'. The scenarios can then be automated through system-specific test drivers. The goal of this research is to enable organizations to compare their systems to regulation in a repeatable and traceable way through the use of BDD. To evaluate our approach, we developed seven scenarios based on the HITECH Act Meaningful Use (MU) regulations for healthcare. We then created system-specific code for three open-source electronic health record systems. We found that it was possible to create scenarios and system-specific code supporting scenario execution on three systems, that iTrust can be shown to be noncompliant, and that emergency access procedures are not defined clearly enough by the regulation to determine compliance or non-compliance.				Included	Included	new_screen			2						
119	Behave	Combining IID with BDD to Enhance the Critical Quality of Security Functional Requirements	In software system, functional requirements are primary system requirements. Client cannot explicitly depicted security requirements and the development team is hard to understand security requirements, makes security requirements difficult to specific implant software system. In software system development process, security requirements often neglected and ignored. However, the cost of correcting security flaws in maintenance phase is over 100 times in requirements phase. Can't effectively improve the system security, enterprises loss is bound to continue to expand. In order to enhance the security of software system, this paper combines the popular software development methodology IID (Interactive and Incremental Development) with BDD (Behavior Driven Development), institutionalized requires functional requirements must be integrated into security requirements. And, using BDD process features to evaluate the major quality of security functional requirements. Timely identifies and modifies the quality defects of security functional requirements item, effectively enhance the security of software systems.	BDD; functional requirements; IID; security functional requirements; security requirements	Lai, Sen-Tarng; Leu, Fang-Yie; Chu, William Cheng-Chung	Proceedings of the 2014 Ninth International Conference on Broadband and Wireless Computing, Communication and Applications	In software system, functional requirements are primary system requirements. Client cannot explicitly depicted security requirements and the development team is hard to understand security requirements, makes security requirements difficult to specific implant software system. In software system development process, security requirements often neglected and ignored. However, the cost of correcting security flaws in maintenance phase is over 100 times in requirements phase. Can't effectively improve the system security, enterprises loss is bound to continue to expand. In order to enhance the security of software system, this paper combines the popular software development methodology IID (Interactive and Incremental Development) with BDD (Behavior Driven Development), institutionalized requires functional requirements must be integrated into security requirements. And, using BDD process features to evaluate the major quality of security functional requirements. Timely identifies and modifies the quality defects of security functional requirements item, effectively enhance the security of software systems.				Included	Included	new_screen			2						
120	Behave	Test-Driven Development of Relational Databases	In test-first development, developers formulate and implement a detailed design iteratively, one test at a time. Test-driven development (also called test-driven design) combines TFD with refactoring, wherein developers make small changes (refactorings) to improve code design without changing the code's semantics. When developers decide to use TDD to implement a new feature, they must first ask whether the current design is the easiest possible design to enable the feature's addition. Implementing test-driven database design involves database refactoring, regression testing, and continuous integration. TDDD is an integrated part of the overall development process, not a standalone activity that data professionals perform in parallel with application TDD. Although from a technical view point, TDDD is relatively straightforward, we must overcome several challenges to its whole sale adoption throughout the IT community	test-driven development;TDD;database refactoring;database testing;test-driven database design;TDD;relational database;behavior-driven development;BDD	S. W. Ambler	IEEE Software	In test-first development, developers formulate and implement a detailed design iteratively, one test at a time. Test-driven development (also called test-driven design) combines TFD with refactoring, wherein developers make small changes (refactorings) to improve code design without changing the code's semantics. When developers decide to use TDD to implement a new feature, they must first ask whether the current design is the easiest possible design to enable the feature's addition. Implementing test-driven database design involves database refactoring, regression testing, and continuous integration. TDDD is an integrated part of the overall development process, not a standalone activity that data professionals perform in parallel with application TDD. Although from a technical view point, TDDD is relatively straightforward, we must overcome several challenges to its whole sale adoption throughout the IT community				Excluded	Excluded	new_screen			2						
121	Behave	Mobile Application Development: Automated Test Input Generation Via Model Inference based on User Story and Acceptance Criteria	In the past few years, there has been observed explosive growth in the development of Mobile Applications across Android and iOS operating system which has led to the direct impact towards mobile app development. In order to design and propose quality-oriented apps, it is the primary responsibility of the developers to devote time and sufficient efforts towards testing to make the Apps bug free and operational in the hands of end users without any hiccup. In order to test the mobile apps, manual testing procedures takes prolonged amount of time in writing test cases and even the full testing requirements are not met. In addition to this, lack of sufficient knowledge by the tester also impacts overall quality and assurance that app is bug free. To overcome all the issues of testing, and to assure that apps designed by developers are almost bug free, we propose a new testing methodology cum tool 'AgileUATM' which works primarily towards white-box and black-box testing. With this tool, all the test cases are generated automatically based on user stories and acceptance criteria by using formal specification and Z3 SMT solvers. To test the validity of the proposed tool, we applied the tool in real-time operational environment with regard to test Mobile apps. Using this tool, all the acceptance criteria is determined via user stories. The testers/developers specify requirements with formal specifications based on programs properties, predicates, invariants, and constraints. From the results, it is observed that the proposed tool i.e. AgileUATM generated effective and accurate test cases, test input, and expected output was generated in a unified fashion from the user stories to meet acceptance criteria. In addition to this, the tool also reduced the development time to identify test data as compared to manual Behavior Driven Development (BDD) methodologies. With this tool, the developers got better idea with regard to required tests and able to translate the customers natural languages to the computer language as well. © 2019 IEEE.		Iqbal H.	Proceeding of 2019 International Conference on Digitization: Landscaping Artificial Intelligence, ICD 2019	In the past few years, there has been observed explosive growth in the development of Mobile Applications across Android and iOS operating system which has led to the direct impact towards mobile app development. In order to design and propose quality-oriented apps, it is the primary responsibility of the developers to devote time and sufficient efforts towards testing to make the Apps bug free and operational in the hands of end users without any hiccup. In order to test the mobile apps, manual testing procedures takes prolonged amount of time in writing test cases and even the full testing requirements are not met. In addition to this, lack of sufficient knowledge by the tester also impacts overall quality and assurance that app is bug free. To overcome all the issues of testing, and to assure that apps designed by developers are almost bug free, we propose a new testing methodology cum tool 'AgileUATM' which works primarily towards white-box and black-box testing. With this tool, all the test cases are generated automatically based on user stories and acceptance criteria by using formal specification and Z3 SMT solvers. To test the validity of the proposed tool, we applied the tool in real-time operational environment with regard to test Mobile apps. Using this tool, all the acceptance criteria is determined via user stories. The testers/developers specify requirements with formal specifications based on programs properties, predicates, invariants, and constraints. From the results, it is observed that the proposed tool i.e. AgileUATM generated effective and accurate test cases, test input, and expected output was generated in a unified fashion from the user stories to meet acceptance criteria. In addition to this, the tool also reduced the development time to identify test data as compared to manual Behavior Driven Development (BDD) methodologies. With this tool, the developers got better idea with regard to required tests and able to translate the customers natural languages to the computer language as well. © 2019 IEEE.				Included	Included	new_screen			2						
122	Behave	Notice of Violation of IEEE Publication Principles: Mobile Application Development: Automated Test Input Generation Via Model Inference based on User Story and Acceptance Criteria	In the past few years, there has been observed explosive growth in the development of Mobile Applications across Android and iOS operating system which has led to the direct impact towards mobile app development. In order to design and propose quality-oriented apps, it is the primary responsibility of the developers to devote time and sufficient efforts towards testing to make the Apps bug free and operational in the hands of end users without any hiccup. In order to test the mobile apps, manual testing procedures takes prolonged amount of time in writing test cases and even the full testing requirements are not met. In addition to this, lack of sufficient knowledge by the tester also impacts overall quality and assurance that app is bug free. To overcome all the issues of testing, and to assure that apps designed by developers are almost bug free, we propose a new testing methodology cum tool “AgileUATM” which works primarily towards white-box and black-box testing. With this tool, all the test cases are generated automatically based on user stories and acceptance criteria by using formal specification and Z3 SMT solvers. To test the validity of the proposed tool, we applied the tool in real-time operational environment with regard to test Mobile apps. Using this tool, all the acceptance criteria is determined via user stories. The testers/developers specify requirements with formal specifications based on programs properties, predicates, invariants, and constraints. From the results, it is observed that the proposed tool i.e. AgileUATM generated effective and accurate test cases, test input, and expected output was generated in a unified fashion from the user stories to meet acceptance criteria. In addition to this, the tool also reduced the development time to identify test data as compared to manual Behavior Driven Development (BDD) methodologies. With this tool, the developers got better idea with regard to required tests and able to translate the customers natural languages to the computer language as well.;Notice of Violation of IEEE Publication Principles <br><br> “Mobile Application Development: Automated Test Input Generation Via Model Inference based on User Story and Acceptance Criteria” <br> by Hena Iqbal <br> in the Proceedings of the International Conference on Digitization (ICD), November 2019, pp. 92-103 <br><br> After careful and considered review of the content and authorship of this paper by a duly constituted expert committee, this paper has been found to be in violation of IEEE’s Publication Principles. <br><br> This paper is a near duplication of the original text from the paper cited below. The original text was copied without attribution (including appropriate references to the original author(s) and/or paper title) and without permission. <br><br> Due to the nature of this violation, reasonable effort should be made to remove all past references to this paper, and future references should be made to the following article: <br><br> “Automated Test Input Generation via Model Inference Based on User Story and Acceptance Criteria for Mobile Application Development” <br> by Duc-Man Nguyen, Quyet-Thang Huynh, Nhu-Hang Ha and Thanh-Hung Nguyen <br> in the International Journal of Software Engineering and Knowledge Engineering, Vol. 30, No. 3 2020, pp. 399-425 <br><br>		H. Iqbal	2019 International Conference on Digitization (ICD)	In the past few years, there has been observed explosive growth in the development of Mobile Applications across Android and iOS operating system which has led to the direct impact towards mobile app development. In order to design and propose quality-oriented apps, it is the primary responsibility of the developers to devote time and sufficient efforts towards testing to make the Apps bug free and operational in the hands of end users without any hiccup. In order to test the mobile apps, manual testing procedures takes prolonged amount of time in writing test cases and even the full testing requirements are not met. In addition to this, lack of sufficient knowledge by the tester also impacts overall quality and assurance that app is bug free. To overcome all the issues of testing, and to assure that apps designed by developers are almost bug free, we propose a new testing methodology cum tool “AgileUATM” which works primarily towards white-box and black-box testing. With this tool, all the test cases are generated automatically based on user stories and acceptance criteria by using formal specification and Z3 SMT solvers. To test the validity of the proposed tool, we applied the tool in real-time operational environment with regard to test Mobile apps. Using this tool, all the acceptance criteria is determined via user stories. The testers/developers specify requirements with formal specifications based on programs properties, predicates, invariants, and constraints. From the results, it is observed that the proposed tool i.e. AgileUATM generated effective and accurate test cases, test input, and expected output was generated in a unified fashion from the user stories to meet acceptance criteria. In addition to this, the tool also reduced the development time to identify test data as compared to manual Behavior Driven Development (BDD) methodologies. With this tool, the developers got better idea with regard to required tests and able to translate the customers natural languages to the computer language as well.;Notice of Violation of IEEE Publication Principles <br><br> “Mobile Application Development: Automated Test Input Generation Via Model Inference based on User Story and Acceptance Criteria” <br> by Hena Iqbal <br> in the Proceedings of the International Conference on Digitization (ICD), November 2019, pp. 92-103 <br><br> After careful and considered review of the content and authorship of this paper by a duly constituted expert committee, this paper has been found to be in violation of IEEE’s Publication Principles. <br><br> This paper is a near duplication of the original text from the paper cited below. The original text was copied without attribution (including appropriate references to the original author(s) and/or paper title) and without permission. <br><br> Due to the nature of this violation, reasonable effort should be made to remove all past references to this paper, and future references should be made to the following article: <br><br> “Automated Test Input Generation via Model Inference Based on User Story and Acceptance Criteria for Mobile Application Development” <br> by Duc-Man Nguyen, Quyet-Thang Huynh, Nhu-Hang Ha and Thanh-Hung Nguyen <br> in the International Journal of Software Engineering and Knowledge Engineering, Vol. 30, No. 3 2020, pp. 399-425 <br><br>				Excluded	Excluded	new_screen			2						
123	Behave	Combination of Test-Driven Development and Behavior-Driven Development for Improving Backend Testing Performance	In the process of software development, a testing phase is an important step for detecting the errors. In order to produce a reliable application, this paper discusses the utilization of a combination from two different testing methods, Test- Driven Development (TDD) and Behavior Driven Development (BDD). TDD testing method is a process with a high percentage of code which is tested automatically. However, it could lead to an error when the parameters of the features are changed. Meanwhile, the BDD testing method is a testing method that could perform successfully despite changes to the parameters of the features. This paper discusses the combination of TDD and BDD testing methods, which is called as T-BDD method. By implementing T-BDD into the Vixio backend system, this paper successfully shows that it could be performed to achieve a high percentage of test-coverage while it could also adapt when the parameters of the features were changed. This paper also shows that the T-BDD testing method performed better compared to using the TDD testing method only.	Unit Test, Test-Driven Development (TDD), Behavior-Driven Development(BDD), Backend, Web Application	Kerthyayana Manuaba, Ida Bagus	Procedia Computer Science	In the process of software development, a testing phase is an important step for detecting the errors. In order to produce a reliable application, this paper discusses the utilization of a combination from two different testing methods, Test- Driven Development (TDD) and Behavior Driven Development (BDD). TDD testing method is a process with a high percentage of code which is tested automatically. However, it could lead to an error when the parameters of the features are changed. Meanwhile, the BDD testing method is a testing method that could perform successfully despite changes to the parameters of the features. This paper discusses the combination of TDD and BDD testing methods, which is called as T-BDD method. By implementing T-BDD into the Vixio backend system, this paper successfully shows that it could be performed to achieve a high percentage of test-coverage while it could also adapt when the parameters of the features were changed. This paper also shows that the T-BDD testing method performed better compared to using the TDD testing method only.				Included	Included	new_screen			2						
124	Behave	Requirements behaviour analysis for ontology testing	In the software engineering field, every software product is delivered with its pertinent associated tests which verify its correct behaviour. Besides, there are several approaches which, integrated in the software development process, deal with software testing, such as unit testing or behaviour-driven development. However, in the ontology engineering field there is a lack of clearly defined testing processes that can be integrated into the ontology development process. In this paper we propose a testing framework composed by a set of activities (i.e., test design, implementation and execution), with the goal of checking whether the requirements identified are satisfied by the formalization and analysis of their expected behaviour. This testing framework can be used in different types of ontology development life-cycles, or concerning other goals such as conformance testing between ontologies. In addition to this, we propose an RDF vocabulary to store, publish and reuse these test cases and their results, in order to allow traceability between the ontology, the test cases and their requirements. We validate our approach by integrating the testing framework into an ontology engineering process where an ontology network has been developed following agile principles. © Springer Nature Switzerland AG 2018.		Fernández-Izquierdo A., García-Castro R.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	In the software engineering field, every software product is delivered with its pertinent associated tests which verify its correct behaviour. Besides, there are several approaches which, integrated in the software development process, deal with software testing, such as unit testing or behaviour-driven development. However, in the ontology engineering field there is a lack of clearly defined testing processes that can be integrated into the ontology development process. In this paper we propose a testing framework composed by a set of activities (i.e., test design, implementation and execution), with the goal of checking whether the requirements identified are satisfied by the formalization and analysis of their expected behaviour. This testing framework can be used in different types of ontology development life-cycles, or concerning other goals such as conformance testing between ontologies. In addition to this, we propose an RDF vocabulary to store, publish and reuse these test cases and their results, in order to allow traceability between the ontology, the test cases and their requirements. We validate our approach by integrating the testing framework into an ontology engineering process where an ontology network has been developed following agile principles. © Springer Nature Switzerland AG 2018.				Excluded	Excluded	new_screen			2						
125	Behave	Skyfire: Model-Based Testing with Cucumber	In the software industry, a Behavior-Driven Development (BDD) tool, Cucumber, has been widely used by practitioners. Usually product analysts, developers, and testers manually write BDD test scenarios that describe system behaviors. Testers write implementation for the BDD scenarios by hand and execute the Cucumber tests. Cucumber provides transparency about what test scenarios are covered and how the test scenarios are mapped to executable tests. One drawback of the Cucumber BDD approach is that test scenarios are generated manually. Thus, the test scenarios are usually weak. More importantly, practitioners do not have a metric to measure test coverage. In this paper, we present a Model-Based Testing (MBT) tool, skyfire. Skyfire can automatically generate effective Cucumber test scenarios to replace manually generated test scenarios. Skyfire reads a behavioral UML diagram (e.g., a state machine diagram), identifies all necessary elements (e.g., transitions) of the diagram, generates effective tests to satisfy various graph coverage criteria, and converts the tests into Cucumber scenarios. Then testers write Cucumber mappings for the generated scenarios. Skyfire does not only generate effective tests but is also completely compatible with the existing agile development and continuous integration (CI) rhythm. We present the design architecture and implementation of skyfire, as well as an industrial case study to show how skyfire is used in practice.		N. Li; A. Escalona; T. Kamal	2016 IEEE International Conference on Software Testing, Verification and Validation (ICST)	In the software industry, a Behavior-Driven Development (BDD) tool, Cucumber, has been widely used by practitioners. Usually product analysts, developers, and testers manually write BDD test scenarios that describe system behaviors. Testers write implementation for the BDD scenarios by hand and execute the Cucumber tests. Cucumber provides transparency about what test scenarios are covered and how the test scenarios are mapped to executable tests. One drawback of the Cucumber BDD approach is that test scenarios are generated manually. Thus, the test scenarios are usually weak. More importantly, practitioners do not have a metric to measure test coverage. In this paper, we present a Model-Based Testing (MBT) tool, skyfire. Skyfire can automatically generate effective Cucumber test scenarios to replace manually generated test scenarios. Skyfire reads a behavioral UML diagram (e.g., a state machine diagram), identifies all necessary elements (e.g., transitions) of the diagram, generates effective tests to satisfy various graph coverage criteria, and converts the tests into Cucumber scenarios. Then testers write Cucumber mappings for the generated scenarios. Skyfire does not only generate effective tests but is also completely compatible with the existing agile development and continuous integration (CI) rhythm. We present the design architecture and implementation of skyfire, as well as an industrial case study to show how skyfire is used in practice.				Included	Included	new_screen			2						
126	Behave	Systematic verification and testing	In this chapter, we present a process pattern for model based specification, verification and testing. It combines concepts of behaviour driven development (BDD), graphical and formal, mathematical modelling, formal verification techniques, acceptance testing and model based testing. The rigorous approach helps to ensure that for highly dependable systems, dependability (e.g. safety) requirements are fulfilled and both the specified and the implemented behaviour are as desired. It helps bridging the gap between natural language or semi-formal requirements and mathematical abstraction. Furthermore, it addresses the issue that formal modelling expertise and domain knowledge are rarely held by the same set of people. © Springer Nature Switzerland AG 2020.		Dghaym D., Fischer T., Hoang T.S., Reichl K., Snook C., Schlick R., Tummeltshammer P.	Validation and Verification of Automated Systems: Results of the ENABLE-S3 Project	In this chapter, we present a process pattern for model based specification, verification and testing. It combines concepts of behaviour driven development (BDD), graphical and formal, mathematical modelling, formal verification techniques, acceptance testing and model based testing. The rigorous approach helps to ensure that for highly dependable systems, dependability (e.g. safety) requirements are fulfilled and both the specified and the implemented behaviour are as desired. It helps bridging the gap between natural language or semi-formal requirements and mathematical abstraction. Furthermore, it addresses the issue that formal modelling expertise and domain knowledge are rarely held by the same set of people. © Springer Nature Switzerland AG 2020.				Excluded	Excluded	new_screen			2						
127	Behave	BDD by Example: Russian Bylina Written in Gherkin Language	"In this paper is presented the User Stories technique within the Behaviour-Driven Development process by example of the famous Russian bylina (epic poem) ""Three trips of Ilya Muromets"" written in Gherkin language. In the first part are given explanations about the choice of the bylina as a good example for presentation of this technique and about the choice of GitHub as a good environment for this presentation. In the second part is placed the text of the presentation divided by the stages of the Story development and fitted with the links to the corresponding commits and file versions in the educational repository. A distinct advantage of this presentation is that it reflects a Story in its evolution, as a process. It reflects a more complex and changeable behaviour than in static trivial examples, which are usually used. Also, there are presented the main features of using the User Stories technique in Russian language, which have not been previously covered nowhere. Besides that, the using of the educational repository can significantly increase the possibilities for further spreading and development of the example."	behaviour-driven development; Gherkin; Agile; user stories; byliny; cucumber; epic poetry; examples; extreme programming; GitHub; JBehave; Scrum	Mustyatsa, Vadim	Proceedings of the 11th Central &amp; Eastern European Software Engineering Conference in Russia	"In this paper is presented the User Stories technique within the Behaviour-Driven Development process by example of the famous Russian bylina (epic poem) ""Three trips of Ilya Muromets"" written in Gherkin language. In the first part are given explanations about the choice of the bylina as a good example for presentation of this technique and about the choice of GitHub as a good environment for this presentation. In the second part is placed the text of the presentation divided by the stages of the Story development and fitted with the links to the corresponding commits and file versions in the educational repository. A distinct advantage of this presentation is that it reflects a Story in its evolution, as a process. It reflects a more complex and changeable behaviour than in static trivial examples, which are usually used. Also, there are presented the main features of using the User Stories technique in Russian language, which have not been previously covered nowhere. Besides that, the using of the educational repository can significantly increase the possibilities for further spreading and development of the example."				Excluded	Excluded	new_screen			2						
128	Behave	Satisfaction and its correlates in agile software development	In this paper we address the topic of software development team members satisfaction with their development process. We present an in-depth analysis of the results of a nationwide survey about software development in Switzerland. We wanted to find out if satisfaction relates to the applied development method, and to the use of various practices, and impacts on business, team and software issues. We found that higher satisfaction is reported more by those using Agile development than with plan-driven processes. We explored the different perspectives of developers and those with a management role and found a high consistency of satisfaction between Agile developers and Agile management, and differences with those using working plan-driven methods. We found that certain practices and impacts have high correlations to satisfaction, and that collaborative processes are closely related to satisfaction. We then explored the relationship between satisfaction and various other perspectives. Our results in this analysis are principally descriptive, but we think they can be a relevant contribution to understand the challenges for everyone involved in Agile development.		Kropp, Martin; Meier, Andreas; Anslow, Craig; Biddle, Robert	Journal of Systems and Software	In this paper we address the topic of software development team members satisfaction with their development process. We present an in-depth analysis of the results of a nationwide survey about software development in Switzerland. We wanted to find out if satisfaction relates to the applied development method, and to the use of various practices, and impacts on business, team and software issues. We found that higher satisfaction is reported more by those using Agile development than with plan-driven processes. We explored the different perspectives of developers and those with a management role and found a high consistency of satisfaction between Agile developers and Agile management, and differences with those using working plan-driven methods. We found that certain practices and impacts have high correlations to satisfaction, and that collaborative processes are closely related to satisfaction. We then explored the relationship between satisfaction and various other perspectives. Our results in this analysis are principally descriptive, but we think they can be a relevant contribution to understand the challenges for everyone involved in Agile development.				Excluded	Excluded	new_screen			2						
129	Behave	Compliance checking on building models with the gherkin language and continuous integration	In this paper we document our approach on applying Behaviour-Driven Development (BDD) and Continuous Integration (CI) from the software industry to the construction sector. We have provided a freely available open software toolset for the application of rules in the Gherkin syntax to an IFC building model. A prominent aspect of BDD and contrary to mvdXML, the formalization of rules in plain-test human-readable scenarios provides a basis for collaborative formalization of rules among stakeholders. At the same time our approach includes imperative program code that is fully extensible to incorporate for example external data sources and geometrical reasoning. Runnings test on every model revision (the CI concept) as opposed to, for example, upon model delivery ensures a proactive approach to compliance. Reusing existing open source frameworks allowed us to build a comprehensive solution for continuous and automated model checking, visualization and reporting in several hundred lines of program code. © EG-ICE 2020 Workshop on Intelligent Computing in Engineering, Proceedings. All rights reserved.		Moult D., Krijnen T.	EG-ICE 2020 Workshop on Intelligent Computing in Engineering, Proceedings	In this paper we document our approach on applying Behaviour-Driven Development (BDD) and Continuous Integration (CI) from the software industry to the construction sector. We have provided a freely available open software toolset for the application of rules in the Gherkin syntax to an IFC building model. A prominent aspect of BDD and contrary to mvdXML, the formalization of rules in plain-test human-readable scenarios provides a basis for collaborative formalization of rules among stakeholders. At the same time our approach includes imperative program code that is fully extensible to incorporate for example external data sources and geometrical reasoning. Runnings test on every model revision (the CI concept) as opposed to, for example, upon model delivery ensures a proactive approach to compliance. Reusing existing open source frameworks allowed us to build a comprehensive solution for continuous and automated model checking, visualization and reporting in several hundred lines of program code. © EG-ICE 2020 Workshop on Intelligent Computing in Engineering, Proceedings. All rights reserved.				Included	Included	new_screen			2						
130	Behave	Improving Agile Software Development with Domain Ontologies	In this paper we propose to apply domain ontologies in agile software development to reduce the ambiguity caused by using natural language as ubiquitous language to report user stories. To justify and demonstrate our approach, we present a case study that combines Scrum and Behaviour-Driven Development (BDD) in the development of an educational support system, which was built to support the activities of the Medicine Programme of Federal University of São Carlos (UFSCar) in Brazil. Starting from a reference ontology for the Higher Education domain, we gradually specialized this ontology for this programme. Since we selected the Evaluation Management module of this system for our case study, we applied the Evaluation Process Ontology to that programme, and defined user stories to identify the feature set to be implemented. For evaluation and validation purposes, we assessed the quality of all ontologies used in this work according to structural and functional dimensions. © 2018, Springer International Publishing AG, part of Springer Nature.		de Souza P.L., do Prado A.F., de Souza W.L., dos Santos Forghieri Pereira S.M., Pires L.F.	Advances in Intelligent Systems and Computing	In this paper we propose to apply domain ontologies in agile software development to reduce the ambiguity caused by using natural language as ubiquitous language to report user stories. To justify and demonstrate our approach, we present a case study that combines Scrum and Behaviour-Driven Development (BDD) in the development of an educational support system, which was built to support the activities of the Medicine Programme of Federal University of São Carlos (UFSCar) in Brazil. Starting from a reference ontology for the Higher Education domain, we gradually specialized this ontology for this programme. Since we selected the Evaluation Management module of this system for our case study, we applied the Evaluation Process Ontology to that programme, and defined user stories to identify the feature set to be implemented. For evaluation and validation purposes, we assessed the quality of all ontologies used in this work according to structural and functional dimensions. © 2018, Springer International Publishing AG, part of Springer Nature.				Included	Included	new_screen			2						
131	Behave	Agile testing practices in software quality: State of the art review	In this paper you can find a review of articles related to agile testing practices in software quality, looking for theoretical information and real cases applied to testing inside a modern context, comparing them with the standard procedures taking into account their advantages and relevant features. As final result, we determine that agile practices in software quality have wide acceptance and many companies have chosen their use for all their benefits and impact on development software processes in several real applications, not necessarily IT governance ones, since other kind of technical applications have shown excellent results on testing. © 2005 - 2016 JATIT & LLS. All rights reserved.		Gil C., Diaz J., Orozco M., de la Hoz A., de la Hoz E., Morales R.	Journal of Theoretical and Applied Information Technology	In this paper you can find a review of articles related to agile testing practices in software quality, looking for theoretical information and real cases applied to testing inside a modern context, comparing them with the standard procedures taking into account their advantages and relevant features. As final result, we determine that agile practices in software quality have wide acceptance and many companies have chosen their use for all their benefits and impact on development software processes in several real applications, not necessarily IT governance ones, since other kind of technical applications have shown excellent results on testing. © 2005 - 2016 JATIT & LLS. All rights reserved.				Excluded	Excluded	new_screen			2						
132	Behave	Consistency Reflection for Automatic Update of Testing Environment	In this paper, we present an approach for maintaining consistency among design models, system under test, and test components. Our approach provides an automatic updating technique to deal with changes that happen frequently in agile software development. Consistency reflection by automatic updating allows us to cut off manual tasks required in maintaining automated tests and speed up testing process which is a bottleneck in service development lifecycle. We introduce the use of metadata, the data structure that describes structural behavior of the system, in our automatic updating technique. Metadata is used as a common medium for communicating changes to keep consistency among design, system under test, and test components. We present an example of testing process to show how we apply this approach in practice.	behavior-driven development; agile software development; automated software testing; automatic update; consistency reflection; design models; metadata	Sathawornwichit, Chaiwat; Hosono, Shigeru	Proceedings of the 2012 IEEE Asia-Pacific Services Computing Conference)	In this paper, we present an approach for maintaining consistency among design models, system under test, and test components. Our approach provides an automatic updating technique to deal with changes that happen frequently in agile software development. Consistency reflection by automatic updating allows us to cut off manual tasks required in maintaining automated tests and speed up testing process which is a bottleneck in service development lifecycle. We introduce the use of metadata, the data structure that describes structural behavior of the system, in our automatic updating technique. Metadata is used as a common medium for communicating changes to keep consistency among design, system under test, and test components. We present an example of testing process to show how we apply this approach in practice.				Included	Included	new_screen			2						
133	Behave	Generation of behavior-driven development C++ tests from abstract state machine scenarios	In this paper, we present the AsmetaVBDD tool that automatically translates the scenarios written in the AValLa language (used by the asmeta validator (AsmetaV)) into Behavior-Driven Development scenarios for C++. © Springer Nature Switzerland AG 2018.		Bonfanti S., Gargantini A., Mashkoor A.	Communications in Computer and Information Science	In this paper, we present the AsmetaVBDD tool that automatically translates the scenarios written in the AValLa language (used by the asmeta validator (AsmetaV)) into Behavior-Driven Development scenarios for C++. © Springer Nature Switzerland AG 2018.				Included	Included	new_screen			2						
134	Behave	Behaviour-Driven Development for Computer-Interpretable Clinical Guidelines	In this paper, we propose an approach for specification and analysis of Computer-Interpretable Clinical Guidelines (CIGs) that was inspired by Behaviour-Driven Development. The expected behaviour of a CIG is specified by requirements in natural language. On the one hand, those requirements are used as design input for guideline development. On the other hand, they can be checked against time-oriented data recorded during testing sessions of the implemented CIG.		Hatko, Reinhard; Mersmann, Stefan; Puppe, Prank	Proceedings of the 10th International Conference on Knowledge Engineering and Software Engineering - Volume 1289	In this paper, we propose an approach for specification and analysis of Computer-Interpretable Clinical Guidelines (CIGs) that was inspired by Behaviour-Driven Development. The expected behaviour of a CIG is specified by requirements in natural language. On the one hand, those requirements are used as design input for guideline development. On the other hand, they can be checked against time-oriented data recorded during testing sessions of the implemented CIG.				Included	Included	new_screen			2						
135	Behave	A preliminary study on using acceptance tests for representing business requirements of smart contracts	"In this work, we address the following question: ""Which acceptance testing techniques are being used for representing business requirements of smart contracts?"" To answer this question we performed a systematic mapping to determine whether acceptance tests for smart contracts and blockchain are being utilized to represent requirements and which acceptance testing techniques are being applied. This systematic mapping shows that, in fact, acceptance testing techniques are still not commonly used to represent the business requirements of smart contracts. We only found two studies using acceptance testing techniques with smart contracts. Moreover, only one of them uses an acceptance testing technique, the BDD (Behavior-Driven Development) notation, to represent the business requirements. In order to confirm that it is possible to represent business requirements of smart contracts, we developed an example that uses the BDD notation to represent requirements of a smart contract deployed in the Hyperledger blockchain. Preliminary results show that it is possible to use acceptance tests to represent business requirements."	acceptance testing;acceptance test;smart contract;business requirement;blockchain	P. Vilain; J. Mylopoulos; H. -A. Jacobsen	2020 IEEE International Conference on Blockchain and Cryptocurrency (ICBC)	"In this work, we address the following question: ""Which acceptance testing techniques are being used for representing business requirements of smart contracts?"" To answer this question we performed a systematic mapping to determine whether acceptance tests for smart contracts and blockchain are being utilized to represent requirements and which acceptance testing techniques are being applied. This systematic mapping shows that, in fact, acceptance testing techniques are still not commonly used to represent the business requirements of smart contracts. We only found two studies using acceptance testing techniques with smart contracts. Moreover, only one of them uses an acceptance testing technique, the BDD (Behavior-Driven Development) notation, to represent the business requirements. In order to confirm that it is possible to represent business requirements of smart contracts, we developed an example that uses the BDD notation to represent requirements of a smart contract deployed in the Hyperledger blockchain. Preliminary results show that it is possible to use acceptance tests to represent business requirements."				Excluded	Excluded	new_screen			2						
136	Behave	Behavior-Driven Development as an Approach to Improve Software Quality and Communication across Remote Business Stakeholders, Developers and QA: Two Case Studies	In this work, we describe two of our experiences applying BDD: one at a large publisher of financial information and business news, and the other in a secure collaboration platform vendor. The team composition involves both a local team and an external service provider. We analyze two adoption processes, one driven by the product team, and the other driven by the development team. We cover the communication benefits and impacts on areas such as stakeholder alignment, software design, code refactoring, and bug fixing. We also discuss lessons learned, caveats and how we plan to expand this practice in the future.	distributed agile teams; industrial offshoring and outsourcing experiences; methods and processes; social and human aspects of software development	Scandaroli, André; Leite, Rodrigo; Kiosia, Aléxis H.; Coelho, Sandro A.	Proceedings of the 14th International Conference on Global Software Engineering	In this work, we describe two of our experiences applying BDD: one at a large publisher of financial information and business news, and the other in a secure collaboration platform vendor. The team composition involves both a local team and an external service provider. We analyze two adoption processes, one driven by the product team, and the other driven by the development team. We cover the communication benefits and impacts on areas such as stakeholder alignment, software design, code refactoring, and bug fixing. We also discuss lessons learned, caveats and how we plan to expand this practice in the future.				Excluded	Excluded	new_screen			2						
137	Behave	Behavior-Driven Development as an Approach to Improve Software Quality and Communication Across Remote Business Stakeholders, Developers and QA: Two Case Studies	In this work, we describe two of our experiences applying BDD: one at a large publisher of financial information and business news, and the other in a secure collaboration platform vendor. The team composition involves both a local team and an external service provider. We analyze two adoption processes, one driven by the product team, and the other driven by the development team. We cover the communication benefits and impacts on areas such as stakeholder alignment, software design, code refactoring, and bug fixing. We also discuss lessons learned, caveats and how we plan to expand this practice in the future. © 2019 IEEE.		Scandaroli A., Leite R., Kiosia A.H., Coelho S.A.	Proceedings - 2019 ACM/IEEE 14th International Conference on Global Software Engineering, ICGSE 2019	In this work, we describe two of our experiences applying BDD: one at a large publisher of financial information and business news, and the other in a secure collaboration platform vendor. The team composition involves both a local team and an external service provider. We analyze two adoption processes, one driven by the product team, and the other driven by the development team. We cover the communication benefits and impacts on areas such as stakeholder alignment, software design, code refactoring, and bug fixing. We also discuss lessons learned, caveats and how we plan to expand this practice in the future. © 2019 IEEE.				Included	Included	new_screen			2						
138	Behave	Towards a Behavior-Oriented Specification and Testing Language for Multimodal Applications	Initiated by the ubiquity of mobile devices, human computer interaction has evolved beyond the classic PCs' mouse and keyboard setup. Smartphones and tablets introduced new interaction modalities to the mass market and created the need for specialized software engineering methods. While more and more powerful SDKs are released to develop interactive applications, specifying user interaction is still ambiguous and error-prone, causing software defects as well as misunderstandings and frustration among project team members and stakeholders. We present an approach addressing this problems by demonstrating how to incorporate multimodal interaction into user acceptance tests written in near-natural language using Gherkin and formal gesture descriptions.	software engineering; multimodal user interfaces; specification	Hesenius, Marc; Griebe, Tobias; Gruhn, Volker	Proceedings of the 2014 ACM SIGCHI Symposium on Engineering Interactive Computing Systems	Initiated by the ubiquity of mobile devices, human computer interaction has evolved beyond the classic PCs' mouse and keyboard setup. Smartphones and tablets introduced new interaction modalities to the mass market and created the need for specialized software engineering methods. While more and more powerful SDKs are released to develop interactive applications, specifying user interaction is still ambiguous and error-prone, causing software defects as well as misunderstandings and frustration among project team members and stakeholders. We present an approach addressing this problems by demonstrating how to incorporate multimodal interaction into user acceptance tests written in near-natural language using Gherkin and formal gesture descriptions.				Included	Included	new_screen			2						
139	Behave	Improving the Prediction of Files Changed by Programming Tasks	Integration conflicts often damage software quality and developers' productivity in a collaborative development environment. For reducing merge conflicts, we could avoid asking developers to execute potentially conflicting tasks in parallel, as long as we can predict the files to be changed by each task. As manually predicting that is hard, the TAITI tool tries to do that in the context of BDD (Behaviour-Driven Development) projects, by statically analysing the automated acceptance tests that validate each task. TAITI computes the set of files that might be executed by the tests of a task (a so called test-based task interface), approximating the files that developers will change when performing the task. Although TAITI performs better than a random task interface, there is space for accuracy improvements. In this paper, we extend the interfaces computed by TAITI by including the dependences of the application files reached by the task tests. To understand the potential benefits of our extension, we evaluate precision and recall of 60 task interfaces from 8 Rails GitHub projects. The results bring evidence that the extended interface improves recall by slightly compromising precision.	Collaborative development; File change prediction; Behaviour-Driven Development	Santos, João Pedro; Rocha, Thaís; Borba, Paulo	Proceedings of the XIII Brazilian Symposium on Software Components, Architectures, and Reuse	Integration conflicts often damage software quality and developers' productivity in a collaborative development environment. For reducing merge conflicts, we could avoid asking developers to execute potentially conflicting tasks in parallel, as long as we can predict the files to be changed by each task. As manually predicting that is hard, the TAITI tool tries to do that in the context of BDD (Behaviour-Driven Development) projects, by statically analysing the automated acceptance tests that validate each task. TAITI computes the set of files that might be executed by the tests of a task (a so called test-based task interface), approximating the files that developers will change when performing the task. Although TAITI performs better than a random task interface, there is space for accuracy improvements. In this paper, we extend the interfaces computed by TAITI by including the dependences of the application files reached by the task tests. To understand the potential benefits of our extension, we evaluate precision and recall of 60 task interfaces from 8 Rails GitHub projects. The results bring evidence that the extended interface improves recall by slightly compromising precision.				Included	Included	new_screen			2						
140	Behave	Test-Driven Java Development	Invoke TDD principles for end-to-end application development with JavaAbout This BookExplore the most popular TDD tools and frameworks and become more proficient in building applicationsCreate applications with better code design, fewer bugs, and higher test coverage, enabling you to get them to market quicklyImplement test-driven programming methods into your development workflowsWho This Book Is ForIf you're an experienced Java developer and want to implement more effective methods of programming systems and applications, then this book is for you.What You Will LearnExplore the tools and frameworks required for effective TDD developmentPerform the Red-Green-Refactor process efficiently, the pillar around which all other TDD procedures are basedMaster effective unit testing in isolation from the rest of your codeDesign simple and easily maintainable codes by implementing different techniquesUse mocking frameworks and techniques to easily write and quickly execute testsDevelop an application to implement behaviour-driven development in conjunction with unit testingEnable and disable features using Feature TogglesIn DetailTest-driven development (TDD) is a development approach that relies on a test-first procedure that emphasises writing a test before writing the necessary code, and then refactoring the code to optimize it.The value of performing TDD with Java, one of the most established programming languages, is to improve the productivity of programmers, the maintainability and performance of code, and develop a deeper understanding of the language and how to employ it effectively.Starting with the basics of TDD and reasons why its adoption is beneficial, this book will take you from the first steps of TDD with Java until you are confident enough to embrace the practice in your day-to-day routine.You'll be guided through setting up tools, frameworks, and the environment you need, and will dive right in to hands-on exercises with the goal of mastering one practice, tool, or framework at a time. You'll learn about the Red-Green-Refactor procedure, how to write unit tests, and how to use them as executable documentation.With this book you'll also discover how to design simple and easily maintainable code, work with mocks, utilise behaviour-driven development, refactor old legacy code, and release a half-finished feature to production with feature toggles.You will finish this book with a deep understanding of the test-driven development methodology and the confidence to apply it to application programming with Java.Style and approachAn easy-to-follow, hands-on guide to building applications through effective coding practices. This book covers practical examples by introducing different problems, each one designed as a learning exercise to help you understand each aspect of TDD.		Farcic, Viktor; Garcia, Alex		Invoke TDD principles for end-to-end application development with JavaAbout This BookExplore the most popular TDD tools and frameworks and become more proficient in building applicationsCreate applications with better code design, fewer bugs, and higher test coverage, enabling you to get them to market quicklyImplement test-driven programming methods into your development workflowsWho This Book Is ForIf you're an experienced Java developer and want to implement more effective methods of programming systems and applications, then this book is for you.What You Will LearnExplore the tools and frameworks required for effective TDD developmentPerform the Red-Green-Refactor process efficiently, the pillar around which all other TDD procedures are basedMaster effective unit testing in isolation from the rest of your codeDesign simple and easily maintainable codes by implementing different techniquesUse mocking frameworks and techniques to easily write and quickly execute testsDevelop an application to implement behaviour-driven development in conjunction with unit testingEnable and disable features using Feature TogglesIn DetailTest-driven development (TDD) is a development approach that relies on a test-first procedure that emphasises writing a test before writing the necessary code, and then refactoring the code to optimize it.The value of performing TDD with Java, one of the most established programming languages, is to improve the productivity of programmers, the maintainability and performance of code, and develop a deeper understanding of the language and how to employ it effectively.Starting with the basics of TDD and reasons why its adoption is beneficial, this book will take you from the first steps of TDD with Java until you are confident enough to embrace the practice in your day-to-day routine.You'll be guided through setting up tools, frameworks, and the environment you need, and will dive right in to hands-on exercises with the goal of mastering one practice, tool, or framework at a time. You'll learn about the Red-Green-Refactor procedure, how to write unit tests, and how to use them as executable documentation.With this book you'll also discover how to design simple and easily maintainable code, work with mocks, utilise behaviour-driven development, refactor old legacy code, and release a half-finished feature to production with feature toggles.You will finish this book with a deep understanding of the test-driven development methodology and the confidence to apply it to application programming with Java.Style and approachAn easy-to-follow, hands-on guide to building applications through effective coding practices. This book covers practical examples by introducing different problems, each one designed as a learning exercise to help you understand each aspect of TDD.				Excluded	Excluded	new_screen			2						
141	Behave	An industrial case study on test cases as requirements	It is a conundrum that agile projects can succeed ‘without requirements’ when weak requirements engineering is a known cause for project failures. While Agile development projects often manage well without extensive requirements documentation, test cases are commonly used as requirements. We have investigated this agile practice at three companies in order to understand how test cases can fill the role of requirements. We performed a case study based on twelve interviews performed in a previous study. The findings include a range of benefits and challenges in using test cases for eliciting, validating, verifying, tracing and managing requirements. In addition, we identified three scenarios for applying the practice, namely as a mature practice, as a de facto practice and as part of an agile transition. The findings provide insights into how the role of requirements may be met in agile development including challenges to consider. © Springer International Publishing Switzerland 2015.		Bjarnason E., Unterkalmsteiner M., Engström E., Borg M.	Lecture Notes in Business Information Processing	It is a conundrum that agile projects can succeed ‘without requirements’ when weak requirements engineering is a known cause for project failures. While Agile development projects often manage well without extensive requirements documentation, test cases are commonly used as requirements. We have investigated this agile practice at three companies in order to understand how test cases can fill the role of requirements. We performed a case study based on twelve interviews performed in a previous study. The findings include a range of benefits and challenges in using test cases for eliciting, validating, verifying, tracing and managing requirements. In addition, we identified three scenarios for applying the practice, namely as a mature practice, as a de facto practice and as part of an agile transition. The findings provide insights into how the role of requirements may be met in agile development including challenges to consider. © Springer International Publishing Switzerland 2015.				Included	Included	new_screen			2						
142	Behave	Chapter Five - Advances in Testing JavaScript-Based Web Applications	JavaScript is a flexible and expressive prototype-based scripting language that is used by developers to create interactive web applications. The language is interpreted, dynamic, weakly typed, and has first-class functions. It also interacts extensively with other web languages such as CSS and HTML at runtime. All these characteristics make JavaScript code particularly error-prone and challenging to analyze and test. In this chapter, we explore recent advances made in analysis and testing techniques geared toward JavaScript-based web applications. In particular, we look at recent empirical studies, testing techniques, test oracle automation approaches, test adequacy assessment methods, fault localization and repair, and Integrated Development Environment support to help programmers write better JavaScript code.	JavaScript, Testing, Dynamic analysis, Web applications, Test adequacy, Oracles	Mesbah, Ali		JavaScript is a flexible and expressive prototype-based scripting language that is used by developers to create interactive web applications. The language is interpreted, dynamic, weakly typed, and has first-class functions. It also interacts extensively with other web languages such as CSS and HTML at runtime. All these characteristics make JavaScript code particularly error-prone and challenging to analyze and test. In this chapter, we explore recent advances made in analysis and testing techniques geared toward JavaScript-based web applications. In particular, we look at recent empirical studies, testing techniques, test oracle automation approaches, test adequacy assessment methods, fault localization and repair, and Integrated Development Environment support to help programmers write better JavaScript code.				Excluded	Excluded	new_screen			2						
143	Behave	Mastering Symfony	Key FeaturesCreate a robust and reliable Symfony development pipeline using Amazon's cloud platformCut development and maintenance costs by defining crystal clear features and possible scenarios for each feature before implementationFollow detailed examples provided in each chapter to create a task management applicationBook DescriptionIn this book, you will learn some lesser known aspects of development with Symfony, and you will see how to use Symfony as a framework to create reliable and effective applications. You might have developed some impressive PHP libraries in other projects, but what is the point when your library is tied to one particular project? With Symfony, you can turn your code into a service and reuse it in other projects.This book starts with Symfony concepts such as bundles, routing, twig, doctrine, and more, taking you through the request/response life cycle. You will then proceed to set up development, test, and deployment environments in AWS. Then you will create reliable projects using Behat and Mink, and design business logic, cover authentication, and authorization steps in a security checking process. You will be walked through concepts such as DependencyInjection, service containers, and services, and go through steps to create customized commands for Symfony's console. Finally, the book covers performance optimization and the use of Varnish and Memcached in our project, and you are treated with the creation of database agnostic bundles and best practices.What you will learnInstall and configure Symfony and required third-party bundles to develop a task management applicationSet up a continuous integration server to orchestrate automatic builds every time you add a new feature to your projectReduce maintenance costs dramatically using Behaviour Driven Development (BDD)Create a slick user interface using the Bootstrap frameworkDesign robust business logic using DoctrineBuild a comprehensive dashboard and secure your project using the Sonata projectImprove performance using Redis, Memcache, and VarnishCreate customized Symfony commands and add them to your consoleAbout the AuthorSohail Salehi is a full stack web developer who is constantly seeking creative solutions for complex problems. He believes that what has been taught as universalities should be considered as a basic stepping stone to real-life challenges. They cannot be used as practical solutions. He learned that a one-size-fits-all solution does not work in the IT world. Every business, every coding challenge, and every environment setup has its own signature and requires some tweaking on basic principals to make sure that it receives a reliable cost-effective solution.When he is not staring at his computer screen, he is watching sunsets and sunrises, swimming and surfing in the ocean, and putting his subconscious mind at work by asking creative questions while facing life's ups and downs on a daily basis.Table of ContentsInstalling and Configuring SymfonyThe Request and Response Life CycleSetting Up the EnvironmentUsing Behavior-Driven Development in SymfonyBusiness LogicDashboard and SecurityThe Presentation LayerProject ReviewServices and Service ContainersCustom User CommandsMore about Dev, Test and Prod EnvironmentsCaching in Symfony		Salehi, Sohail		Key FeaturesCreate a robust and reliable Symfony development pipeline using Amazon's cloud platformCut development and maintenance costs by defining crystal clear features and possible scenarios for each feature before implementationFollow detailed examples provided in each chapter to create a task management applicationBook DescriptionIn this book, you will learn some lesser known aspects of development with Symfony, and you will see how to use Symfony as a framework to create reliable and effective applications. You might have developed some impressive PHP libraries in other projects, but what is the point when your library is tied to one particular project? With Symfony, you can turn your code into a service and reuse it in other projects.This book starts with Symfony concepts such as bundles, routing, twig, doctrine, and more, taking you through the request/response life cycle. You will then proceed to set up development, test, and deployment environments in AWS. Then you will create reliable projects using Behat and Mink, and design business logic, cover authentication, and authorization steps in a security checking process. You will be walked through concepts such as DependencyInjection, service containers, and services, and go through steps to create customized commands for Symfony's console. Finally, the book covers performance optimization and the use of Varnish and Memcached in our project, and you are treated with the creation of database agnostic bundles and best practices.What you will learnInstall and configure Symfony and required third-party bundles to develop a task management applicationSet up a continuous integration server to orchestrate automatic builds every time you add a new feature to your projectReduce maintenance costs dramatically using Behaviour Driven Development (BDD)Create a slick user interface using the Bootstrap frameworkDesign robust business logic using DoctrineBuild a comprehensive dashboard and secure your project using the Sonata projectImprove performance using Redis, Memcache, and VarnishCreate customized Symfony commands and add them to your consoleAbout the AuthorSohail Salehi is a full stack web developer who is constantly seeking creative solutions for complex problems. He believes that what has been taught as universalities should be considered as a basic stepping stone to real-life challenges. They cannot be used as practical solutions. He learned that a one-size-fits-all solution does not work in the IT world. Every business, every coding challenge, and every environment setup has its own signature and requires some tweaking on basic principals to make sure that it receives a reliable cost-effective solution.When he is not staring at his computer screen, he is watching sunsets and sunrises, swimming and surfing in the ocean, and putting his subconscious mind at work by asking creative questions while facing life's ups and downs on a daily basis.Table of ContentsInstalling and Configuring SymfonyThe Request and Response Life CycleSetting Up the EnvironmentUsing Behavior-Driven Development in SymfonyBusiness LogicDashboard and SecurityThe Presentation LayerProject ReviewServices and Service ContainersCustom User CommandsMore about Dev, Test and Prod EnvironmentsCaching in Symfony				Excluded	Excluded	new_screen			2						
144	Behave	RSpec Essentials	Key FeaturesExplore the concept of testability and how to implement tests that deliver the most valueMaximize the quality of your Ruby code through a wide variety of testsMaster the real-world tradeoffs of testing through detailed examples supported by in-depth discussionBook DescriptionThis book will teach you how to use RSpec to write high-value tests for real-world code. We start with the key concepts of the unit and testability, followed by hands-on exploration of key features. From the beginning, we learn how to integrate tests into the overall development process to help create high-quality code, avoiding the dangers of testing for its own sake.We build up sample applications and their corresponding tests step by step, from simple beginnings to more sophisticated versions that include databases and external web services. We devote three chapters to web applications with rich JavaScript user interfaces, building one from the ground up using behavior-driven development (BDD) and test-driven development (TDD).The code examples are detailed enough to be realistic while simple enough to be easily understood. Testing concepts, development methodologies, and engineering tradeoffs are discussed in detail as they arise. This approach is designed to foster the reader's ability to make well-informed decisions on their own.What you will learnIdentify a unit of software for the purposes of testingManage test states with hooks, fixtures, and mocksHandle external web services in tests using various techniquesConfigure RSpec flexibly and cleanly using support code and environment variablesInteract with rich web apps in tests using CapybaraBuild the right feature with behavior-driven developmentCustomize matchers and failure messagesVerify correct development and production environmentsAbout the AuthorMani Tadayon first learned to program as a shy 7th grader on an Apple IIe using BASIC. He went on to learn Pascal, C++, Java, JavaScript, Visual Basic, and PHP before becoming a Ruby developer in 2008. With 15 years of experience in the software industry, he has developed expertise in web development, infrastructure, and testing. Mani's interests and education are broad, with degrees in foreign languages, computer science, and geography. He lives just far enough from Silicon Valley with his family and their many, many Shiba Inus.Table of ContentsExploring Testability from Unit Tests to Behavior-Driven DevelopmentSpecifying Behavior with Examples and MatchersTaking Control of State with Doubles and HooksSetting Up and Cleaning UpSimulating External ServicesDriving a Web Browser with CapybaraBuilding an App from the Outside In with Behavior-Driven DevelopmentTackling the Challenges of End-to-end TestingConfigurabilityOdds and Ends		Tadayon, Mani		Key FeaturesExplore the concept of testability and how to implement tests that deliver the most valueMaximize the quality of your Ruby code through a wide variety of testsMaster the real-world tradeoffs of testing through detailed examples supported by in-depth discussionBook DescriptionThis book will teach you how to use RSpec to write high-value tests for real-world code. We start with the key concepts of the unit and testability, followed by hands-on exploration of key features. From the beginning, we learn how to integrate tests into the overall development process to help create high-quality code, avoiding the dangers of testing for its own sake.We build up sample applications and their corresponding tests step by step, from simple beginnings to more sophisticated versions that include databases and external web services. We devote three chapters to web applications with rich JavaScript user interfaces, building one from the ground up using behavior-driven development (BDD) and test-driven development (TDD).The code examples are detailed enough to be realistic while simple enough to be easily understood. Testing concepts, development methodologies, and engineering tradeoffs are discussed in detail as they arise. This approach is designed to foster the reader's ability to make well-informed decisions on their own.What you will learnIdentify a unit of software for the purposes of testingManage test states with hooks, fixtures, and mocksHandle external web services in tests using various techniquesConfigure RSpec flexibly and cleanly using support code and environment variablesInteract with rich web apps in tests using CapybaraBuild the right feature with behavior-driven developmentCustomize matchers and failure messagesVerify correct development and production environmentsAbout the AuthorMani Tadayon first learned to program as a shy 7th grader on an Apple IIe using BASIC. He went on to learn Pascal, C++, Java, JavaScript, Visual Basic, and PHP before becoming a Ruby developer in 2008. With 15 years of experience in the software industry, he has developed expertise in web development, infrastructure, and testing. Mani's interests and education are broad, with degrees in foreign languages, computer science, and geography. He lives just far enough from Silicon Valley with his family and their many, many Shiba Inus.Table of ContentsExploring Testability from Unit Tests to Behavior-Driven DevelopmentSpecifying Behavior with Examples and MatchersTaking Control of State with Doubles and HooksSetting Up and Cleaning UpSimulating External ServicesDriving a Web Browser with CapybaraBuilding an App from the Outside In with Behavior-Driven DevelopmentTackling the Challenges of End-to-end TestingConfigurabilityOdds and Ends				Excluded	Excluded	new_screen			2						
145	Behave	Crowdsourced Behavior-Driven Development	Key to the effectiveness of crowdsourcing approaches for software engineering is workflow design, describing how complex work is organized into small, relatively independent microtasks. This paper, we introduce a Behavior-Driven Development (BDD) workflow for accomplishing programming work through self-contained microtasks, implemented as a preconfigured environment called CrowdMicroservices. In our approach, a client, acting on behalf of a software team, describes a microservice as a set of endpoints with paths, requests, and responses. A crowd then implements the endpoints, identifying individual endpoint behaviors that they test, implement, debug, create new functions, and interact with persistence APIs as needed. To evaluate our approach, we conducted a feasibility study in which a small crowd worked to implement a small ToDo microservice. The crowd created an implementation with only four defects, completing 350 microtasks and implementing 13 functions. We discuss the implications of these findings for incorporating crowdsourced programming contributions into traditional software projects.	Microtask programming, Programming environments, Behavior-Driven Development, Crowdsourcing, Workflow, Microservices	Aghayi, Emad; LaToza, Thomas D.; Surendra, Paurav; Abolghasemi, Seyedmeysam	Journal of Systems and Software	Key to the effectiveness of crowdsourcing approaches for software engineering is workflow design, describing how complex work is organized into small, relatively independent microtasks. This paper, we introduce a Behavior-Driven Development (BDD) workflow for accomplishing programming work through self-contained microtasks, implemented as a preconfigured environment called CrowdMicroservices. In our approach, a client, acting on behalf of a software team, describes a microservice as a set of endpoints with paths, requests, and responses. A crowd then implements the endpoints, identifying individual endpoint behaviors that they test, implement, debug, create new functions, and interact with persistence APIs as needed. To evaluate our approach, we conducted a feasibility study in which a small crowd worked to implement a small ToDo microservice. The crowd created an implementation with only four defects, completing 350 microtasks and implementing 13 functions. We discuss the implications of these findings for incorporating crowdsourced programming contributions into traditional software projects.				Included	Included	new_screen			2						
146	Behave	Using Language Workbenches and Domain-Specific Languages for Safety-Critical Software Development	Language workbenches support the efficient creation, integration, and use of domain-specific languages. Typically, they execute models by code generation to programming language code. This can lead to increased productivity and higher quality. However, in safety-/mission-critical environments, generated code may not be considered trustworthy, because of the lack of trust in the generation mechanisms. This makes it harder to justify the use of language workbenches in such an environment. In this paper, we demonstrate an approach to use such tools in critical environments. We argue that models created with domain-specific languages are easier to validate and that the additional risk resulting from the transformation to code can be mitigated by a suitably designed transformation and verification architecture. We validate the approach with an industrial case study from the healthcare domain. We also discuss the degree to which the approach is appropriate for critical software in space, automotive, and robotics systems.	Case study; Domain-specific languages; Language workbenches; Safety-critical software development	Voelter, Markus; Kolb, Bernd; Birken, Klaus; Tomassetti, Federico; Alff, Patrick; Wiart, Laurent; Wortmann, Andreas; Nordmann, Arne	Softw. Syst. Model.	Language workbenches support the efficient creation, integration, and use of domain-specific languages. Typically, they execute models by code generation to programming language code. This can lead to increased productivity and higher quality. However, in safety-/mission-critical environments, generated code may not be considered trustworthy, because of the lack of trust in the generation mechanisms. This makes it harder to justify the use of language workbenches in such an environment. In this paper, we demonstrate an approach to use such tools in critical environments. We argue that models created with domain-specific languages are easier to validate and that the additional risk resulting from the transformation to code can be mitigated by a suitably designed transformation and verification architecture. We validate the approach with an industrial case study from the healthcare domain. We also discuss the degree to which the approach is appropriate for critical software in space, automotive, and robotics systems.				Excluded	Excluded	new_screen			2						
147	Behave	Instant RSpec Test - Driven Development How-To	Learn RSpec and redefine your approach towards software development Overview Learn something new in an Instant! A short, fast, focused guide delivering immediate results Learn how to use RSpec with Rails Easy to read and grok examples Write idiomatic specifications In Detail RSpec is a behaviour driven development framework for Ruby programmers. It comes integrated with its own mocking framework based on Jmock. This book introduces you to RSpec helping you to write idiomatic specifications for Ruby code in a test first approach. Instant RSpec Test-Driven Development How-to is filled with examples of actual code accompanied by explanations and covers general Ruby, Rails, and RSpec use cases plus a few of the more advanced topics. RSpec Test Driven Development is written on the premise that you will need no experience with RSpec and limited experience with Ruby, Rails, and TDD fundamentals. Youll begin by writing a very simple Ruby library in true TDD fashion and and use the red, green, refactor tools to migrate this library into a Rails application. Instant RSpec Test-Driven Development How-to will teach you the actual steps performed in writing an idiomatic specification. You will be able to write a test for the code you wish you had, and learn to write only the minimum code necessary to pass a test, and write more specifications to drive out the production functionality your application will need. Through the course of the book, you will convert a Ruby program into a new Rails application, test Rails specifics such as file uploads, cookies, and model validation and even learn how to use Capybara. RSpec Test Driven Development will help you build confidence in the code they you write and spend less time dealing with bugs and maintenance headaches. What you will learn from this book RSpec fundamentals How to use RSpec and Rails together Modify your behavior to create tests first and run your specs with every code change How to work with the rspec command line tool Using mocks and stubs to decouple tests from the database How to refactor code to improve readability Approach Filled with practical, step-by-step instructions and clear explanations for the most important and useful tasks. A concise guide that delivers immediate results with practical recipes on learning practical hints. Who this book is written for This book is aimed at Ruby developers with beginner level expertise who want to use RSpec and test driven development methodology to improve the code they write. Experienced programmers new to Ruby will also benefit from this book which also covers creating testable, idiomatic Ruby code.		Feduke, Charles		Learn RSpec and redefine your approach towards software development Overview Learn something new in an Instant! A short, fast, focused guide delivering immediate results Learn how to use RSpec with Rails Easy to read and grok examples Write idiomatic specifications In Detail RSpec is a behaviour driven development framework for Ruby programmers. It comes integrated with its own mocking framework based on Jmock. This book introduces you to RSpec helping you to write idiomatic specifications for Ruby code in a test first approach. Instant RSpec Test-Driven Development How-to is filled with examples of actual code accompanied by explanations and covers general Ruby, Rails, and RSpec use cases plus a few of the more advanced topics. RSpec Test Driven Development is written on the premise that you will need no experience with RSpec and limited experience with Ruby, Rails, and TDD fundamentals. Youll begin by writing a very simple Ruby library in true TDD fashion and and use the red, green, refactor tools to migrate this library into a Rails application. Instant RSpec Test-Driven Development How-to will teach you the actual steps performed in writing an idiomatic specification. You will be able to write a test for the code you wish you had, and learn to write only the minimum code necessary to pass a test, and write more specifications to drive out the production functionality your application will need. Through the course of the book, you will convert a Ruby program into a new Rails application, test Rails specifics such as file uploads, cookies, and model validation and even learn how to use Capybara. RSpec Test Driven Development will help you build confidence in the code they you write and spend less time dealing with bugs and maintenance headaches. What you will learn from this book RSpec fundamentals How to use RSpec and Rails together Modify your behavior to create tests first and run your specs with every code change How to work with the rspec command line tool Using mocks and stubs to decouple tests from the database How to refactor code to improve readability Approach Filled with practical, step-by-step instructions and clear explanations for the most important and useful tasks. A concise guide that delivers immediate results with practical recipes on learning practical hints. Who this book is written for This book is aimed at Ruby developers with beginner level expertise who want to use RSpec and test driven development methodology to improve the code they write. Experienced programmers new to Ruby will also benefit from this book which also covers creating testable, idiomatic Ruby code.				Excluded	Excluded	new_screen			2						
148	Behave	Behavior-Driven Load Testing Using Contextual Knowledge - Approach and Experiences	Load testing is widely considered a meaningful technique for performance quality assurance. However, empirical studies reveal that in practice, load testing is not applied systematically, due to the sound expert knowledge required to specify, implement, and execute load tests.Our Behavior-driven Load Testing (BDLT) approach eases load test specification and execution for users with no or little expert knowledge. It allows a user to describe a load test in a template-based natural language and to rely on an automated framework to execute the test. Utilizing the system's contextual knowledge such as workload-influencing events, the framework automatically determines the workload and test configuration. We investigated the applicability of our approach in an industrial case study, where we were able to express four load test concerns using BDLT and received positive feedback from our industrial partner. They understood the BDLT definitions well and proposed further applications, such as the usage for software quality acceptance criteria.	behavior-driven testing; declarative performance engineering; load testing	Schulz, Henning; Okanović, Dušan; van Hoorn, André; Ferme, Vincenzo; Pautasso, Cesare	Proceedings of the 2019 ACM/SPEC International Conference on Performance Engineering	Load testing is widely considered a meaningful technique for performance quality assurance. However, empirical studies reveal that in practice, load testing is not applied systematically, due to the sound expert knowledge required to specify, implement, and execute load tests.Our Behavior-driven Load Testing (BDLT) approach eases load test specification and execution for users with no or little expert knowledge. It allows a user to describe a load test in a template-based natural language and to rely on an automated framework to execute the test. Utilizing the system's contextual knowledge such as workload-influencing events, the framework automatically determines the workload and test configuration. We investigated the applicability of our approach in an industrial case study, where we were able to express four load test concerns using BDLT and received positive feedback from our industrial partner. They understood the BDLT definitions well and proposed further applications, such as the usage for software quality acceptance criteria.				Included	Included	new_screen			2						
149	Behave	Challenges &amp; Opportunities in Low-Code Testing	Low-code is a growing development approach supported by many platforms. It fills the gap between business and IT by supporting the active involvement of non-technical domain experts, named Citizen Developer, in the application development lifecycle.Low-code introduces new concepts and characteristics. However, it is not investigated yet in academic research to point out the existing challenges and opportunities when testing low-code software. This shortage of resources motivates this research to provide an explicit definition to this area that we call it Low-Code Testing.In this paper, we initially conduct an analysis of the testing components of five commercial Low-Code Development Platforms (LCDP) to present low-code testing advancements from a business point of view. Based on the low-code principles as well as the result of our analysis, we propose a feature list for low-code testing along with possible values for them. This feature list can be used as a baseline for comparing low-code testing components and as a guideline for building new ones. Accordingly, we specify the status of the testing components of investigated LCDPs based on the proposed features. Finally, the challenges of low-code testing are introduced considering three concerns: the role of citizen developer in testing, the need for high-level test automation, and cloud testing. We provide references to the state-of-the-art to specify the difficulties and opportunities from an academic perspective. The results of this research can be used as a starting point for future research in low-code testing area.	testing; citizen developer; low-code; low-code development platform	Khorram, Faezeh; Mottu, Jean-Marie; Sunyé, Gerson	Proceedings of the 23rd ACM/IEEE International Conference on Model Driven Engineering Languages and Systems: Companion Proceedings	Low-code is a growing development approach supported by many platforms. It fills the gap between business and IT by supporting the active involvement of non-technical domain experts, named Citizen Developer, in the application development lifecycle.Low-code introduces new concepts and characteristics. However, it is not investigated yet in academic research to point out the existing challenges and opportunities when testing low-code software. This shortage of resources motivates this research to provide an explicit definition to this area that we call it Low-Code Testing.In this paper, we initially conduct an analysis of the testing components of five commercial Low-Code Development Platforms (LCDP) to present low-code testing advancements from a business point of view. Based on the low-code principles as well as the result of our analysis, we propose a feature list for low-code testing along with possible values for them. This feature list can be used as a baseline for comparing low-code testing components and as a guideline for building new ones. Accordingly, we specify the status of the testing components of investigated LCDPs based on the proposed features. Finally, the challenges of low-code testing are introduced considering three concerns: the role of citizen developer in testing, the need for high-level test automation, and cloud testing. We provide references to the state-of-the-art to specify the difficulties and opportunities from an academic perspective. The results of this research can be used as a starting point for future research in low-code testing area.				Excluded	Excluded	new_screen			2						
150	Behave	Toward leveraging Gherkin Controlled Natural Language and Machine Translation for Global Product Information Development	Machine Translation (MT) already plays an important part in software development process at McAfee where the technology can be leveraged to provide early builds for localization and internationalization testing teams. Behavior Driven Development (BDD) has been growing in usage as a development methodology in McAfee. Within BDD, the Gherkin Controlled Natural Language (CNL) is a syntax and common terminology set that is used to describe the software or business process in a User Story. Given there exists this control on the language to describe User Stories for software features using Gherkin, we seek to use Machine Translation to Globalize it at high accuracy and without Post-Editing and reuse it as Product Information. This enables global product information development to happen as part of the Software Development Life Cycle (SDLC) and at low cost. © 2018 Morgan O’Brien, McAfee LLC.		O’Brien M.	EAMT 2018 - Proceedings of the 21st Annual Conference of the European Association for Machine Translation	Machine Translation (MT) already plays an important part in software development process at McAfee where the technology can be leveraged to provide early builds for localization and internationalization testing teams. Behavior Driven Development (BDD) has been growing in usage as a development methodology in McAfee. Within BDD, the Gherkin Controlled Natural Language (CNL) is a syntax and common terminology set that is used to describe the software or business process in a User Story. Given there exists this control on the language to describe User Stories for software features using Gherkin, we seek to use Machine Translation to Globalize it at high accuracy and without Post-Editing and reuse it as Product Information. This enables global product information development to happen as part of the Software Development Life Cycle (SDLC) and at low cost. © 2018 Morgan O’Brien, McAfee LLC.				Included	Included	new_screen			2						
151	Behave	Automating test oracles from restricted natural language agile requirements	Manual testing of software requirements written in natural language for agile or any other methodology requires more time and human resources. This leaves the testing process error prone and time consuming. For satisfied end users with bug-free software delivered on time, there is a need to automate the test oracle process for natural language or informal requirements. The automation of the test oracle is relatively easier with formal requirements, but this task is difficult to achieve with natural language requirements. This study proposes an approach called Restricted Natural Language Agile Requirements Testing (ReNaLART) to automate the test oracle from restricted natural language agile requirements. For this purpose, it uses an existing user story template with some modifications for writing user stories. This helps in identifying test input and expected output for a user story. For comparison of expected and observed outputs it makes use of a regex pattern and string distance functions. It is capable of assigning different types of verdicts automatically depending upon the similarity/dissimilarity between observed and expected outputs of user stories. ReNaLART is validated using several case studies of different domains, namely, OLX Pakistan, Mental Health Tests, McDelivery Pakistan, BlueStacks, Power Searching with Google, TensorFlow Playground, w3Schools 2018 offline and Touch'D. It revealed several faults in five of the above listed eight applications. Plus, the proposed test oracle on an average took 0.02 s for test data generation, expected output generation and verdict assignment. Both these facts show the fault revealing effectiveness and efficiency of ReNaLART. © 2020 John Wiley & Sons, Ltd		Malik M.I., Sindhu M.A., Khattak A.S., Abbasi R.A., Saleem K.	Expert Systems	Manual testing of software requirements written in natural language for agile or any other methodology requires more time and human resources. This leaves the testing process error prone and time consuming. For satisfied end users with bug-free software delivered on time, there is a need to automate the test oracle process for natural language or informal requirements. The automation of the test oracle is relatively easier with formal requirements, but this task is difficult to achieve with natural language requirements. This study proposes an approach called Restricted Natural Language Agile Requirements Testing (ReNaLART) to automate the test oracle from restricted natural language agile requirements. For this purpose, it uses an existing user story template with some modifications for writing user stories. This helps in identifying test input and expected output for a user story. For comparison of expected and observed outputs it makes use of a regex pattern and string distance functions. It is capable of assigning different types of verdicts automatically depending upon the similarity/dissimilarity between observed and expected outputs of user stories. ReNaLART is validated using several case studies of different domains, namely, OLX Pakistan, Mental Health Tests, McDelivery Pakistan, BlueStacks, Power Searching with Google, TensorFlow Playground, w3Schools 2018 offline and Touch'D. It revealed several faults in five of the above listed eight applications. Plus, the proposed test oracle on an average took 0.02 s for test data generation, expected output generation and verdict assignment. Both these facts show the fault revealing effectiveness and efficiency of ReNaLART. © 2020 John Wiley & Sons, Ltd				Included	Included	new_screen			2						
152	Behave	Scenario-Based Microservice Retrieval Using Word2Vec	Microservice architecture (MSA) is an emerging software architectural style, which differs fundamentally from the monolithic, layered architecture. During the development and maintenance of microservice systems, how to provide an effective service retrieval mechanism is a critical challenge to avoid the problems of rework and duplicate code. Meanwhile, nowadays, using the BDD (Behavior-Driven Development) method to develop microservices becomes more and more popular due to its agility and domain-driven characteristics. BDD is an agile software development approach emphasizing that test cases are written in a common language to include scenarios that describe the features of a target system. In this paper, we propose an approach, referred to as SMSR (Scenario-based MicroService Retrieval), to recommend appropriate microservices to users based on the user-written BDD test scenarios. The proposed service retrieval algorithm is based on word2vec, a widely-used machine learning method in NLP (Natural Language Processing), to perform service filtering and service similarity calculation. Experiment results show that SMSR is able to effectively retrieve appropriate microservices from the service repository.	Microservice, Microservice Retrieval, Requirement Scenario, Behavior-Driven Development, word2vec	S. Ma; Y. Chuang; C. Lan; H. Chen; C. Huang; C. Li	2018 IEEE 15th International Conference on e-Business Engineering (ICEBE)	Microservice architecture (MSA) is an emerging software architectural style, which differs fundamentally from the monolithic, layered architecture. During the development and maintenance of microservice systems, how to provide an effective service retrieval mechanism is a critical challenge to avoid the problems of rework and duplicate code. Meanwhile, nowadays, using the BDD (Behavior-Driven Development) method to develop microservices becomes more and more popular due to its agility and domain-driven characteristics. BDD is an agile software development approach emphasizing that test cases are written in a common language to include scenarios that describe the features of a target system. In this paper, we propose an approach, referred to as SMSR (Scenario-based MicroService Retrieval), to recommend appropriate microservices to users based on the user-written BDD test scenarios. The proposed service retrieval algorithm is based on word2vec, a widely-used machine learning method in NLP (Natural Language Processing), to perform service filtering and service similarity calculation. Experiment results show that SMSR is able to effectively retrieve appropriate microservices from the service repository.				Included	Included	new_screen			2						
153	Behave	Agile development cycle: Approach to design an effective Model Based Testing with Behaviour driven automation framework	Model Based Testing (MBT) is a relatively an approach widely discussed in software testing. It extends test automation from test design to test execution using automatic test generation from models. The effective use of this approach requires new skills, technology and knowledge, such as test modelling skills, but also good programs and tool support. This paper explores a design of a Behaviour driven test automation framework using MBT and how it can be effectively used during Agile Development. The automation framework is experimented upon the integration of the Graphwalker, a Model Based Graphical User Interface test generator with behaviour driven development framework and Robot Framework. © 2014 IEEE.		Sivanandan S., Yogeesha C.B.	2014 20th Annual International Conference on Advanced Computing and Communications, ADCOM 2014 - Proceedings	Model Based Testing (MBT) is a relatively an approach widely discussed in software testing. It extends test automation from test design to test execution using automatic test generation from models. The effective use of this approach requires new skills, technology and knowledge, such as test modelling skills, but also good programs and tool support. This paper explores a design of a Behaviour driven test automation framework using MBT and how it can be effectively used during Agile Development. The automation framework is experimented upon the integration of the Graphwalker, a Model Based Graphical User Interface test generator with behaviour driven development framework and Robot Framework. © 2014 IEEE.				Included	Included	new_screen			2						
154	Behave	Automated Test Case Generation from Domain Specific Models of High-Level Requirements	Model-based software development has been shown to improve productivity and quality of software through automation. This involves using abstractions or models at several stages of development. This work reports on preliminary attempts to automate the generation of test cases from software requirement models using an industrial case study. The requirements are represented using a modeling notation and test cases are automatically generated using model to text transformation techniques.	domain specific languages; model-based testing	Olajubu, Oyindamola; Ajit, Suraj; Johnson, Mark; Turner, Scott; Thomson, Scott; Edwards, Mark	Proceedings of the 2015 Conference on Research in Adaptive and Convergent Systems	Model-based software development has been shown to improve productivity and quality of software through automation. This involves using abstractions or models at several stages of development. This work reports on preliminary attempts to automate the generation of test cases from software requirement models using an industrial case study. The requirements are represented using a modeling notation and test cases are automatically generated using model to text transformation techniques.				Excluded	Excluded	new_screen			2						
155	Behave	Towards a Workflow for Model-Based Testing of Embedded Systems	Model-based testing (MBT) has been previously used to validate embedded systems. However, (i) creation of a model conforming to the behavioural aspects of an embedded system, (ii) generation of executable test scripts and (iii) assessment of test verdict, re-quires a systematic process. In this paper, we have presented a three-phase tool-supported MBT workflow for the testing of an embedded system, that spans from requirements specification to test verdict assessment. The workflow starts with a simplistic, yet practical, application of a Domain-Specific Language (DSL) based on Gherkin-like style, which allows the requirements engineer to specify requirements and to extract information about model elements(i.e. states and transitions). This is done to assist the graphical modelling of the complete system under test (SUT). Later stages of the workflow generates an executable test script that runs on a domain-specific simulation platform. We have evaluated this tool-supported workflow by specifying the requirements, extracting information from the DSL and developing a model of a subsystem of the train control management system developed at Alstom Transport AB in Sweden. The C# test script generated from the SUT model is successfully executed at the Software-in-the-Loop (SIL) execution platform and test verdicts are visualized as a sequence of passed and failed test steps.	Domain-Specific Language; Model-Based Testing; Software-in-the-Loop	Zafar, Muhammad Nouman; Afzal, Wasif; Enoiu, Eduard	Proceedings of the 12th International Workshop on Automating TEST Case Design, Selection, and Evaluation	Model-based testing (MBT) has been previously used to validate embedded systems. However, (i) creation of a model conforming to the behavioural aspects of an embedded system, (ii) generation of executable test scripts and (iii) assessment of test verdict, re-quires a systematic process. In this paper, we have presented a three-phase tool-supported MBT workflow for the testing of an embedded system, that spans from requirements specification to test verdict assessment. The workflow starts with a simplistic, yet practical, application of a Domain-Specific Language (DSL) based on Gherkin-like style, which allows the requirements engineer to specify requirements and to extract information about model elements(i.e. states and transitions). This is done to assist the graphical modelling of the complete system under test (SUT). Later stages of the workflow generates an executable test script that runs on a domain-specific simulation platform. We have evaluated this tool-supported workflow by specifying the requirements, extracting information from the DSL and developing a model of a subsystem of the train control management system developed at Alstom Transport AB in Sweden. The C# test script generated from the SUT model is successfully executed at the Software-in-the-Loop (SIL) execution platform and test verdicts are visualized as a sequence of passed and failed test steps.				Included	Included	new_screen			2						
156	Behave	Model-Based Testing in Practice: An Industrial Case Study Using GraphWalker	Model-based testing (MBT) is a test design technique that supports the automation of software testing processes and generates test artefacts based on a system model representing behavioural aspects of the system under test (SUT). Previous research has shown some positive aspects of MBT such as low-cost test case generation and fault detection effectiveness. However, it is still a challenge for both practitioners and researchers to evaluate MBT tools and techniques in real, industrial settings. Consequently, the empirical evidence regarding the mainstream use, including the modelling and test case generation using MBT tools, is limited. In this paper, we report the results of a case study on applying GraphWalker, an open-source tool for MBT, on an industrial cyber-physical system (i.e., a Train Control Management System developed by Bombardier Transportation in Sweden), from modelling of real-world requirements and test specifications to test case generation. We evaluate the models of the SUT for completeness and representativeness, compare MBT with manual test cases written by practitioners using multiple attributes as well as share our experiences of selecting and using GraphWalker for industrial application. The results show that a model of the SUT created using both requirements and test specifications provides better understanding of the SUT from testers’ perspective, making it more complete and representative than the model created based only on the requirements specification alone. The generated model-based test cases are longer in terms of the number of test steps, achieve better edge coverage and can cover requirements more frequently in different orders while achieving the same level of requirements coverage as manually created test cases.		Zafar, Muhammad Nouman; Afzal, Wasif; Enoiu, Eduard; Stratis, Athanasios; Arrieta, Aitor; Sagardui, Goiuria	14th Innovations in Software Engineering Conference (Formerly Known as India Software Engineering Conference)	Model-based testing (MBT) is a test design technique that supports the automation of software testing processes and generates test artefacts based on a system model representing behavioural aspects of the system under test (SUT). Previous research has shown some positive aspects of MBT such as low-cost test case generation and fault detection effectiveness. However, it is still a challenge for both practitioners and researchers to evaluate MBT tools and techniques in real, industrial settings. Consequently, the empirical evidence regarding the mainstream use, including the modelling and test case generation using MBT tools, is limited. In this paper, we report the results of a case study on applying GraphWalker, an open-source tool for MBT, on an industrial cyber-physical system (i.e., a Train Control Management System developed by Bombardier Transportation in Sweden), from modelling of real-world requirements and test specifications to test case generation. We evaluate the models of the SUT for completeness and representativeness, compare MBT with manual test cases written by practitioners using multiple attributes as well as share our experiences of selecting and using GraphWalker for industrial application. The results show that a model of the SUT created using both requirements and test specifications provides better understanding of the SUT from testers’ perspective, making it more complete and representative than the model created based only on the requirements specification alone. The generated model-based test cases are longer in terms of the number of test steps, achieve better edge coverage and can cover requirements more frequently in different orders while achieving the same level of requirements coverage as manually created test cases.				Excluded	Excluded	new_screen			2						
157	Behave	Towards behavior driven operations (BDOps)	Modern Enterprise Software Systems entail many challenges such as availability, scalability, complexity and providing business agility. Ensuring the systems to be up and running for 24 × 7 has become a mandate for operations. Agile development has been adopted to keep pace with the demands of business and IT. Test Driven Development (TDD) and Behavior Driven Development (BDD) are practices, which enable agile development. So far the agile approach has been limited to development. For ensuring business to be truly agile, we need to take forward the agile approach to operations. In this paper, we discuss the behavior driven approach for operations specifically on the core sub-systems like infrastructure provisioning, deployment and monitoring. We share our explorations and experiments with Behavior Driven Monitoring (BDM) and how the same can be adopted for infrastructure provisioning and deployment. We used Cucumber-Nagios to detect behavior of an enterprise application. We close this paper with a note on the benefits to busmess and IT showing its relevance to DevOps, Continuous Delivery and Cloud Computing.	Behavior Driven Development;Behavior Driven Operations;Behavior Driven Monitoring;Cucumber-Nagios;Behavior Driven Infrastructure	K. Gohil; N. Alapati; S. Joglekar	3rd International Conference on Advances in Recent Technologies in Communication and Computing (ARTCom 2011)	Modern Enterprise Software Systems entail many challenges such as availability, scalability, complexity and providing business agility. Ensuring the systems to be up and running for 24 × 7 has become a mandate for operations. Agile development has been adopted to keep pace with the demands of business and IT. Test Driven Development (TDD) and Behavior Driven Development (BDD) are practices, which enable agile development. So far the agile approach has been limited to development. For ensuring business to be truly agile, we need to take forward the agile approach to operations. In this paper, we discuss the behavior driven approach for operations specifically on the core sub-systems like infrastructure provisioning, deployment and monitoring. We share our explorations and experiments with Behavior Driven Monitoring (BDM) and how the same can be adopted for infrastructure provisioning and deployment. We used Cucumber-Nagios to detect behavior of an enterprise application. We close this paper with a note on the benefits to busmess and IT showing its relevance to DevOps, Continuous Delivery and Cloud Computing.				Included	Included	new_screen			2						
158	Behave	Combining behaviour-driven development with scrum for software development in the education domain	Most of the Brazilian universities employ teaching-learning methodologies based on classic frontal lectures. The Medicine Programme of the Federal University of São Carlos (UFSCar) is an exception, since it employs active learning methodologies. The Educational and Academic Management System for Courses Based on Active Learning Methodologies (EAMS-CBALM) was built and it is currently used to support this programme, and has been made available for other programmes as well. This system was developed using Scrum, but during its development project it was often necessary to reconsider system behaviour scenarios, and consequently the product backlog items, mainly due to poor communication between the Product Owner (PO) and the development team. This paper discusses a case study in which Behaviour-Driven Development (BDD) has been used in combination with Scrum to redesign some EAMS-CBALM components. The paper demonstrates that the communication between the PO and the development team can be improved by using BDD as a communication platform to unambiguously define system requirements and automatically generate test suites. ©2017 by SCITEPRESS - Science and Technology Publications, Lda. All rights reserved.		De Souza P.L., Do Prado A.F., De Souza W.L., Dos Santos Forghieri Pereira S.M., Pires L.F.	ICEIS 2017 - Proceedings of the 19th International Conference on Enterprise Information Systems	Most of the Brazilian universities employ teaching-learning methodologies based on classic frontal lectures. The Medicine Programme of the Federal University of São Carlos (UFSCar) is an exception, since it employs active learning methodologies. The Educational and Academic Management System for Courses Based on Active Learning Methodologies (EAMS-CBALM) was built and it is currently used to support this programme, and has been made available for other programmes as well. This system was developed using Scrum, but during its development project it was often necessary to reconsider system behaviour scenarios, and consequently the product backlog items, mainly due to poor communication between the Product Owner (PO) and the development team. This paper discusses a case study in which Behaviour-Driven Development (BDD) has been used in combination with Scrum to redesign some EAMS-CBALM components. The paper demonstrates that the communication between the PO and the development team can be improved by using BDD as a communication platform to unambiguously define system requirements and automatically generate test suites. ©2017 by SCITEPRESS - Science and Technology Publications, Lda. All rights reserved.				Included	Included	new_screen			2						
159	Behave	Enterprise ontology-driven development	Most of the current techniques and approaches for user requirements specification have problems with capturing the appropriate context for development of enterprise information systems. Primarily, they are designed to capture the functional aspects of software rather than its relevancy to an enterprise. Transactions defined in the DEMO (Design & Engineering Methodology for Organizations) represent business activities in their existential essence without implementation details. Therefore, they are great candidates to be utilized for the initial development phase of enterprise information systems. The paper exemplifies how to specify software specification the using the DEMO transaction pattern and BDD (Behaviour-Driven Development) technique. This proposal resulted from a significant lack of direct utilization of ontology for enterprise information systems development. The major part of the paper gives a step-by-step explanation of how to integrate DEMO transaction patterns into initial BDD scenarios for the development of enterprise information systems. Such created scenarios provide a perfect guideline in the initial phase of information system development for enterprises. The created scenarios were verified using the domain specific language Gherkin and BDD framework Behat. © Springer Nature Switzerland AG 2018.		Matula J., Hunka F.	Lecture Notes in Business Information Processing	Most of the current techniques and approaches for user requirements specification have problems with capturing the appropriate context for development of enterprise information systems. Primarily, they are designed to capture the functional aspects of software rather than its relevancy to an enterprise. Transactions defined in the DEMO (Design & Engineering Methodology for Organizations) represent business activities in their existential essence without implementation details. Therefore, they are great candidates to be utilized for the initial development phase of enterprise information systems. The paper exemplifies how to specify software specification the using the DEMO transaction pattern and BDD (Behaviour-Driven Development) technique. This proposal resulted from a significant lack of direct utilization of ontology for enterprise information systems development. The major part of the paper gives a step-by-step explanation of how to integrate DEMO transaction patterns into initial BDD scenarios for the development of enterprise information systems. Such created scenarios provide a perfect guideline in the initial phase of information system development for enterprises. The created scenarios were verified using the domain specific language Gherkin and BDD framework Behat. © Springer Nature Switzerland AG 2018.				Included	Included	new_screen			2						
160	Behave	A Behavior-Based Ontology for Supporting Automated Assessment of Interactive Systems	Nowadays many software development frameworks implement Behavior-Driven Development (BDD) as a mean of automating the test of interactive systems under construction. Automated testing helps to simulate user's action on the User Interface and therefore check if the system behaves properly and in accordance to Scenarios that describe functional requirements. However, most of tools supporting BDD requires that tests should be written using low-level events and components that only exist when the system is already implemented. As a consequence of such low-level of abstraction, BDD tests can hardly be reused with diverse artifacts and with versions of the system. To address this problem, this paper proposes to raise the abstraction level by the means of a behavior-based ontology that is aimed at supporting test automation. The paper presents an ontology and an ontology-based approach for automating the test of functional requirements of interactive systems. With the help of a case study for the flight tickets e-commerce domain, we demonstrate how tests written using our ontology can be used to assess functional requirements using different artifacts, from low-fidelity to full-fledged UI Prototypes.	Automated Requirements Assessment;Behavior-Driven Development;Ontological Modeling;Testing of Interactive Systems	T. R. Silva; J. Hak; M. Winckler	2017 IEEE 11th International Conference on Semantic Computing (ICSC)	Nowadays many software development frameworks implement Behavior-Driven Development (BDD) as a mean of automating the test of interactive systems under construction. Automated testing helps to simulate user's action on the User Interface and therefore check if the system behaves properly and in accordance to Scenarios that describe functional requirements. However, most of tools supporting BDD requires that tests should be written using low-level events and components that only exist when the system is already implemented. As a consequence of such low-level of abstraction, BDD tests can hardly be reused with diverse artifacts and with versions of the system. To address this problem, this paper proposes to raise the abstraction level by the means of a behavior-based ontology that is aimed at supporting test automation. The paper presents an ontology and an ontology-based approach for automating the test of functional requirements of interactive systems. With the help of a case study for the flight tickets e-commerce domain, we demonstrate how tests written using our ontology can be used to assess functional requirements using different artifacts, from low-fidelity to full-fledged UI Prototypes.				Included	Included	new_screen			2						
161	Behave	A Formal Ontology for Describing Interactive Behaviors and Supporting Automated Testing on User Interfaces	Nowadays many software development frameworks implement Behavior-Driven Development (BDD) as a mean of automating the test of interactive systems under construction. Automated testing helps to simulate user's actions on the User Interface and therefore check if the system behaves properly and in accordance to scenarios that describe functional requirements. However, tools supporting BDD run tests on implemented User Interfaces and are a suitable alternative for assessing functional requirements in later phases of the development process. However, even when BDD tests can be written in early phases of the development process they can hardly be used with specifications of User Interfaces such as prototypes. To address this problem, this paper proposes to raise the abstraction level of both system interactive behaviors and User Interfaces by means of a formal ontology that is aimed at supporting test automation using BDD. The paper presents an ontology and an ontology-based approach for automating the test of functional requirements of interactive systems. We demonstrate the feasibility of this ontology-based approach to assess functional requirements in prototypes and full-fledge applications through an illustrative case study of e-commerce applications for buying flight tickets. © 2017 World Scientific Publishing Company.		Silva T.R., Hak J.-L., Winckler M.	International Journal of Semantic Computing	Nowadays many software development frameworks implement Behavior-Driven Development (BDD) as a mean of automating the test of interactive systems under construction. Automated testing helps to simulate user's actions on the User Interface and therefore check if the system behaves properly and in accordance to scenarios that describe functional requirements. However, tools supporting BDD run tests on implemented User Interfaces and are a suitable alternative for assessing functional requirements in later phases of the development process. However, even when BDD tests can be written in early phases of the development process they can hardly be used with specifications of User Interfaces such as prototypes. To address this problem, this paper proposes to raise the abstraction level of both system interactive behaviors and User Interfaces by means of a formal ontology that is aimed at supporting test automation using BDD. The paper presents an ontology and an ontology-based approach for automating the test of functional requirements of interactive systems. We demonstrate the feasibility of this ontology-based approach to assess functional requirements in prototypes and full-fledge applications through an illustrative case study of e-commerce applications for buying flight tickets. © 2017 World Scientific Publishing Company.				Included	Included	new_screen			2						
162	Behave	Behavior Driven Development: Tools and Challenges	Nowadays testing usually applies Test Driven Development (TDD) which is an approach to software development in which developers write tests first which initially fail and by adding more application codes tests pass. However, the latest development in this field is an extension to Test Driven Development (TDD) which usually referred as Behavior Driven Development (BDD). As being a modified version of TDD, both the technologies have various similarities. Nevertheless, the differences are also not unnoticeable. Where BDD is more about communication and collaboration TDD is more about coders and coding. This paper focuses on the advantages and glitches of TDD which led to the development of along with the method of working of BDD and several tools along with their features and a comparison of their functionalities.	Manual Testing;Test Driven Development (TDD);Behavior Driven Development (BDD);Collaboration	R. K. Lenka; S. Kumar; S. Mamgain	2018 International Conference on Advances in Computing, Communication Control and Networking (ICACCCN)	Nowadays testing usually applies Test Driven Development (TDD) which is an approach to software development in which developers write tests first which initially fail and by adding more application codes tests pass. However, the latest development in this field is an extension to Test Driven Development (TDD) which usually referred as Behavior Driven Development (BDD). As being a modified version of TDD, both the technologies have various similarities. Nevertheless, the differences are also not unnoticeable. Where BDD is more about communication and collaboration TDD is more about coders and coding. This paper focuses on the advantages and glitches of TDD which led to the development of along with the method of working of BDD and several tools along with their features and a comparison of their functionalities.				Included	Included	new_screen			2						
163	Behave	Behavior Driven Development Approach in the Modern Quality Control Process	Nowadays usually the Behavior Driven Development is the approach of choice for the quality control engineers, especially for the long-term projects with the big amount of the audits, because of its main advantage - clear test scenarios visualization and understanding for the not involved persons. However, this approach could not reach its maximum efficiency without proper usage, but the documentation covers only the high-level practices which are not always enough to write the good test scenarios. That is why it is needed to describe the best practices and techniques of the usage of behavior-driven development, formed with the experience of its use. These practices would help to create correct and well understandable behavior scenarios, with the ability to use them as part of the technical documentation. Behavior-driven development would be considered in the comparison with the test-driven development and the domain-driven design approaches - the other important strategies in the quality assurance process.	behaviour driven development;test driven development;quality control;gherkin;practice;technique;scenario;feature;keyword;step	O. Bezsmertnyi; N. Golian; V. Golian; I. Afanasieva	2020 IEEE International Conference on Problems of Infocommunications. Science and Technology (PIC S&T)	Nowadays usually the Behavior Driven Development is the approach of choice for the quality control engineers, especially for the long-term projects with the big amount of the audits, because of its main advantage - clear test scenarios visualization and understanding for the not involved persons. However, this approach could not reach its maximum efficiency without proper usage, but the documentation covers only the high-level practices which are not always enough to write the good test scenarios. That is why it is needed to describe the best practices and techniques of the usage of behavior-driven development, formed with the experience of its use. These practices would help to create correct and well understandable behavior scenarios, with the ability to use them as part of the technical documentation. Behavior-driven development would be considered in the comparison with the test-driven development and the domain-driven design approaches - the other important strategies in the quality assurance process.				Included	Included	new_screen			2						
164	Behave	Behavior driven development for tests and verification	Nowadays, hardware is usually tested and verified at postdesign time. The bottom line is that more effort is spend in the validation phases than in the implementation, because it is harder to fix bugs in later design stages than during the implementation of the design. In contrast, test-first approaches such as test driven development (TDD) have become increasingly important for software development. Behavior driven development (BDD) extends TDD by using natural language style scenarios to describe tests. But both approaches miss formal verification methods which are very important in hardware design. This research project presents a new approach based on BDD that combines testing and verification seamlessly. © Springer Fachmedien Wiesbaden 2015. All rights reserved.		Diepenbeck M.	Formal Modeling and Verification of Cyber-Physical Systems: 1st International Summer School on Methods and Tools for the Design of Digital Systems, Bremen, Germany, September 2015	Nowadays, hardware is usually tested and verified at postdesign time. The bottom line is that more effort is spend in the validation phases than in the implementation, because it is harder to fix bugs in later design stages than during the implementation of the design. In contrast, test-first approaches such as test driven development (TDD) have become increasingly important for software development. Behavior driven development (BDD) extends TDD by using natural language style scenarios to describe tests. But both approaches miss formal verification methods which are very important in hardware design. This research project presents a new approach based on BDD that combines testing and verification seamlessly. © Springer Fachmedien Wiesbaden 2015. All rights reserved.				Excluded	Excluded	new_screen			2						
165	Behave	Towards Automatic Scenario Generation from Coverage Information	Nowadays, the design of software systems is pushed towards agile development practices. One of its most fundamental approaches is Test Driven Development (TDD). This procedure is based on test cases which are incrementally written prior to the implementation. Recently, Behavior Driven Development (BDD) has been introduced as an extension of TDD, in which natural language scenarios are the starting point for the test cases. This description offers a ubiquitous communication mean for both the software developers and stakeholders.Following the BDD methodology thoroughly, one would expect 100% code coverage, since code is only written to make the test cases pass. However, as we show in an empirical study this expectation is not valid in practice. It becomes even worse in the process of development, i.e. the coverage decreases over time. To close the coverage gap, we sketch an algorithm that generates BDD-style scenarios based on uncovered code.		Diepenbeck, Melanie; Soeken, Mathias; Große, Daniel; Drechsler, Rolf	Proceedings of the 8th International Workshop on Automation of Software Test	Nowadays, the design of software systems is pushed towards agile development practices. One of its most fundamental approaches is Test Driven Development (TDD). This procedure is based on test cases which are incrementally written prior to the implementation. Recently, Behavior Driven Development (BDD) has been introduced as an extension of TDD, in which natural language scenarios are the starting point for the test cases. This description offers a ubiquitous communication mean for both the software developers and stakeholders.Following the BDD methodology thoroughly, one would expect 100% code coverage, since code is only written to make the test cases pass. However, as we show in an empirical study this expectation is not valid in practice. It becomes even worse in the process of development, i.e. the coverage decreases over time. To close the coverage gap, we sketch an algorithm that generates BDD-style scenarios based on uncovered code.				Included	Included	new_screen			2						
166	Behave	Towards automatic scenario generation from coverage information	Nowadays, the design of software systems is pushed towards agile development practices. One of its most fundamental approaches is Test Driven Development (TDD). This procedure is based on test cases which are incrementally written prior to the implementation. Recently, Behavior Driven Development (BDD) has been introduced as an extension of TDD, in which natural language scenarios are the starting point for the test cases. This description offers a ubiquitous communication mean for both the software developers and stakeholders. Following the BDD methodology thoroughly, one would expect 100 % code coverage, since code is only written to make the test cases pass. However, as we show in an empirical study this expectation is not valid in practice. It becomes even worse in the process of development, i.e. the coverage decreases over time. To close the coverage gap, we sketch an algorithm that generates BDD-style scenarios based on uncovered code.		M. Diepenbeck; M. Soeken; D. Grobe; R. Drechsler	2013 8th International Workshop on Automation of Software Test (AST)	Nowadays, the design of software systems is pushed towards agile development practices. One of its most fundamental approaches is Test Driven Development (TDD). This procedure is based on test cases which are incrementally written prior to the implementation. Recently, Behavior Driven Development (BDD) has been introduced as an extension of TDD, in which natural language scenarios are the starting point for the test cases. This description offers a ubiquitous communication mean for both the software developers and stakeholders. Following the BDD methodology thoroughly, one would expect 100 % code coverage, since code is only written to make the test cases pass. However, as we show in an empirical study this expectation is not valid in practice. It becomes even worse in the process of development, i.e. the coverage decreases over time. To close the coverage gap, we sketch an algorithm that generates BDD-style scenarios based on uncovered code.				Excluded	Excluded	new_screen			2						
167	Behave	Using Gherkin to Extract Tests and Monitors for Safer Medical Device Interaction Design	Number entry systems on medical devices are safety critical and it is important to get them right. Interaction design teams can be multidisciplinary, and in this work we present a process where the requirements of the system are drawn up using a Controlled Natural Language (CNL) that is understandable by non-technical experts or clients. These CNL requirements can also be directly used by the Quality Assurance (QA) team to test the system and monitor whether or not the system runs as it should once deployed. Since commonly, systems are too complex to test all possible execution paths before deployment, monitoring the system at runtime is useful in order to check that the system is running correctly. If at runtime, it is discovered that an anomaly is detected, the relevant personnel is notified through a report in natural language.	testing; medical devices; runtime verification; user interfaces	Cauchi, Abigail; Colombo, Christian; Francalanza, Adrian; Micallef, Mark; Pace, Gordon	Proceedings of the 8th ACM SIGCHI Symposium on Engineering Interactive Computing Systems	Number entry systems on medical devices are safety critical and it is important to get them right. Interaction design teams can be multidisciplinary, and in this work we present a process where the requirements of the system are drawn up using a Controlled Natural Language (CNL) that is understandable by non-technical experts or clients. These CNL requirements can also be directly used by the Quality Assurance (QA) team to test the system and monitor whether or not the system runs as it should once deployed. Since commonly, systems are too complex to test all possible execution paths before deployment, monitoring the system at runtime is useful in order to check that the system is running correctly. If at runtime, it is discovered that an anomaly is detected, the relevant personnel is notified through a report in natural language.				Included	Included	new_screen			2						
168	Behave	A Behavior-Driven Approach to Intent Specification for Software-Defined Infrastructure Management	"One of the goals of Software-Defined Networking (SDN) is to allow users to specify high-level policies into lower level network rules. Managing a network and decide what policy set is appropriate requires, however, expertise and low level know-how. An emerging SDN paradigm is to allow higher-level network level decisions wishes in the form of ""intents"". Despite its importance in simplifying network management, intent specification is not yet standardized. In this work, we propose a northbound interface (NBI) for intent declaration, based on Behavior-Driven Development. In our approach, intents are specified in plain English and translated by our system into pre-compiled network policies, that are in turn, converted into low-level rules by the software-defined infrastructure e.g. an SDN controller. We demonstrated our behavior-driven approach with two practical use cases: service function chaining deployed on OpenStack, supported by both ONOS and Ryu controllers, and dynamic firewall programming. We also measured the overhead and response time of our NBI. We believe that our approach is far more general and paves the way for a more expressive and simplified northbound interface for intent-driven networking."		F. Esposito; J. Wang; C. Contoli; G. Davoli; W. Cerroni; F. Callegati	2018 IEEE Conference on Network Function Virtualization and Software Defined Networks (NFV-SDN)	"One of the goals of Software-Defined Networking (SDN) is to allow users to specify high-level policies into lower level network rules. Managing a network and decide what policy set is appropriate requires, however, expertise and low level know-how. An emerging SDN paradigm is to allow higher-level network level decisions wishes in the form of ""intents"". Despite its importance in simplifying network management, intent specification is not yet standardized. In this work, we propose a northbound interface (NBI) for intent declaration, based on Behavior-Driven Development. In our approach, intents are specified in plain English and translated by our system into pre-compiled network policies, that are in turn, converted into low-level rules by the software-defined infrastructure e.g. an SDN controller. We demonstrated our behavior-driven approach with two practical use cases: service function chaining deployed on OpenStack, supported by both ONOS and Ryu controllers, and dynamic firewall programming. We also measured the overhead and response time of our NBI. We believe that our approach is far more general and paves the way for a more expressive and simplified northbound interface for intent-driven networking."				Included	Included	new_screen			2						
169	Behave	Feature-Trace: Generating Operational Profile and Supporting Testing Prioritization from BDD Features	Operational Profiles provide quantitative information about how the software will be used, which supports highlighting those software components more sensitive to reliability based on their profile usage. However, the generation of Operational Profiles usually requires a considerable team effort to liaise requirements specification until their reification into expected software artifacts. In this sense, it becomes paramount in the software life cycle the ability to seamlessly or efficiently perform traceability from requirement to code, embracing the testing process as a means to ensure that the requirements are satisfiably covered and addressed. In this work, we propose the Feature-Trace approach which merges the advantages of the Operational Profile and the benefits of the requirements-to-code traceability present in the BDD (Behavior-Driven Development) approach. The primary goal of our work is to use the BDD approach as an information source for the semi-automated generation of the Operational Profile. The proposed approach was evaluated on the Diaspora software, on a GitHub open source software. The case study revealed that the Feature-Trace approach is capable of extracting the operational profile seamlessly from the specified Diaspora's BDD features as well as obtaining and presenting vital information to guide the process of test cases prioritization.	behavior-driven development; operational profile; requirements traceability; testing	Fazzolino, Rafael; Rodrigues, Genaína Nunes	Proceedings of the XXXIII Brazilian Symposium on Software Engineering	Operational Profiles provide quantitative information about how the software will be used, which supports highlighting those software components more sensitive to reliability based on their profile usage. However, the generation of Operational Profiles usually requires a considerable team effort to liaise requirements specification until their reification into expected software artifacts. In this sense, it becomes paramount in the software life cycle the ability to seamlessly or efficiently perform traceability from requirement to code, embracing the testing process as a means to ensure that the requirements are satisfiably covered and addressed. In this work, we propose the Feature-Trace approach which merges the advantages of the Operational Profile and the benefits of the requirements-to-code traceability present in the BDD (Behavior-Driven Development) approach. The primary goal of our work is to use the BDD approach as an information source for the semi-automated generation of the Operational Profile. The proposed approach was evaluated on the Diaspora software, on a GitHub open source software. The case study revealed that the Feature-Trace approach is capable of extracting the operational profile seamlessly from the specified Diaspora's BDD features as well as obtaining and presenting vital information to guide the process of test cases prioritization.				Included	Included	new_screen			2						
170	Behave	Cucumber Cookbook	"Over 35 hands-on recipes to efficiently master the art of behaviour-driven development using Cucumber-JVM About This BookCreate a test automation framework to handle web, REST, and native mobile application automationDiscover Glue code, Hooks, Tags, and Cucumber's integration with Maven, Jenkins, and GitComprehensive recipes in Cucumber for behaviour-driven development and test automationWho This Book Is ForThis book is intended for business and development personnel who want to use Cucumber for behavior-driven development and test automation. Readers with some familiarity with Cucumber will find this book of most benefit.Since the main objective of this book is to create test automation frameworks, previous experience in automation will be helpful.What You Will Learn Explore the usage of the Gherkin Language to write meaningful and smart Feature files Understand Scenario, Steps, Backgrounds, Scenario Outlines, and Data Tables Discover the concepts of Glue Code and Step Definitions in detail Gain insights into the different types of Step Definitions, Regular Expressions, Doc Strings, Data Table transformations, and Capture Groups Master the advanced concepts of implementing Tags and Hooks Override default Cucumber options and settings along with different output report formats Run Jenkins and Cucumber from Terminal while running various Cucumber Scenarios in parallel In DetailToday, behaviour-driven development (BDD) is gaining popularity around the world. Cucumber-JVM is one of the fastest growing tools and offers a cutting-edge platform for conceptualizing and implementing BDD. The variety of features available within Cucumber enhances the experience of implementing BDD for both business and development teams.This book provides you with the skills you need to successfully create, customize, and configure the Cucumber framework. You will discover how to create Feature files, and Step Definitions, and enable various configurations, such as ""Before"" and ""After"" functions, with fun exercises. You'll round off your learning by creating automation frameworks to automate Web, REST, and Mobile apps."		Garg, Shankar		"Over 35 hands-on recipes to efficiently master the art of behaviour-driven development using Cucumber-JVM About This BookCreate a test automation framework to handle web, REST, and native mobile application automationDiscover Glue code, Hooks, Tags, and Cucumber's integration with Maven, Jenkins, and GitComprehensive recipes in Cucumber for behaviour-driven development and test automationWho This Book Is ForThis book is intended for business and development personnel who want to use Cucumber for behavior-driven development and test automation. Readers with some familiarity with Cucumber will find this book of most benefit.Since the main objective of this book is to create test automation frameworks, previous experience in automation will be helpful.What You Will Learn Explore the usage of the Gherkin Language to write meaningful and smart Feature files Understand Scenario, Steps, Backgrounds, Scenario Outlines, and Data Tables Discover the concepts of Glue Code and Step Definitions in detail Gain insights into the different types of Step Definitions, Regular Expressions, Doc Strings, Data Table transformations, and Capture Groups Master the advanced concepts of implementing Tags and Hooks Override default Cucumber options and settings along with different output report formats Run Jenkins and Cucumber from Terminal while running various Cucumber Scenarios in parallel In DetailToday, behaviour-driven development (BDD) is gaining popularity around the world. Cucumber-JVM is one of the fastest growing tools and offers a cutting-edge platform for conceptualizing and implementing BDD. The variety of features available within Cucumber enhances the experience of implementing BDD for both business and development teams.This book provides you with the skills you need to successfully create, customize, and configure the Cucumber framework. You will discover how to create Feature files, and Step Definitions, and enable various configurations, such as ""Before"" and ""After"" functions, with fun exercises. You'll round off your learning by creating automation frameworks to automate Web, REST, and Mobile apps."				Excluded	Excluded	new_screen			2						
171	Behave	A semantic wiki approach to enable behaviour driven requirements management	Poorly managed requirements are considered as one of the principal causes of projects failure and consequently companies struggle to find an effective solution for requirements elicitation and further management. The adoption of such solution becomes even more difficult when the collaboration between different departments (e.g. marketing and development) is necessary. To address this challenge, the authors propose a methodology for requirements management based on Semantic Wiki and Behaviour Driven Development (BDD). BDD allows developers and end-users to interoperate and encourages seamless collaboration between all project participants. It also certifies that requirements are treated properly by their associated developments through the connection of textual descriptions to functional tests. Semantic wikis can be an added value in requirements management due to their enhanced browser interface and collaborative knowledge sharing capability. They allow stakeholders to participate in requirements management independently of their location. This is of major importance to reduce the problem of lack of inputs from interested parties. Moreover, with semantic wikis adoption, end-users and ontologies can coexist in one system since wiki pages are presented in a human-readable format in parallel to their formal representation in ontologies. This knowledge representation supports companies' decision-making by allowing managers to prioritize implementations, to keep a trace of requirements evolution, and reuse implementations when new requirements enter the system.		Marques-Lucena C., Agostinho C., Sarraipa J., Jardim-Goncalves R.	Control Engineering and Applied Informatics	Poorly managed requirements are considered as one of the principal causes of projects failure and consequently companies struggle to find an effective solution for requirements elicitation and further management. The adoption of such solution becomes even more difficult when the collaboration between different departments (e.g. marketing and development) is necessary. To address this challenge, the authors propose a methodology for requirements management based on Semantic Wiki and Behaviour Driven Development (BDD). BDD allows developers and end-users to interoperate and encourages seamless collaboration between all project participants. It also certifies that requirements are treated properly by their associated developments through the connection of textual descriptions to functional tests. Semantic wikis can be an added value in requirements management due to their enhanced browser interface and collaborative knowledge sharing capability. They allow stakeholders to participate in requirements management independently of their location. This is of major importance to reduce the problem of lack of inputs from interested parties. Moreover, with semantic wikis adoption, end-users and ontologies can coexist in one system since wiki pages are presented in a human-readable format in parallel to their formal representation in ontologies. This knowledge representation supports companies' decision-making by allowing managers to prioritize implementations, to keep a trace of requirements evolution, and reuse implementations when new requirements enter the system.				Included	Included	new_screen			2						
172	Behave	Dynamic signal driving strategy based high speed and low powered dual edge triggered flip flop design used memory applications	Power utilization assumes a massive part in any of the integrated circuits, and it’s rundown as a standout amongst essential difficulties in the universal innovation guide into semiconductors. Generally in integrated circuit, flip-flop and clock distribution system consume a lot of energy since they make and utilize the most extreme number of internal transitions. In the clock distribution system, the clock signal circulates from a typical point to every one of the components that required for the circuit. However this capacity is more important to the synchronous framework, much consideration needs to provide for the attributes of these clock signals. In the sequential circuits, a clock distribution system spends a lot of power given the high operating frequency of high capacitance. An existing approach to reducing the limits of a clock signal is based on the quantity of clocked transistors. In this, an advanced procedure is proposed and evaluated by utilizing Dual-Edge Triggered Flip-Flop (DETFF) depends on the Dynamic Signal Driving (DSD) strategy. This DETFF is executed in sequential circuits that have been ordered using Tanner Electronic Design Automation (EDA) tool which is used to simulate and examine control by using Dynamic Signal Driving (DSD) strategy. The outcomes demonstrate that the total power utilization is decreased in sequential benchmark circuit design. A number of Flip flops have been designed by various technologies such as reducing area, delay, and power, but this proposed dynamic signal driving scheme can be used for any integrated circuit- that can be reduced to all these three parameters to give the best trade-off for a particular ASIC platform.	Flip flop, Clock distribution system, Clocked transistor, Tanner, ASIC	Prithivi Raj, M.; Kavithaa, G.	Microprocessors and Microsystems	Power utilization assumes a massive part in any of the integrated circuits, and it’s rundown as a standout amongst essential difficulties in the universal innovation guide into semiconductors. Generally in integrated circuit, flip-flop and clock distribution system consume a lot of energy since they make and utilize the most extreme number of internal transitions. In the clock distribution system, the clock signal circulates from a typical point to every one of the components that required for the circuit. However this capacity is more important to the synchronous framework, much consideration needs to provide for the attributes of these clock signals. In the sequential circuits, a clock distribution system spends a lot of power given the high operating frequency of high capacitance. An existing approach to reducing the limits of a clock signal is based on the quantity of clocked transistors. In this, an advanced procedure is proposed and evaluated by utilizing Dual-Edge Triggered Flip-Flop (DETFF) depends on the Dynamic Signal Driving (DSD) strategy. This DETFF is executed in sequential circuits that have been ordered using Tanner Electronic Design Automation (EDA) tool which is used to simulate and examine control by using Dynamic Signal Driving (DSD) strategy. The outcomes demonstrate that the total power utilization is decreased in sequential benchmark circuit design. A number of Flip flops have been designed by various technologies such as reducing area, delay, and power, but this proposed dynamic signal driving scheme can be used for any integrated circuit- that can be reduced to all these three parameters to give the best trade-off for a particular ASIC platform.				Excluded	Excluded	new_screen			2						
173	Behave	Pro Agile .NET Development with SCRUM	Pro Agile .NET Development with SCRUMguides youthrough a real-world ASP.NET project and shows how agile methodology is put into practice. There is plenty of literature on the theory behind agile methodologies, but no book on the market takes the concepts of agile practices and applies these in a practical manner to an end-to-end ASP.NET project, especially the estimating, requirements and management aspects of a project. Pro Agile .NET Development with SCRUM takes you through the initial stages of a project–gathering requirementsand setting up an environment–through to the development and deployment stages using an agile iterative approach: namely, Scrum. In the book,you'll focuson delivering an enterprise-level ASP.NET project. Each chapter is in iterations or sprints, putting into practice the features of agile–user stories, test-driven development (TDD), behavior-driven development (BDD), continuous integration, user acceptance testing, extreme programming, Scrum, design patterns and principles, inside-out development, lean developent, KanBan boards, and more. An appendix features code katas designed for the reader to get up-to-speed with some of the features of extreme programming, while also showcasing popular open-source frameworks to assist in automated testing and mocking. What you'll learn Gain practical knowledge on employing the Scrum project methodology using a real-world ASP.NET project Seehow extreme programming features in real world .NET projects Learnbest-practice tools foruser interfaceanduser acceptance testing, such as waitiN Discoverdetails on how to capture requirements and drive development using user stories Learnhow to estimate and plan agile projects and work with business stakeholders through a practical example Uncover tips for developing using the outside-in, TDD and BDD methodologies Gain information on tracking the progress of a project through burn down charts, iterations and retrospectives Who this book is for Experienced .NET developers who are looking to see how the Scrum agile project methodology and extreme programming features are employed in a real-world .NET application.		Blankenship, Jerrel; Bussa, Matthew; Millett, Scott		Pro Agile .NET Development with SCRUMguides youthrough a real-world ASP.NET project and shows how agile methodology is put into practice. There is plenty of literature on the theory behind agile methodologies, but no book on the market takes the concepts of agile practices and applies these in a practical manner to an end-to-end ASP.NET project, especially the estimating, requirements and management aspects of a project. Pro Agile .NET Development with SCRUM takes you through the initial stages of a project–gathering requirementsand setting up an environment–through to the development and deployment stages using an agile iterative approach: namely, Scrum. In the book,you'll focuson delivering an enterprise-level ASP.NET project. Each chapter is in iterations or sprints, putting into practice the features of agile–user stories, test-driven development (TDD), behavior-driven development (BDD), continuous integration, user acceptance testing, extreme programming, Scrum, design patterns and principles, inside-out development, lean developent, KanBan boards, and more. An appendix features code katas designed for the reader to get up-to-speed with some of the features of extreme programming, while also showcasing popular open-source frameworks to assist in automated testing and mocking. What you'll learn Gain practical knowledge on employing the Scrum project methodology using a real-world ASP.NET project Seehow extreme programming features in real world .NET projects Learnbest-practice tools foruser interfaceanduser acceptance testing, such as waitiN Discoverdetails on how to capture requirements and drive development using user stories Learnhow to estimate and plan agile projects and work with business stakeholders through a practical example Uncover tips for developing using the outside-in, TDD and BDD methodologies Gain information on tracking the progress of a project through burn down charts, iterations and retrospectives Who this book is for Experienced .NET developers who are looking to see how the Scrum agile project methodology and extreme programming features are employed in a real-world .NET application.				Excluded	Excluded	new_screen			2						
174	Behave	Behavior-driven development in product configuration systems	Product Configuration Systems (PCS) are increasingly used by companies to automate the performance of the sales and engineering processes. Since the benefits from such projects have huge variations, it is crucial to make the right decisions when scoping and developing PCSs. The development of PCS is influenced by both business interests and technical insights. Developers of PCS face various challenges while working in team, including different stakeholders such as business owners, developers, project managers, and product experts. The more diverse the team is, the more significant are the challenges. This paper suggests that Behavior-driven Development (BDD) may provide configuration teams with a specific structure to express scenarios (and thus constraints) on PCS in natural language. BDD may yield benefits such as a better expression of PCS constraints, more efficient communication of requirements and incorporation of the expressed rules in a software transformation process. In other words, applying BDD may eliminate unnecessary tasks when gathering knowledge, developing, and testing PCS projects. In this paper, we present a novel approach from an ongoing project on how to relate BDD to the development process of PCS while using Scrum-based methods. © 2018 CEUR-WS. All rights reserved.		Shafiee S., Hvam L., Haug A., Wautelet Y.	CEUR Workshop Proceedings	Product Configuration Systems (PCS) are increasingly used by companies to automate the performance of the sales and engineering processes. Since the benefits from such projects have huge variations, it is crucial to make the right decisions when scoping and developing PCSs. The development of PCS is influenced by both business interests and technical insights. Developers of PCS face various challenges while working in team, including different stakeholders such as business owners, developers, project managers, and product experts. The more diverse the team is, the more significant are the challenges. This paper suggests that Behavior-driven Development (BDD) may provide configuration teams with a specific structure to express scenarios (and thus constraints) on PCS in natural language. BDD may yield benefits such as a better expression of PCS constraints, more efficient communication of requirements and incorporation of the expressed rules in a software transformation process. In other words, applying BDD may eliminate unnecessary tasks when gathering knowledge, developing, and testing PCS projects. In this paper, we present a novel approach from an ongoing project on how to relate BDD to the development process of PCS while using Scrum-based methods. © 2018 CEUR-WS. All rights reserved.				Included	Included	new_screen			2						
175	Behave	Light-Weight Software Product Lines for Small and Medium-Sized Enterprises (SMEs)	Product line engineering practices promote the idea of systematic reuse of core assets and have been reported to decrease time-to-market and development costs for new products. However, our recent efforts to transfer our product line engineering knowledge to several of our small and medium-size enterprise industrial partner showed that there are challenges that need to be addressed before core product line engineering ideas can be deployed in SME context. These challenges include upfront investment costs, business traceability, levels of abstraction of functional features and semantic distinction between functional and non-functional software aspects. In order to address these challenges within the context of SMEs, we adopt and extend the behavior-driven development methodology in a way to not only offer agility in practice but also to equip software developers with the means to capture and manage software variability within the behavior-driven development process. We introduce the details of the extended methodology and discuss its advantages and disadvantages in detail.		Bagheri, Ebrahim; Ensan, Faezeh	Proceedings of the 2013 Conference of the Center for Advanced Studies on Collaborative Research	Product line engineering practices promote the idea of systematic reuse of core assets and have been reported to decrease time-to-market and development costs for new products. However, our recent efforts to transfer our product line engineering knowledge to several of our small and medium-size enterprise industrial partner showed that there are challenges that need to be addressed before core product line engineering ideas can be deployed in SME context. These challenges include upfront investment costs, business traceability, levels of abstraction of functional features and semantic distinction between functional and non-functional software aspects. In order to address these challenges within the context of SMEs, we adopt and extend the behavior-driven development methodology in a way to not only offer agility in practice but also to equip software developers with the means to capture and manage software variability within the behavior-driven development process. We introduce the details of the extended methodology and discuss its advantages and disadvantages in detail.				Included	Included	new_screen			2						
176	Behave	Chapter 8 - Integrating Automation into Your Development Process	Publisher Summary The concept of continuous integration has been around for quite a while now. There are many tools to provide continuous integration and surprisingly, some even work together. Any investment in continuous integration will pay off but it requires discipline that few developers, QA resources, or management actually have at the start of the process. The challenge is to train the development staff and the QA to use continuous integration to work smarter, not harder. There is much interest in continuous integration, and many organizations are implementing continuous integration tools as part of their move to agile development. Difficulty surrounds this move because not only do developers have to change some working habits, but also there typically is a large investment required matching the capabilities of the tool to the organization itself and for that reason alone it is daunting. Many tools, whether they are open source or commercial products, exist for performing automation. The platform in use for development, including the operating system or the development environment platform, as well as the delivery platform of the end product, may restrict the selection of tools. Additionally, the software development language in use may dictate a narrow selection of tools. Some development shops may have restrictions regarding what software can be brought in due to security concerns.		Holtsnider, Bill; Wheeler, Tom; Stragand, George; Gee, Joseph		Publisher Summary The concept of continuous integration has been around for quite a while now. There are many tools to provide continuous integration and surprisingly, some even work together. Any investment in continuous integration will pay off but it requires discipline that few developers, QA resources, or management actually have at the start of the process. The challenge is to train the development staff and the QA to use continuous integration to work smarter, not harder. There is much interest in continuous integration, and many organizations are implementing continuous integration tools as part of their move to agile development. Difficulty surrounds this move because not only do developers have to change some working habits, but also there typically is a large investment required matching the capabilities of the tool to the organization itself and for that reason alone it is daunting. Many tools, whether they are open source or commercial products, exist for performing automation. The platform in use for development, including the operating system or the development environment platform, as well as the delivery platform of the end product, may restrict the selection of tools. Additionally, the software development language in use may dictate a narrow selection of tools. Some development shops may have restrictions regarding what software can be brought in due to security concerns.				Excluded	Excluded	new_screen			2						
177	Behave	Chapter 4.1 - The Psychology of Programming in the Large: Team and Organizational Behaviour	Publisher Summary This chapter focuses on the psychology of programming in relation to team and organizational behavior. Software development must be studied at several behavioural levels. Organizing programmers into teams superimposes a layer of social behavior on the cognitive requirements of programming tasks. Two structures have been proposed for programming teams based on the centralized versus decentralized team organizations often studied in group dynamics research. A hybrid approach to structuring programming teams might be taken on large projects that have characteristics favourable to different types of programming teams. Programming team activities offer many opportunities for peer review activities that may be formal or informal components of the development process. On the other hand, team methodologies must focus on coordinating the tasks and product concept. The structure of programming teams should reflect the nature of the task rather than the organization, allow members to speak as if with one mind, and determine the tasks the team can effectively handle.		Curtis, Bill; Walz, Diane		Publisher Summary This chapter focuses on the psychology of programming in relation to team and organizational behavior. Software development must be studied at several behavioural levels. Organizing programmers into teams superimposes a layer of social behavior on the cognitive requirements of programming tasks. Two structures have been proposed for programming teams based on the centralized versus decentralized team organizations often studied in group dynamics research. A hybrid approach to structuring programming teams might be taken on large projects that have characteristics favourable to different types of programming teams. Programming team activities offer many opportunities for peer review activities that may be formal or informal components of the development process. On the other hand, team methodologies must focus on coordinating the tasks and product concept. The structure of programming teams should reflect the nature of the task rather than the organization, allow members to speak as if with one mind, and determine the tasks the team can effectively handle.				Excluded	Excluded	new_screen			2						
178	Behave	Intuitive design: framing a software test system as a status reporting tool for business	Purpose: This paper aims to present a conceptual framework of how software teams can leverage the implicit information of implemented acceptance tests to cater to the needs of decision makers. The research questions on this framework were how business stakeholders can receive project status information in an intuitive way and how this framework can guarantee the traceability of tests to requirements. Design/methodology/approach: The conceptual framework delineates the design of an acceptance test framework in three aspects: how the requirements model reflects the evolving states of requirement maturity over a project, how the acceptance test model becomes synchronized with the requirements model without a traceability matrix and how the acceptance test model communicates business value to the decision makers. Findings: In an industrial case study, the presented framework yielded the positive effects of intuitive understanding by business stakeholders, high test coverage of requirements and distinctly reduced manual quality assurance (QA) work by automated testing for browsers and mobile devices. Practical implications: The presented framework can help to convince business stakeholders to approve the budget for building a testing framework because it delivers them value as a status reporting tool. Originality/value: This paper is the first to describe a step-by-step approach to solving a critical problem that IT departments frequently face. The solution consists in a new way of transforming the perception of a technical framework into a reporting tool for business information by intuitive design. The idea of mapping hierarchically corresponding abstraction layers can be transferred to other engineering domains. © 2017, © Emerald Publishing Limited.		So C.	Journal of Engineering, Design and Technology	Purpose: This paper aims to present a conceptual framework of how software teams can leverage the implicit information of implemented acceptance tests to cater to the needs of decision makers. The research questions on this framework were how business stakeholders can receive project status information in an intuitive way and how this framework can guarantee the traceability of tests to requirements. Design/methodology/approach: The conceptual framework delineates the design of an acceptance test framework in three aspects: how the requirements model reflects the evolving states of requirement maturity over a project, how the acceptance test model becomes synchronized with the requirements model without a traceability matrix and how the acceptance test model communicates business value to the decision makers. Findings: In an industrial case study, the presented framework yielded the positive effects of intuitive understanding by business stakeholders, high test coverage of requirements and distinctly reduced manual quality assurance (QA) work by automated testing for browsers and mobile devices. Practical implications: The presented framework can help to convince business stakeholders to approve the budget for building a testing framework because it delivers them value as a status reporting tool. Originality/value: This paper is the first to describe a step-by-step approach to solving a critical problem that IT departments frequently face. The solution consists in a new way of transforming the perception of a technical framework into a reporting tool for business information by intuitive design. The idea of mapping hierarchically corresponding abstraction layers can be transferred to other engineering domains. © 2017, © Emerald Publishing Limited.				Included	Included	new_screen			2						
179	Behave	IOS Code Testing: Test-Driven Development and Behavior-Driven Development with Swift	Put into motion practical examples to master Test-Driven Development (TDD) and acceptance testing in Swift. This book uses a pragmatic approach to writing well-tested code and provides techniques that can be used to retrofit tests to legacy code bases. You'll be introduced to basic principles of TDD, such as Test First, Red-Green-Refactor, Remove Duplicate code, Dependency Injection, and Single Responsibility. Approaches covered include TDD, behavior-driven development (BDD), UI, and acceptance testing with common standard/open source frameworks. iOS Code Testing offers helpful instruction to teach iOS developers to retrospectively fit tests to legacy code, refactor legacy code so as to make the code more testable, install and configure a popular Swift BDD framework, practice BDD with Xcode, and create automated UI tests with Xcode. Additionally, many projects have legacy code bases. Legacy code is often seen as a blocker when it comes to implementing any kind of testing. What You Will Learn Fit test to legacy code retrospectively Install and configure popular Swift BDD frameworks Practice BDD with Xcode Who This Book Is For Software practitioners, such as Swift developers and mobile app testers.		Mishra, Abhishek		Put into motion practical examples to master Test-Driven Development (TDD) and acceptance testing in Swift. This book uses a pragmatic approach to writing well-tested code and provides techniques that can be used to retrofit tests to legacy code bases. You'll be introduced to basic principles of TDD, such as Test First, Red-Green-Refactor, Remove Duplicate code, Dependency Injection, and Single Responsibility. Approaches covered include TDD, behavior-driven development (BDD), UI, and acceptance testing with common standard/open source frameworks. iOS Code Testing offers helpful instruction to teach iOS developers to retrospectively fit tests to legacy code, refactor legacy code so as to make the code more testable, install and configure a popular Swift BDD framework, practice BDD with Xcode, and create automated UI tests with Xcode. Additionally, many projects have legacy code bases. Legacy code is often seen as a blocker when it comes to implementing any kind of testing. What You Will Learn Fit test to legacy code retrospectively Install and configure popular Swift BDD frameworks Practice BDD with Xcode Who This Book Is For Software practitioners, such as Swift developers and mobile app testers.				Excluded	Excluded	new_screen			2						
180	Behave	Modern and Responsive Mobile-enabled Web Applications	Rapid web technology improvements in the last few years have powered software developers to quickly write responsive mobile-friendly applications. The innovative web frameworks and libraries make it easy to have same software code base for desktop and mobile devices. Single-page applications offer a more-native-app-like experience to the user. This also means a web application can easily be converted to a native mobile application if desired. This allows software products to be evolved continuously at a much faster pace with features added on daily basis. The software companies who can adopt these technologies will most likely see the benefit in the long run as they can offer new and modified products faster than their competitors. In this paper, we review some of the state-of-the-art web technologies, third-party libraries, and frameworks for quick interactive web development. Finally, we present a simple interactive browser-based, mobile friendly web application which was developed using one of the latest web development framework.	Web-based Applications, JavaScript, Web Framework, Mobile-friendly Application, Single-Page Applications	Shahzad, Farrukh	Procedia Computer Science	Rapid web technology improvements in the last few years have powered software developers to quickly write responsive mobile-friendly applications. The innovative web frameworks and libraries make it easy to have same software code base for desktop and mobile devices. Single-page applications offer a more-native-app-like experience to the user. This also means a web application can easily be converted to a native mobile application if desired. This allows software products to be evolved continuously at a much faster pace with features added on daily basis. The software companies who can adopt these technologies will most likely see the benefit in the long run as they can offer new and modified products faster than their competitors. In this paper, we review some of the state-of-the-art web technologies, third-party libraries, and frameworks for quick interactive web development. Finally, we present a simple interactive browser-based, mobile friendly web application which was developed using one of the latest web development framework.				Excluded	Excluded	new_screen			2						
181	Behave	Reengineering legacy systems with transaction model	Reengineering of legacy systems is one of trickiest challenges in software development. The paper addresses methodologies applicable to re-engineering legacy information systems. Specifically, it points out a possibility to couple ontological descriptions of the enterprise with information systems features. Such interconnection verifies whether a functionality implemented in the information system relates to business tasks or not. Business processes formulated as DEMO transaction patterns together with Behavior-Driven Development technique enable to link existing businesses processes to production codebase. © 2018 Author(s).		Matula J., Zacek J.	AIP Conference Proceedings	Reengineering of legacy systems is one of trickiest challenges in software development. The paper addresses methodologies applicable to re-engineering legacy information systems. Specifically, it points out a possibility to couple ontological descriptions of the enterprise with information systems features. Such interconnection verifies whether a functionality implemented in the information system relates to business tasks or not. Business processes formulated as DEMO transaction patterns together with Behavior-Driven Development technique enable to link existing businesses processes to production codebase. © 2018 Author(s).				Included	Included	new_screen			2						
182	Behave	A Requirement-based Regression Test Selection Technique in Behavior-Driven Development	Regression testing is an essential software maintenance activity before the release of a new version implementing a bug fix or a new feature. A regression test selection (RTS) technique chooses a subset of existing test cases to ensure that the system will not be adversely affected by the latest modifications. With the rise of DevOps, behavior-driven development (BDD) is growing in popularity as it is in close alignment with agile practices, for example, continuous integration. Hence, it is necessary to propose a novel and effective RTS technique for BDD specifically to accelerate the development process while ensuring software quality. Since most existing techniques for RTS are code-based and thus subject to some limitations, we present a requirement-based technique which uses the requirements in BDD to select test cases in both high-level (acceptance testing) and low-level (unit testing). Our technique firstly illustrates the new requirement with a scenario, and subsequently computes the semantic similarity of the new scenario and all existing scenarios with the vector space model. According to the results, the modification-traversing regression test cases can be selected in a semi-automated way. We also conduct an experimental study to evaluate our technique in terms of inclusiveness, precision, efficiency and generality. The study shows that our technique is applicable for BDD and effective in practice.	regression test selection;behavior-driven development;requirement-based technique;vector space model	J. Xu; Q. Du; X. Li	2021 IEEE 45th Annual Computers, Software, and Applications Conference (COMPSAC)	Regression testing is an essential software maintenance activity before the release of a new version implementing a bug fix or a new feature. A regression test selection (RTS) technique chooses a subset of existing test cases to ensure that the system will not be adversely affected by the latest modifications. With the rise of DevOps, behavior-driven development (BDD) is growing in popularity as it is in close alignment with agile practices, for example, continuous integration. Hence, it is necessary to propose a novel and effective RTS technique for BDD specifically to accelerate the development process while ensuring software quality. Since most existing techniques for RTS are code-based and thus subject to some limitations, we present a requirement-based technique which uses the requirements in BDD to select test cases in both high-level (acceptance testing) and low-level (unit testing). Our technique firstly illustrates the new requirement with a scenario, and subsequently computes the semantic similarity of the new scenario and all existing scenarios with the vector space model. According to the results, the modification-traversing regression test cases can be selected in a semi-automated way. We also conduct an experimental study to evaluate our technique in terms of inclusiveness, precision, efficiency and generality. The study shows that our technique is applicable for BDD and effective in practice.				Included	Included	new_screen			2						
183	Behave	Interface Responsibility Patterns: Processing Resources and Operation Responsibilities	Remote Application Programming Interfaces (APIs), as for instance offered in microservices architectures, are used in almost any distributed system today and are thus enablers for many digitalization efforts. It is hard to design such APIs so that they are easy and effective to use; maintaining their runtime qualities while preserving backward compatibility is equally challenging. Finding well suited granularities in terms of the architectural capabilities of endpoints and the read-write semantics of their operations are particularly important design concerns. Existing pattern languages have dealt with local APIs in object-oriented programming, with remote objects, with queue-based messaging and with service-oriented computing platforms. However, patterns or equivalent guidances for the architectural design of API endpoints, operations and their request and response message structures are still missing. In this paper, we extend our microservice API pattern language (MAP) and introduce endpoint role and operation responsibility patterns, namely Processing Resource, Computation Function, State Creation Operation, Retrieval Operation, and State Transition Operation. Known uses and examples of the patterns are drawn from public Web APIs, as well as application development and system integration projects the authors have been involved in.		Zimmermann, Olaf; Lübke, Daniel; Zdun, Uwe; Pautasso, Cesare; Stocker, Mirko	Proceedings of the European Conference on Pattern Languages of Programs 2020	Remote Application Programming Interfaces (APIs), as for instance offered in microservices architectures, are used in almost any distributed system today and are thus enablers for many digitalization efforts. It is hard to design such APIs so that they are easy and effective to use; maintaining their runtime qualities while preserving backward compatibility is equally challenging. Finding well suited granularities in terms of the architectural capabilities of endpoints and the read-write semantics of their operations are particularly important design concerns. Existing pattern languages have dealt with local APIs in object-oriented programming, with remote objects, with queue-based messaging and with service-oriented computing platforms. However, patterns or equivalent guidances for the architectural design of API endpoints, operations and their request and response message structures are still missing. In this paper, we extend our microservice API pattern language (MAP) and introduce endpoint role and operation responsibility patterns, namely Processing Resource, Computation Function, State Creation Operation, Retrieval Operation, and State Transition Operation. Known uses and examples of the patterns are drawn from public Web APIs, as well as application development and system integration projects the authors have been involved in.				Excluded	Excluded	new_screen			2						
184	Behave	A Conceptual Metamodel to Bridging Requirement Patterns to Test Patterns	Requirement patterns represent an abstraction of an application's behaviors and services that, in turn, may be replicated in similar applications. However, there has been a lack of efforts exploiting the benefits of requirement patterns in other phases of the software development life cycle, besides the requirements engineering itself. To address this gap, we propose the Software Pattern MetaModel (SoPaMM) that bridges requirement patterns to groups of scenarios with similar behaviors in the form of test patterns. SoPaMM allows the description of the behavior of a requirement pattern through a time executable and easy-to-use language aiming at the automatic generation of test patterns. Using SoPaMM, we model and implement a behavior-driven functional requirement pattern for a web-based user authentication application. Our preliminary results point out that a requirement pattern can be an executable specification capable of generating automated tests.	behavior; metamodeling; requirement pattern; reuse; test pattern	Kudo, Taciana Novo; Bulcão-Neto, Renato F.; Vincenzi, Auri M. R.	Proceedings of the XXXIII Brazilian Symposium on Software Engineering	Requirement patterns represent an abstraction of an application's behaviors and services that, in turn, may be replicated in similar applications. However, there has been a lack of efforts exploiting the benefits of requirement patterns in other phases of the software development life cycle, besides the requirements engineering itself. To address this gap, we propose the Software Pattern MetaModel (SoPaMM) that bridges requirement patterns to groups of scenarios with similar behaviors in the form of test patterns. SoPaMM allows the description of the behavior of a requirement pattern through a time executable and easy-to-use language aiming at the automatic generation of test patterns. Using SoPaMM, we model and implement a behavior-driven functional requirement pattern for a web-based user authentication application. Our preliminary results point out that a requirement pattern can be an executable specification capable of generating automated tests.				Included	Included	new_screen			2						
185	Behave	A Framework to Diminish the Gap between the Business Specialist and the Software Designer	"Requirements Engineering establishes the process for defining requirements as one in which elicitation, modeling and analysis are tasks which must be carried out. This process should involve different stakeholders and their different viewpoints. Among these stakeholders, there is the software designer, responsible for creating models based on the information gathered by business specialists. However, this communication channel may create some ""noise"" that leads to information being lost. This loss produces a semantic gap between what is desired and what will be developed. The semantic gap is characterized by inconsistencies in the requirements represented by scenarios–user stories in a behavior-driven context–and by the conceptual model. This paper presents an interactive approach to the agile requirements modeling, thus fostering greater consistency between the artifacts of the scenarios and the conceptual model. This consistency is ensured by using a mind model specification which will serve as a basis for transforming the definitions of the scenario and generating a conceptual model represented by a UML class diagram. The mind model represents the main role of this approach, and functions as a bond that represents the business entities, thus enabling the requirements to be more consistent with the reality of the business."	Behaviour Driven Development; Agile Modeling Requirements; Domain Model; Mind Map Modeling; UML	Wanderley, Fernando; da Silveria, Denis Silva	Proceedings of the 2012 Eighth International Conference on the Quality of Information and Communications Technology	"Requirements Engineering establishes the process for defining requirements as one in which elicitation, modeling and analysis are tasks which must be carried out. This process should involve different stakeholders and their different viewpoints. Among these stakeholders, there is the software designer, responsible for creating models based on the information gathered by business specialists. However, this communication channel may create some ""noise"" that leads to information being lost. This loss produces a semantic gap between what is desired and what will be developed. The semantic gap is characterized by inconsistencies in the requirements represented by scenarios–user stories in a behavior-driven context–and by the conceptual model. This paper presents an interactive approach to the agile requirements modeling, thus fostering greater consistency between the artifacts of the scenarios and the conceptual model. This consistency is ensured by using a mind model specification which will serve as a basis for transforming the definitions of the scenario and generating a conceptual model represented by a UML class diagram. The mind model represents the main role of this approach, and functions as a bond that represents the business entities, thus enabling the requirements to be more consistent with the reality of the business."				Included	Included	new_screen			2						
186	Behave	Using Behaviour-driven Requirements Engineering for Establishing and Managing Agile Product Lines: An Observational Study	Requirements engineering in agile product line engineering refers to both common and variability components establishing a software. Although it is conventional for the requirements engineering to take place in a dedicated upfront domain analysis phase, agile-based environments denounce such a proactive behaviour. This paper provides an observational study examining a reactive incremental requirement engineering approach called behaviour-driven requirements engineering. The proposed approach uses behaviour-driven development to establish and maintain agile product lines. The findings of the study are very promising and suggest the following: the approach is easy to understand and quick to learn; the approach supports the constantly changing nature of software development; and using behaviour-driven requirements engineering produces reliable and coherent requirements. In practice, the observational study showed that using the proposed approach saved time for development team and customers, decreased costs, improved the software quality, and shortened the time-to-market. © 2021. All Rights Reserved.		Elshandidy H., Mazen S., Hassanein E., Nasr E.	International Journal of Advanced Computer Science and Applications	Requirements engineering in agile product line engineering refers to both common and variability components establishing a software. Although it is conventional for the requirements engineering to take place in a dedicated upfront domain analysis phase, agile-based environments denounce such a proactive behaviour. This paper provides an observational study examining a reactive incremental requirement engineering approach called behaviour-driven requirements engineering. The proposed approach uses behaviour-driven development to establish and maintain agile product lines. The findings of the study are very promising and suggest the following: the approach is easy to understand and quick to learn; the approach supports the constantly changing nature of software development; and using behaviour-driven requirements engineering produces reliable and coherent requirements. In practice, the observational study showed that using the proposed approach saved time for development team and customers, decreased costs, improved the software quality, and shortened the time-to-market. © 2021. All Rights Reserved.				Included	Included	new_screen			2						
187	Behave	Towards Automated Testing of RPA Implementations	Robotic Process Automation (RPA) is a technology that has grown tremendously in the last years, due to its usability in the area of process automation. An essential part of any software development process is quality assurance, so testing will be very important for RPA processes. However, the classical software techniques are not always suitable for the RPA software robots due to the mix of the graphical description of the robots and their implementations. In this short paper, we describe the state of the practice for testing of software robots and propose some ideas of test automation using model-based testing.	Test automation; Model-based testing; Robotic Process Automation (RPA); RPA testing	Cernat, Marina; Staicu, Adelina Nicoleta; Stefanescu, Alin	Proceedings of the 11th ACM SIGSOFT International Workshop on Automating TEST Case Design, Selection, and Evaluation	Robotic Process Automation (RPA) is a technology that has grown tremendously in the last years, due to its usability in the area of process automation. An essential part of any software development process is quality assurance, so testing will be very important for RPA processes. However, the classical software techniques are not always suitable for the RPA software robots due to the mix of the graphical description of the robots and their implementations. In this short paper, we describe the state of the practice for testing of software robots and propose some ideas of test automation using model-based testing.				Excluded	Excluded	new_screen			2						
188	Behave	Agent-oriented software patterns for rapid and affordable robot programming	Robotic systems are often quite complex to develop; they are huge, heavily constrained from the non-functional point of view and they implement challenging algorithms. The lack of integrated methods with reuse approaches leads robotic developers to reinvent the wheel each time a new project starts. This paper proposes to reuse the experience done when building robotic applications, by catching it into design patterns. These represent a general mean for (i) reusing proved solutions increasing the final quality, (ii) communicating the knowledge about a domain and (iii) reducing the development time and effort. Despite of this generality, the proposed repository of patterns is specific for multi-agent robotic systems. These patterns are documented by a set of design diagrams and the corresponding implementing code is obtained through a series of automatic transformations. Some patterns extracted from an existing and freely available repository are presented. The paper also discusses an experimental set-up based on the construction of a complete robotic application obtained by composing some highly reusable patterns.	Multi-agent systems, Design patterns, Pattern oriented design, Robotics systems	Chella, Antonio; Cossentino, Massimo; Gaglio, Salvatore; Sabatucci, Luca; Seidita, Valeria	Journal of Systems and Software	Robotic systems are often quite complex to develop; they are huge, heavily constrained from the non-functional point of view and they implement challenging algorithms. The lack of integrated methods with reuse approaches leads robotic developers to reinvent the wheel each time a new project starts. This paper proposes to reuse the experience done when building robotic applications, by catching it into design patterns. These represent a general mean for (i) reusing proved solutions increasing the final quality, (ii) communicating the knowledge about a domain and (iii) reducing the development time and effort. Despite of this generality, the proposed repository of patterns is specific for multi-agent robotic systems. These patterns are documented by a set of design diagrams and the corresponding implementing code is obtained through a series of automatic transformations. Some patterns extracted from an existing and freely available repository are presented. The paper also discusses an experimental set-up based on the construction of a complete robotic application obtained by composing some highly reusable patterns.				Excluded	Excluded	new_screen			2						
189	Behave	Ruby on Rails Tutorial: Learn Web Development with Rails	Ruby on Rails Tutorial by Michael Hartl has become a must-read for developers learning how to build Rails apps. Peter Cooper, Editor of Ruby Inside Using Rails, developers can build web applications of exceptional elegance and power. Although its remarkable capabilities have made Ruby on Rails one of the worlds most popular web development frameworks, it can be challenging to learn and use. Ruby on Rails Tutorial, Second Edition, is the solution. Best-selling author and leading Rails developer Michael Hartl teaches Rails by guiding you through the development of your own complete sample application using the latest techniques in Rails web development. The updates to this edition include all-new site design using Twitters Bootstrap; coverage of the new asset pipeline, including Sprockets and Sass; behavior-driven development (BDD) with Capybara and RSpec; better automated testing with Guard and Spork; roll your own authentication with has_secure_password; and an introduction to Gherkin and Cucumber. Youll find integrated tutorials not only for Rails, but also for the essential Ruby, HTML, CSS, JavaScript, and SQL skills youll need when developing web applications. Hartl explains how each new technique solves a real-world problem, and he demonstrates this with bite-sized code thats simple enough to understand, yet novel enough to be useful. Whatever your previous web development experience, this book will guide you to true Rails mastery. This book will help you Install and set up your Rails development environment Go beyond generated code to truly understand how to build Rails applications from scratch Learn test-driven development (TDD) with RSpec Effectively use the Model-View-Controller (MVC) pattern Structure applications using the REST architecture Build static pages and transform them into dynamic ones Master the Ruby programming skills all Rails developers need Define high-quality site layouts and data models Implement registration and authentication systems, including validation and secure passwords Update, display, and delete users Add social features and microblogging, including an introduction to Ajax Record version changes with Git and share code at GitHub Simplify application deployment with Heroku		Hartl, Michael		Ruby on Rails Tutorial by Michael Hartl has become a must-read for developers learning how to build Rails apps. Peter Cooper, Editor of Ruby Inside Using Rails, developers can build web applications of exceptional elegance and power. Although its remarkable capabilities have made Ruby on Rails one of the worlds most popular web development frameworks, it can be challenging to learn and use. Ruby on Rails Tutorial, Second Edition, is the solution. Best-selling author and leading Rails developer Michael Hartl teaches Rails by guiding you through the development of your own complete sample application using the latest techniques in Rails web development. The updates to this edition include all-new site design using Twitters Bootstrap; coverage of the new asset pipeline, including Sprockets and Sass; behavior-driven development (BDD) with Capybara and RSpec; better automated testing with Guard and Spork; roll your own authentication with has_secure_password; and an introduction to Gherkin and Cucumber. Youll find integrated tutorials not only for Rails, but also for the essential Ruby, HTML, CSS, JavaScript, and SQL skills youll need when developing web applications. Hartl explains how each new technique solves a real-world problem, and he demonstrates this with bite-sized code thats simple enough to understand, yet novel enough to be useful. Whatever your previous web development experience, this book will guide you to true Rails mastery. This book will help you Install and set up your Rails development environment Go beyond generated code to truly understand how to build Rails applications from scratch Learn test-driven development (TDD) with RSpec Effectively use the Model-View-Controller (MVC) pattern Structure applications using the REST architecture Build static pages and transform them into dynamic ones Master the Ruby programming skills all Rails developers need Define high-quality site layouts and data models Implement registration and authentication systems, including validation and secure passwords Update, display, and delete users Add social features and microblogging, including an introduction to Ajax Record version changes with Git and share code at GitHub Simplify application deployment with Heroku				Excluded	Excluded	new_screen			2						
190	Behave	Offshore Development Center Management in Action	Serving as a virtual extension of the Customer's IT Department, the Offshore Development Center (ODC) model provides certain benefits in comparison with in-house teams including reduced development complexity, reduced operating expense, and access to a larger pool of talents. Nevertheless, ODCs are prone to problems in Scope, Schedule, Quality, Human Resources, and Communication. From the experiences of Project Managers who have worked in Offshore Development Centers set up by FPT Software- a leading IT Outsourcing Service provider, this paper offers a look at actual problems encountered in ODCs. We then provide a reference ODC Management Framework, which consists of Best Practices that we have applied into an ODC serving a Media Industry customer over the last 4 years. The results of applying the model are discussed to prove its effectiveness.	Offshore; Offshore development center; Outsourcing	Hung, Phan Duy; Cuong, Le Gia; Bach, Nguyen Luu	Proceedings of the 2020 5th International Conference on Intelligent Information Technology	Serving as a virtual extension of the Customer's IT Department, the Offshore Development Center (ODC) model provides certain benefits in comparison with in-house teams including reduced development complexity, reduced operating expense, and access to a larger pool of talents. Nevertheless, ODCs are prone to problems in Scope, Schedule, Quality, Human Resources, and Communication. From the experiences of Project Managers who have worked in Offshore Development Centers set up by FPT Software- a leading IT Outsourcing Service provider, this paper offers a look at actual problems encountered in ODCs. We then provide a reference ODC Management Framework, which consists of Best Practices that we have applied into an ODC serving a Media Industry customer over the last 4 years. The results of applying the model are discussed to prove its effectiveness.				Excluded	Excluded	new_screen			2						
191	Behave	Test-Driven Infrastructure with Chef: Bring Behavior-Driven Development to Infrastructure as Code	Since Test-Driven Infrastructure with Chef first appeared in mid-2011, infrastructure testing has begun to flourish in the web ops world. In this revised and expanded edition, author Stephen Nelson-Smith brings you up to date on this rapidly evolving discipline, including the philosophy driving it and a growing array of tools. Youll get a hands-on introduction to the Chef framework, and a recommended toolchain and workflow for developing your own test-driven production infrastructure. Several exercises and examples throughout the book help you gain experience with Chef and the entire infrastructure-testing ecosystem. Learn how this test-first approach provides increased security, code quality, and peace of mind.Explore the underpinning philosophy that infrastructure can and should be treated as code Become familiar with the MASCOT approach to test-driven infrastructure Understand the basics of test-driven and behavior-driven development for managing change Dive into Chef fundamentals by building an infrastructure with real examples Discover how Chef works with tools such as Virtualbox and Vagrant Get a deeper understanding of Chef by learning Ruby language basics Learn the tools and workflow necessary to conduct unit, integration, and acceptance tests		Nelson-Smith, Stephen		Since Test-Driven Infrastructure with Chef first appeared in mid-2011, infrastructure testing has begun to flourish in the web ops world. In this revised and expanded edition, author Stephen Nelson-Smith brings you up to date on this rapidly evolving discipline, including the philosophy driving it and a growing array of tools. Youll get a hands-on introduction to the Chef framework, and a recommended toolchain and workflow for developing your own test-driven production infrastructure. Several exercises and examples throughout the book help you gain experience with Chef and the entire infrastructure-testing ecosystem. Learn how this test-first approach provides increased security, code quality, and peace of mind.Explore the underpinning philosophy that infrastructure can and should be treated as code Become familiar with the MASCOT approach to test-driven infrastructure Understand the basics of test-driven and behavior-driven development for managing change Dive into Chef fundamentals by building an infrastructure with real examples Discover how Chef works with tools such as Virtualbox and Vagrant Get a deeper understanding of Chef by learning Ruby language basics Learn the tools and workflow necessary to conduct unit, integration, and acceptance tests				Excluded	Excluded	new_screen			2						
192	Behave	A permissioned blockchain-based implementation of LMSR prediction markets	Since the seminal work by Hanson (2003), the Logarithmic Market Scoring Rule (LMSR) has become the de facto market-maker mechanism for prediction markets. We suggest in this paper three potential issues with centralized implementations of LMSR, which we refer to as the availability, security, and privacy problems. We also explain how a permissioned blockchain-based implementation of LMSR effectively solves all the above problems. Following the design science research framework (Peffers et al., 2007), our main contribution is a fully functional permissioned blockchain-based implementation of LMSR that is ready to be deployed. We believe our results are of great value not only to prediction market researchers and practitioners looking for LMSR implementations, but also to blockchain professionals looking for fully developed solutions as well as applications of suitable research frameworks to guide blockchain research and development.	Blockchain, Design science, Logarithmic Market Scoring Rule, Prediction markets	Carvalho, Arthur	Decision Support Systems	Since the seminal work by Hanson (2003), the Logarithmic Market Scoring Rule (LMSR) has become the de facto market-maker mechanism for prediction markets. We suggest in this paper three potential issues with centralized implementations of LMSR, which we refer to as the availability, security, and privacy problems. We also explain how a permissioned blockchain-based implementation of LMSR effectively solves all the above problems. Following the design science research framework (Peffers et al., 2007), our main contribution is a fully functional permissioned blockchain-based implementation of LMSR that is ready to be deployed. We believe our results are of great value not only to prediction market researchers and practitioners looking for LMSR implementations, but also to blockchain professionals looking for fully developed solutions as well as applications of suitable research frameworks to guide blockchain research and development.				Excluded	Excluded	new_screen			2						
193	Behave	Introducing continuous experimentation in large software-intensive product and service organisations	Software development in highly dynamic environments imposes high risks to development organizations. One such risk is that the developed software may be of only little or no value to customers, wasting the invested development efforts. Continuous experimentation, as an experiment-driven development approach, may reduce such development risks by iteratively testing product and service assumptions that are critical to the success of the software. Although several experiment-driven development approaches are available, there is little guidance available on how to introduce continuous experimentation into an organization. This article presents a multiple-case study that aims at better understanding the process of introducing continuous experimentation into an organization with an already established development process. The results from the study show that companies are open to adopting such an approach and learning throughout the introduction process. Several benefits were obtained, such as reduced development efforts, deeper customer insights, and better support for development decisions. Challenges included complex stakeholder structures, difficulties in defining success criteria, and building experimentation skills. Our findings indicate that organizational factors may limit the benefits of experimentation. Moreover, introducing continuous experimentation requires fundamental changes in how companies operate, and a systematic introduction process can increase the chances of a successful start.	Continuous experimentation, Experiment-driven software development, Product management, Agile software development, Lean software development, Lean startup	Yaman, Sezin Gizem; Munezero, Myriam; Münch, Jürgen; Fagerholm, Fabian; Syd, Ossi; Aaltola, Mika; Palmu, Christina; Männistö, Tomi	Journal of Systems and Software	Software development in highly dynamic environments imposes high risks to development organizations. One such risk is that the developed software may be of only little or no value to customers, wasting the invested development efforts. Continuous experimentation, as an experiment-driven development approach, may reduce such development risks by iteratively testing product and service assumptions that are critical to the success of the software. Although several experiment-driven development approaches are available, there is little guidance available on how to introduce continuous experimentation into an organization. This article presents a multiple-case study that aims at better understanding the process of introducing continuous experimentation into an organization with an already established development process. The results from the study show that companies are open to adopting such an approach and learning throughout the introduction process. Several benefits were obtained, such as reduced development efforts, deeper customer insights, and better support for development decisions. Challenges included complex stakeholder structures, difficulties in defining success criteria, and building experimentation skills. Our findings indicate that organizational factors may limit the benefits of experimentation. Moreover, introducing continuous experimentation requires fundamental changes in how companies operate, and a systematic introduction process can increase the chances of a successful start.				Excluded	Excluded	new_screen			2						
194	Behave	Investigating Agile Practices in Software Startups	Software development practices have smoothly shifted from traditional software development to new approaches that fit better to the real and unpredictable world. Agile practices might help practitioners respond quickly to customer change requests and deliver a working software on-schedule. Software startups are companies that develop innovative and software-intensive products and services in a dynamic and fast-growing market. This study aims to investigate the use of agile practices in software startups. We conducted 14 in-depth semi-structured interviews with the CEO and CTO from early-stage software startups. The results indicate that DevOps, Fundamentals, Design and Extreme Programming are the most used agile practice areas. Our results open up an opportunity to improve software engineering practices in early-stage software startups.	Software engineering; Agile practices; Interview; Software startups	Souza, Renata; Rocha, Larissa; Silva, Franklin; Machado, Ivan	Proceedings of the XXXIII Brazilian Symposium on Software Engineering	Software development practices have smoothly shifted from traditional software development to new approaches that fit better to the real and unpredictable world. Agile practices might help practitioners respond quickly to customer change requests and deliver a working software on-schedule. Software startups are companies that develop innovative and software-intensive products and services in a dynamic and fast-growing market. This study aims to investigate the use of agile practices in software startups. We conducted 14 in-depth semi-structured interviews with the CEO and CTO from early-stage software startups. The results indicate that DevOps, Fundamentals, Design and Extreme Programming are the most used agile practice areas. Our results open up an opportunity to improve software engineering practices in early-stage software startups.				Excluded	Excluded	new_screen			2						
195	Behave	Behavior-Driven Development: A Case Study on Its Impacts on Agile Development Teams	Software development practices which enhance software quality and help teams better develop collaboratively have received attention by the academic community. Among these techniques is Behavior-Driven Development (BDD), a development method which proposes software to be developed focusing primarily on its expected behavior. In this context, this paper investigates how BDD impacts agile software development teams. In order to achieve this, we have conducted a case study on a mobile application development environment which develops software using agile. In total, 42 interviews were performed. Our results indicate that BDD can have positive impacts, increasing collaboration among team members, and negative impacts, like difficulties in writing unit tests. We concluded that BDD has more positive than negative outcomes.	Behavior-Driven Development; Agile Development; Challenge Based Learning; Software Engineering	Nascimento, Nicolas; Santos, Alan R.; Sales, Afonso; Chanin, Rafael	Proceedings of the IEEE/ACM 42nd International Conference on Software Engineering Workshops	Software development practices which enhance software quality and help teams better develop collaboratively have received attention by the academic community. Among these techniques is Behavior-Driven Development (BDD), a development method which proposes software to be developed focusing primarily on its expected behavior. In this context, this paper investigates how BDD impacts agile software development teams. In order to achieve this, we have conducted a case study on a mobile application development environment which develops software using agile. In total, 42 interviews were performed. Our results indicate that BDD can have positive impacts, increasing collaboration among team members, and negative impacts, like difficulties in writing unit tests. We concluded that BDD has more positive than negative outcomes.				Included	Included	new_screen			2						
196	Behave	Using grounded theory to understand software process improvement: A study of Irish software product companies	Software process improvement (SPI) aims to understand the software process as it is used within an organisation and thus drive the implementation of changes to that process to achieve specific goals such as increasing development speed, achieving higher product quality or reducing costs. Accordingly, SPI researchers must be equipped with the methodologies and tools to enable them to look within organisations and understand the state of practice with respect to software process and process improvement initiatives, in addition to investigating the relevant literature. Having examined a number of potentially suitable research methodologies, we have chosen Grounded Theory as a suitable approach to determine what was happening in actual practice in relation to software process and SPI, using the indigenous Irish software product industry as a test-bed. The outcome of this study is a theory, grounded in the field data, that explains when and why SPI is undertaken by the software industry. The objective of this paper is to describe both the selection and usage of grounded theory in this study and evaluate its effectiveness as a research methodology for software process researchers. Accordingly, this paper will focus on the selection and usage of grounded theory, rather than results of the SPI study itself.	Software engineering, Software process improvement, Qualitative research methods, Grounded theory	Coleman, Gerry; O’Connor, Rory	Information and Software Technology	Software process improvement (SPI) aims to understand the software process as it is used within an organisation and thus drive the implementation of changes to that process to achieve specific goals such as increasing development speed, achieving higher product quality or reducing costs. Accordingly, SPI researchers must be equipped with the methodologies and tools to enable them to look within organisations and understand the state of practice with respect to software process and process improvement initiatives, in addition to investigating the relevant literature. Having examined a number of potentially suitable research methodologies, we have chosen Grounded Theory as a suitable approach to determine what was happening in actual practice in relation to software process and SPI, using the indigenous Irish software product industry as a test-bed. The outcome of this study is a theory, grounded in the field data, that explains when and why SPI is undertaken by the software industry. The objective of this paper is to describe both the selection and usage of grounded theory in this study and evaluate its effectiveness as a research methodology for software process researchers. Accordingly, this paper will focus on the selection and usage of grounded theory, rather than results of the SPI study itself.				Excluded	Excluded	new_screen			2						
197	Behave	Using Spring Roo for the Test-Driven Development of Web Applications	Software should be developed in a way that achieves high external and internal quality. Most programs have to be maintained or are extended. They should not only adhere to their requirements but allow to be efficiently changed. Model-driven software development (MDSD) and test-driven development (TDD) are techniques that help to satisfy this demand. We present a novel approach combining MDSD and TDD while using the Spring Roo Web development framework. Besides discussing existing work and the background, we sketch a test-driven Web development process. We then evaluate its feasibility in an exemplary scenario. Thereby, we contribute to the body of scientific knowledge on Web development frameworks in the field of MDSD and TDD.	test-driven development; TDD; spring; spring roo; web application; web development	Majchrzak, Tim A.; Simon, Andreas	Proceedings of the 27th Annual ACM Symposium on Applied Computing	Software should be developed in a way that achieves high external and internal quality. Most programs have to be maintained or are extended. They should not only adhere to their requirements but allow to be efficiently changed. Model-driven software development (MDSD) and test-driven development (TDD) are techniques that help to satisfy this demand. We present a novel approach combining MDSD and TDD while using the Spring Roo Web development framework. Besides discussing existing work and the background, we sketch a test-driven Web development process. We then evaluate its feasibility in an exemplary scenario. Thereby, we contribute to the body of scientific knowledge on Web development frameworks in the field of MDSD and TDD.				Excluded	Excluded	new_screen			2						
198	Behave	A Survey of Software Testing Practices in Canada	Software testing is an important activity in the software development life-cycle. In an earlier study in 2009, we reported the results of a regional survey of software testing practices among practitioners in the Canadian province of Alberta. To get a larger nationwide view on this topic (across Canada), we conducted a newer survey with a revised list of questions in 2010. Compared to our previous Alberta-wide survey (53 software practitioners), the nation-wide survey had larger number of participants (246 practitioners). We report the survey design, execution and results in this article. The survey results reveal important and interesting findings about software testing practices in Canada. Whenever possible, we also compare the results of this survey to other similar studies, such as the ones conducted in the US, Sweden and Australia, and also two previous Alberta-wide surveys, including our 2009 survey. The results of our survey will be of interest to testing professionals both in Canada and world-wide. It will also benefit researchers in observing the latest trends in software testing industry identifying the areas of strength and weakness, which would then hopefully encourage further industry-academia collaborations in this area. Among the findings are the followings: (1) the importance of testing-related training is increasing, (2) functional and unit testing are two common test types that receive the most attention and efforts spent on them, (3) usage of the mutation testing approach is getting attention among Canadian firms, (4) traditional Test-last Development (TLD) style is still dominating and a few companies are attempting the new development approaches such as Test-Driven Development (TDD), and Behavior-Driven Development (BDD), (5) in terms of the most popular test tools, NUnit and Web application testing tools overtook JUnit and IBM Rational tools, (6) most Canadian companies use a combination of two coverage metrics: decision (branch) and condition coverage, (7) number of passing user acceptance tests and number of defects found per day (week or month) are regarded as the most important quality assurance metrics and decision factors to release, (8) in most Canadian companies, testers are out-numbered by developers, with ratios ranging from 1:2 to 1:5, (9) the majority of Canadian firms spent less than 40% of their efforts (budget and time) on testing during development, and (10) more than 70% of respondents participated in online discussion forums related to testing on a regular basis.	Software testing; Survey; Canada; Industry practices	Garousi, Vahid; Zhi, Junji	J. Syst. Softw.	Software testing is an important activity in the software development life-cycle. In an earlier study in 2009, we reported the results of a regional survey of software testing practices among practitioners in the Canadian province of Alberta. To get a larger nationwide view on this topic (across Canada), we conducted a newer survey with a revised list of questions in 2010. Compared to our previous Alberta-wide survey (53 software practitioners), the nation-wide survey had larger number of participants (246 practitioners). We report the survey design, execution and results in this article. The survey results reveal important and interesting findings about software testing practices in Canada. Whenever possible, we also compare the results of this survey to other similar studies, such as the ones conducted in the US, Sweden and Australia, and also two previous Alberta-wide surveys, including our 2009 survey. The results of our survey will be of interest to testing professionals both in Canada and world-wide. It will also benefit researchers in observing the latest trends in software testing industry identifying the areas of strength and weakness, which would then hopefully encourage further industry-academia collaborations in this area. Among the findings are the followings: (1) the importance of testing-related training is increasing, (2) functional and unit testing are two common test types that receive the most attention and efforts spent on them, (3) usage of the mutation testing approach is getting attention among Canadian firms, (4) traditional Test-last Development (TLD) style is still dominating and a few companies are attempting the new development approaches such as Test-Driven Development (TDD), and Behavior-Driven Development (BDD), (5) in terms of the most popular test tools, NUnit and Web application testing tools overtook JUnit and IBM Rational tools, (6) most Canadian companies use a combination of two coverage metrics: decision (branch) and condition coverage, (7) number of passing user acceptance tests and number of defects found per day (week or month) are regarded as the most important quality assurance metrics and decision factors to release, (8) in most Canadian companies, testers are out-numbered by developers, with ratios ranging from 1:2 to 1:5, (9) the majority of Canadian firms spent less than 40% of their efforts (budget and time) on testing during development, and (10) more than 70% of respondents participated in online discussion forums related to testing on a regular basis.				Excluded	Excluded	new_screen			2						
199	Behave	Software Testing: High-Impact Strategies - What You Need to Know Definitions, Adoptions, Impact, Benefits, Maturity, Vendors	Software testing is an investigation conducted to provide stakeholders with information about the quality of the product or service under test. Software testing also provides an objective, independent view of the software to allow the business to appreciate and understand the risks of software implementation. Test techniques include, but are not limited to, the process of executing a program or application with the intent of finding software bugs (errors or other defects). This book is your ultimate resource for Software Testing. Here you will find the most up-to-date information, analysis, background and everything you need to know. In easy to read chapters, with extensive references and links to get you to know all there is to know about Software Testing right away, covering: Software testing, Acceptance testing, Ad hoc testing, Agile testing, All-pairs testing, American Software Testing Qualifications Board, Api Sanity Autotest, Association for Software Testing, Attack patterns, Augmented Reality-based testing, Australian and New Zealand Testing Board, Automated Testing Framework, Avalanche (dynamic analysis tool), Bebugging, Behavior Driven Development, Black-box testing, Block design, Boundary case, Boundary testing, Boundary-value analysis, Browser speed test, Bs 7925-1, Bs 7925-2, Bug bash, Build verification test, Ca/Eztest, Cause-effect graph, Centercode, Characterization test, Cloud testing, Code coverage, Code integrity, Codenomicon, Compatibility testing, Component-Based Usability Testing, Conference Room Pilot, Conformance testing, Core Security, Corner case, Daikon (system), Data-driven testing, Decision table, Decision-to-decision path, Design predicates, Development, testing, acceptance and production, DeviceAnywhere, Dry run (testing), Dynamic program analysis, Dynamic testing, Edge case, Endeavour Software Project Management,		Roebuck, Kevin		Software testing is an investigation conducted to provide stakeholders with information about the quality of the product or service under test. Software testing also provides an objective, independent view of the software to allow the business to appreciate and understand the risks of software implementation. Test techniques include, but are not limited to, the process of executing a program or application with the intent of finding software bugs (errors or other defects). This book is your ultimate resource for Software Testing. Here you will find the most up-to-date information, analysis, background and everything you need to know. In easy to read chapters, with extensive references and links to get you to know all there is to know about Software Testing right away, covering: Software testing, Acceptance testing, Ad hoc testing, Agile testing, All-pairs testing, American Software Testing Qualifications Board, Api Sanity Autotest, Association for Software Testing, Attack patterns, Augmented Reality-based testing, Australian and New Zealand Testing Board, Automated Testing Framework, Avalanche (dynamic analysis tool), Bebugging, Behavior Driven Development, Black-box testing, Block design, Boundary case, Boundary testing, Boundary-value analysis, Browser speed test, Bs 7925-1, Bs 7925-2, Bug bash, Build verification test, Ca/Eztest, Cause-effect graph, Centercode, Characterization test, Cloud testing, Code coverage, Code integrity, Codenomicon, Compatibility testing, Component-Based Usability Testing, Conference Room Pilot, Conformance testing, Core Security, Corner case, Daikon (system), Data-driven testing, Decision table, Decision-to-decision path, Design predicates, Development, testing, acceptance and production, DeviceAnywhere, Dry run (testing), Dynamic program analysis, Dynamic testing, Edge case, Endeavour Software Project Management,				Excluded	Excluded	new_screen			2						
200	Behave	The implementation of ATDD and BDD from Testing Perspectives	Software testing is one of the stages in software development that aims to ensure that the software is built to meet the specifications. Selection of selective test cases has a great chance of finding failure. Black box testing approach is done based on the requirement specification where this approach does not pay attention to the program code but the specification of a software. This approach can be used for testing a software using ATDD (Acceptance Test Driven Development) and BDD (Behavior Driven Development) methods. ATDD is a method of building a software created based on agile principle, acceptance test created by customer, developer and tester. BDD is a growing agile development approach in recent years. Behavior Driven Development (BDD) is built on Test-Driven Development (TDD). This Final Project focuses on the application of ATDD and BDD methods to testing the final three projects of IT Del students tested using the Roboy Framework and Cucumber Framework to find out whether these two methods are effective and be able to improve the software development process. The results obtained are that the application of ATDD and BDD methods are effective and helping to remove the error as soon as possible. © Published under licence by IOP Publishing Ltd.		Christy Barus A.	Journal of Physics: Conference Series	Software testing is one of the stages in software development that aims to ensure that the software is built to meet the specifications. Selection of selective test cases has a great chance of finding failure. Black box testing approach is done based on the requirement specification where this approach does not pay attention to the program code but the specification of a software. This approach can be used for testing a software using ATDD (Acceptance Test Driven Development) and BDD (Behavior Driven Development) methods. ATDD is a method of building a software created based on agile principle, acceptance test created by customer, developer and tester. BDD is a growing agile development approach in recent years. Behavior Driven Development (BDD) is built on Test-Driven Development (TDD). This Final Project focuses on the application of ATDD and BDD methods to testing the final three projects of IT Del students tested using the Roboy Framework and Cucumber Framework to find out whether these two methods are effective and be able to improve the software development process. The results obtained are that the application of ATDD and BDD methods are effective and helping to remove the error as soon as possible. © Published under licence by IOP Publishing Ltd.				Included	Included	new_screen			2						
201	Behave	Impacts of behavioral driven development in the improvement of quality software deliverables	Sometimes, the software deliverables do not exactly match with the requirements. This mismatch requirement can be captured during the testing. Even then if it is missing it is because of non-coverage of the testing and test cases. This could be resolved by creating the unit test cases / Integration test cases from the requirements. This paper focuses on BDD requirements which generates the test cases as well as report executed. With aid of automation testing, the test cases of BDD can be explained. This paper deals with such test cases, the next version binaries to get the proper deliverables.	BDD - Behavior Driven Development;TDD – Test Driven Development;QA – Quality Assurance;BD – Behavior Driven	A. Sheshasaayee; P. Banumathi	2018 3rd International Conference on Inventive Computation Technologies (ICICT)	Sometimes, the software deliverables do not exactly match with the requirements. This mismatch requirement can be captured during the testing. Even then if it is missing it is because of non-coverage of the testing and test cases. This could be resolved by creating the unit test cases / Integration test cases from the requirements. This paper focuses on BDD requirements which generates the test cases as well as report executed. With aid of automation testing, the test cases of BDD can be explained. This paper deals with such test cases, the next version binaries to get the proper deliverables.				Excluded	Excluded	new_screen			2						
202	Behave	A Natural Language Driven Approach for Automated Web API Development: Gherkin2OAS	"Speeding up the development process of Web Services, while adhering to high quality software standards is a typical requirement in the software industry. This is why industry specialists usually suggest ""driven by"" development approaches to tackle this problem. In this paper, we propose such a methodology that employs Specification Driven Development and Behavior Driven Development in order to facilitate the phases of Web Service requirements elicitation and specification. Furthermore, we introduce gherkin2OAS, a software tool that aspires to bridge the aforementioned development approaches. Through the suggested methodology and tool, one may design and build RESTful services fast, while ensuring proper functionality."	behavior driven development; gherkin; open API specification; restful API	Dimanidis, Anastasios; Chatzidimitriou, Kyriakos C.; Symeonidis, Andreas L.	Companion Proceedings of the The Web Conference 2018	"Speeding up the development process of Web Services, while adhering to high quality software standards is a typical requirement in the software industry. This is why industry specialists usually suggest ""driven by"" development approaches to tackle this problem. In this paper, we propose such a methodology that employs Specification Driven Development and Behavior Driven Development in order to facilitate the phases of Web Service requirements elicitation and specification. Furthermore, we introduce gherkin2OAS, a software tool that aspires to bridge the aforementioned development approaches. Through the suggested methodology and tool, one may design and build RESTful services fast, while ensuring proper functionality."				Included	Included	new_screen			2						
203	Behave	Sismic—A Python library for statechart execution and testing	Statecharts are a well-known visual modelling language for representing the executable behaviour of complex reactive event-based systems. The essential complexity of statechart models solicits the need for advanced model testing and validation techniques, such as test-driven development, behaviour-driven development, design by contract, and property statecharts for monitoring of violations of behavioural properties during statechart execution. Sismic is an open-source Python library providing a tool suite to define, simulate, execute and test statecharts with all of the aforementioned techniques.	Statechart, Executable modelling, Behaviour-driven development, Design by contract, Runtime verification	Decan, Alexandre; Mens, Tom	SoftwareX	Statecharts are a well-known visual modelling language for representing the executable behaviour of complex reactive event-based systems. The essential complexity of statechart models solicits the need for advanced model testing and validation techniques, such as test-driven development, behaviour-driven development, design by contract, and property statecharts for monitoring of violations of behavioural properties during statechart execution. Sismic is an open-source Python library providing a tool suite to define, simulate, execute and test statecharts with all of the aforementioned techniques.				Excluded	Excluded	new_screen			2						
204	Behave	A Method for Testing and Validating Executable Statechart Models	Statecharts constitute an executable language for modelling event-based reactive systems. The essential complexity of statechart models solicits the need for advanced model testing and validation techniques. In this article, we propose a method aimed at enhancing statechart design with a range of techniques that have proven their usefulness to increase the quality and reliability of source code. The method is accompanied by a process that flexibly accommodates testing and validation techniques such as test-driven development, behaviour-driven development, design by contract, and property statecharts that check for violations of behavioural properties during statechart execution. The method is supported by the Sismic tool, an open-source statechart interpreter library in Python, which supports all the aforementioned techniques. Based on this tooling, we carry out a controlled user study to evaluate the feasibility, usefulness and adequacy of the proposed techniques for statechart testing and validation.	Behaviour-driven development; Design by contract; Runtime verification; Statechart; Executable modeling	Mens, Tom; Decan, Alexandre; Spanoudakis, Nikolaos I.	Softw. Syst. Model.	Statecharts constitute an executable language for modelling event-based reactive systems. The essential complexity of statechart models solicits the need for advanced model testing and validation techniques. In this article, we propose a method aimed at enhancing statechart design with a range of techniques that have proven their usefulness to increase the quality and reliability of source code. The method is accompanied by a process that flexibly accommodates testing and validation techniques such as test-driven development, behaviour-driven development, design by contract, and property statecharts that check for violations of behavioural properties during statechart execution. The method is supported by the Sismic tool, an open-source statechart interpreter library in Python, which supports all the aforementioned techniques. Based on this tooling, we carry out a controlled user study to evaluate the feasibility, usefulness and adequacy of the proposed techniques for statechart testing and validation.				Excluded	Excluded	new_screen			2						
205	Behave	A method for testing and validating executable statechart models	Statecharts constitute an executable language for modelling event-based reactive systems. The essential complexity of statechart models solicits the need for advanced model testing and validation techniques. In this article, we propose a method aimed at enhancing statechart design with a range of techniques that have proven their usefulness to increase the quality and reliability of source code. The method is accompanied by a process that flexibly accommodates testing and validation techniques such as test-driven development, behaviour-driven development, design by contract, and property statecharts that check for violations of behavioural properties during statechart execution. The method is supported by the Sismic tool, an open-source statechart interpreter library in Python, which supports all the aforementioned techniques. Based on this tooling, we carry out a controlled user study to evaluate the feasibility, usefulness and adequacy of the proposed techniques for statechart testing and validation. © 2018, Springer-Verlag GmbH Germany, part of Springer Nature.		Mens T., Decan A., Spanoudakis N.I.	Software and Systems Modeling	Statecharts constitute an executable language for modelling event-based reactive systems. The essential complexity of statechart models solicits the need for advanced model testing and validation techniques. In this article, we propose a method aimed at enhancing statechart design with a range of techniques that have proven their usefulness to increase the quality and reliability of source code. The method is accompanied by a process that flexibly accommodates testing and validation techniques such as test-driven development, behaviour-driven development, design by contract, and property statecharts that check for violations of behavioural properties during statechart execution. The method is supported by the Sismic tool, an open-source statechart interpreter library in Python, which supports all the aforementioned techniques. Based on this tooling, we carry out a controlled user study to evaluate the feasibility, usefulness and adequacy of the proposed techniques for statechart testing and validation. © 2018, Springer-Verlag GmbH Germany, part of Springer Nature.				Included	Included	new_screen			2						
206	Behave	Rails 3 in Action	Summary Rails 3 in Action is a collaboration between Rails community leaders, Ryan Bigg and Yehuda Katz, that covers Rails 3.1 making it the most up-to-date resource available. But it's much more than just a Rails 3 reference book. You'll learn to do Rails the right way, so you can build stable, scalable, and maintainable apps that will satisfy even the most demanding clients. About the BookRails 3 is a full stack, open source web framework powered by Ruby and this book is an introduction to it. Whether you're just starting or you have a few cycles under your belt, you'll appreciate the book's guru's-eye-view of idiomatic Rails programming.You'll master Rails 3.1 by developing a ticket tracking application that includes RESTful routing, authentication and authorization, state maintenance, file uploads, email, and more. You'll also explore powerful features like designing your own APIs and building a Rails engine. You will see Test Driven Development and Behavior Driven Development in action throughout the book, just like you would in a top Rails shop.It is helpful for readers to have a background in Ruby, but no prior Rails experience is needed. What's InsideCovers Rails 3.1 from the ground up Testing and BDD using RSpec and Cucumber Working with Rack=============================================== Table of ContentsRuby on Rails, the framework Testing saves your bacon Developing a real Rails application Oh CRUD! Nested resources Authentication and basic authorization Basic access control More authorization File uploading Tracking state Tagging Sending email Designing an API Deployment Alternative authentication Basic performance enhancements Engines Rack-based applications		Bigg, Ryan; Katz, Yehuda		Summary Rails 3 in Action is a collaboration between Rails community leaders, Ryan Bigg and Yehuda Katz, that covers Rails 3.1 making it the most up-to-date resource available. But it's much more than just a Rails 3 reference book. You'll learn to do Rails the right way, so you can build stable, scalable, and maintainable apps that will satisfy even the most demanding clients. About the BookRails 3 is a full stack, open source web framework powered by Ruby and this book is an introduction to it. Whether you're just starting or you have a few cycles under your belt, you'll appreciate the book's guru's-eye-view of idiomatic Rails programming.You'll master Rails 3.1 by developing a ticket tracking application that includes RESTful routing, authentication and authorization, state maintenance, file uploads, email, and more. You'll also explore powerful features like designing your own APIs and building a Rails engine. You will see Test Driven Development and Behavior Driven Development in action throughout the book, just like you would in a top Rails shop.It is helpful for readers to have a background in Ruby, but no prior Rails experience is needed. What's InsideCovers Rails 3.1 from the ground up Testing and BDD using RSpec and Cucumber Working with Rack=============================================== Table of ContentsRuby on Rails, the framework Testing saves your bacon Developing a real Rails application Oh CRUD! Nested resources Authentication and basic authorization Basic access control More authorization File uploading Tracking state Tagging Sending email Designing an API Deployment Alternative authentication Basic performance enhancements Engines Rack-based applications				Excluded	Excluded	new_screen			2						
207	Behave	BeSoS: A Tool for Behavior-driven and Scenario-based Requirements Modeling for Systems of Systems	Systems of Systems (SoS), like connected vehicle systems, provide their functionality by the interaction of several constituent systems (CSs). [Problem] Due to the managerial, operational and evolutionary independence of the CSs in an SoS, requirements constantly change over time and linear, top-down requirements engineering methods cannot be applied without significant adaptations. New tools are needed that support the continuous and iterative specification and alignment of requirements across different levels of abstraction. [Principal Ideas] We propose to integrate the behavior-driven development (BDD) approach with an intuitive and executable scenario-based modeling of functional requirements. In this way, stakeholder expectations can be structured via features and documented in natural language as usage scenarios. Based on usage scenarios, the modeling of functional requirements can be driven by tests, allowing for the automated testing and analysis of requirements. This in turn supports the iterative specification of requirements and the alignment of stakeholder needs. [Contribution] In this paper we showcase the tool BeSoS that supports the iterative and behavior-driven specification of requirements in an SoS context. We propose a method and describe its tool components using an example. The tool is available here: https://vimeo.com/512739942. © 2021 CEUR-WS. All rights reserved.		Wiecher C., Greenyer J.	CEUR Workshop Proceedings	Systems of Systems (SoS), like connected vehicle systems, provide their functionality by the interaction of several constituent systems (CSs). [Problem] Due to the managerial, operational and evolutionary independence of the CSs in an SoS, requirements constantly change over time and linear, top-down requirements engineering methods cannot be applied without significant adaptations. New tools are needed that support the continuous and iterative specification and alignment of requirements across different levels of abstraction. [Principal Ideas] We propose to integrate the behavior-driven development (BDD) approach with an intuitive and executable scenario-based modeling of functional requirements. In this way, stakeholder expectations can be structured via features and documented in natural language as usage scenarios. Based on usage scenarios, the modeling of functional requirements can be driven by tests, allowing for the automated testing and analysis of requirements. This in turn supports the iterative specification of requirements and the alignment of stakeholder needs. [Contribution] In this paper we showcase the tool BeSoS that supports the iterative and behavior-driven specification of requirements in an SoS context. We propose a method and describe its tool components using an example. The tool is available here: https://vimeo.com/512739942. © 2021 CEUR-WS. All rights reserved.				Included	Included	new_screen			2						
208	Behave	Behavior-Driven Development: An Expert Panel to Evaluate Benefits and Challenges	"Teaching modern software techniques is a challenging task as these practices tend to be collaborative and require a lot of preparation and environment setup. Among these techniques is Behavior-Driven Development (BDD), a development method which proposes software to be develop focusing primarily on its expected behavior. In this context, this paper investigates the perception of active-learning experts regarding the potential benefits and challenges of teaching BDD in active learning environments to software engineering students. To achieve this goal, we have conducted an expert panel with 28 active-learning experts from four countries. Our preliminary results indicate that experts perceive both benefits, like improvement in specification, and challenges to embrace the BDD ""culture"" when teaching BDD to software engineering students. Based in these findings, we found indicatives that BDD should benefit software engineering students in active learning environments, however it may require more setup, teacher preparation and engagement during the learning process."	Behavior-Driven Development; Agile Development; Challenge Based Learning; Software Engineering	Nascimento, Nicolas; Santos, Alan R.; Sales, Afonso; Chanin, Rafael	Proceedings of the 34th Brazilian Symposium on Software Engineering	"Teaching modern software techniques is a challenging task as these practices tend to be collaborative and require a lot of preparation and environment setup. Among these techniques is Behavior-Driven Development (BDD), a development method which proposes software to be develop focusing primarily on its expected behavior. In this context, this paper investigates the perception of active-learning experts regarding the potential benefits and challenges of teaching BDD in active learning environments to software engineering students. To achieve this goal, we have conducted an expert panel with 28 active-learning experts from four countries. Our preliminary results indicate that experts perceive both benefits, like improvement in specification, and challenges to embrace the BDD ""culture"" when teaching BDD to software engineering students. Based in these findings, we found indicatives that BDD should benefit software engineering students in active learning environments, however it may require more setup, teacher preparation and engagement during the learning process."				Included	Included	new_screen			2						
209	Behave	Testing Meets Static and Runtime Verification	Test driven development (TDD) is a technique where test cases are used to guide the development of a system. This technique introduces several advantages at the time of developing a system, e.g. writing clean code, good coverage for the features of the system, and evolutionary development. In this paper we show how the capabilities of a testing focused development methodology based on TDD and model-based testing, can be enhanced by integrating static and runtime verification into its workflow. Considering that the desired system properties capture data- as well as control-oriented aspects, we integrate TDD with (static) deductive verification as an aid in the development of the data-oriented aspects, and we integrate model-based testing with runtime verification as an aid in the development of the control-oriented aspects. As a result of this integration, the proposed development methodology features the benefits of TDD and model-based testing, enhanced with, for instance, early detection of bugs which may be missed by TDD, regarding data aspects, and the validation of the overall system with respect to the model, regarding the control aspects.	runtime verification; Java; static verification; test driven development	Chimento, Jesús Mauricio; Ahrendt, Wolfgang; Schneider, Gerardo	Proceedings of the 6th Conference on Formal Methods in Software Engineering	Test driven development (TDD) is a technique where test cases are used to guide the development of a system. This technique introduces several advantages at the time of developing a system, e.g. writing clean code, good coverage for the features of the system, and evolutionary development. In this paper we show how the capabilities of a testing focused development methodology based on TDD and model-based testing, can be enhanced by integrating static and runtime verification into its workflow. Considering that the desired system properties capture data- as well as control-oriented aspects, we integrate TDD with (static) deductive verification as an aid in the development of the data-oriented aspects, and we integrate model-based testing with runtime verification as an aid in the development of the control-oriented aspects. As a result of this integration, the proposed development methodology features the benefits of TDD and model-based testing, enhanced with, for instance, early detection of bugs which may be missed by TDD, regarding data aspects, and the validation of the overall system with respect to the model, regarding the control aspects.				Excluded	Excluded	new_screen			2						
210	Behave	Jasmine JavaScript Testing Update	Test your JavaScript applications efficiently using Jasmine and React.js About This BookLeverage the power of unit testing React.js to develop full-fledged JavaScript applicationsLearn the best practices of modularization and code organization while scaling your applicationEnhance your practical skills required to develop applications using the Jasmine framework in a step-by-step mannerWho This Book Is ForThis book is for web developers and designers who work with React.js and JavaScript and who are new to unit testing and automation. It's assumed that you have a basic knowledge of JavaScript and HTML. In Detail Take your testing of JavaScript applications to a new level of efficiency and reliability with the help of this book. Starting with the fundamentals of Jasmine and behavior-driven development (BDD), you will learn about tooling and automation. You will learn how to create a sustainable code base with the help of Jasmine. You will also take a look at integrated testing with React.js and Karma, and how you can speed this process up by faking AJAX requests. As you progress through the book, you will learn about the challenges of testing an application built on top of a framework and how you can prevent your application from suffering from dependency management. You will understand the concept of client-side and server-side rendering and test applications using React.js. You will also learn to automate using webpack and work with JavaScript module systems using ECMA Script 6 (ES6) modules.By the end of this book, you will be a competent web developer with good knowledge and a strong understanding of how to efficiently use the Jasmine framework for testing purposes.		Ragonha, Paulo		Test your JavaScript applications efficiently using Jasmine and React.js About This BookLeverage the power of unit testing React.js to develop full-fledged JavaScript applicationsLearn the best practices of modularization and code organization while scaling your applicationEnhance your practical skills required to develop applications using the Jasmine framework in a step-by-step mannerWho This Book Is ForThis book is for web developers and designers who work with React.js and JavaScript and who are new to unit testing and automation. It's assumed that you have a basic knowledge of JavaScript and HTML. In Detail Take your testing of JavaScript applications to a new level of efficiency and reliability with the help of this book. Starting with the fundamentals of Jasmine and behavior-driven development (BDD), you will learn about tooling and automation. You will learn how to create a sustainable code base with the help of Jasmine. You will also take a look at integrated testing with React.js and Karma, and how you can speed this process up by faking AJAX requests. As you progress through the book, you will learn about the challenges of testing an application built on top of a framework and how you can prevent your application from suffering from dependency management. You will understand the concept of client-side and server-side rendering and test applications using React.js. You will also learn to automate using webpack and work with JavaScript module systems using ECMA Script 6 (ES6) modules.By the end of this book, you will be a competent web developer with good knowledge and a strong understanding of how to efficiently use the Jasmine framework for testing purposes.				Excluded	Excluded	new_screen			2						
211	Behave	TestBox: Behavior Driven Development	TestBox is a testing framework for ColdFusion (CFML) that is based on BDD (Behavior Driven Development) for providing a clean obvious syntax for writing tests. It also includes MockBox for mocking and stubbing.		Majano, Luis Fernando; Reyes, Jorge Emilio		TestBox is a testing framework for ColdFusion (CFML) that is based on BDD (Behavior Driven Development) for providing a clean obvious syntax for writing tests. It also includes MockBox for mocking and stubbing.				Excluded	Excluded	new_screen			2						
212	Behave	Assessing Agile Testing Practices for Enterprise Systems: A Survey Approach	"Testing enterprise systems is a challenging task. In this context, besides considering user requirements and business rules, there are several concerns that must also be considered when designing a test suite, including user interaction, integration with legacy systems, and access to relational or non-relational databases. In addition, test engineers often have to decide whether to test in the different levels (e.g., unit, integration, and system testing) or not, whether to use mock objects or not, and so on. Sadly, these decisions often conflict to each other. In this paper, we report an 18-month experience on using different approaches and tools to test two enterprise systems (SISBOL and SISDOT) from the Brazilian Army. SISBOL is an enterprise system based on the REST architectural style, using JEE (Java Enterprise Edition) in the business and integration tiers and AngularJS in the presentation tier. On the other hand, SISDOT is a ""pure"" Java enterprise system, using Java Server Faces on the presentation tier. We found that using executable specifications (as recommended in approaches based on Behavior Driven Development) is not only valid in test first scenarios as well as giving confidence on the system requirements validation, but they also help to identify new execution paths when the source code had been already implemented—suggesting that it is also promising to introduce a BDD approach in later stages of the development than testing pure JEE systems at the integration level."	Software Testing; Test Driven Development; Behavior Driven Development; Specification by Example	Fazzolino, Rafael; de Faria, Henrique Medrado; Amaral, Luis Henrique Vieira; Canedo, Edna Dias; Rodrigues, Genaína Nunes; Bonifácio, Rodrigo	Proceedings of the III Brazilian Symposium on Systematic and Automated Software Testing	"Testing enterprise systems is a challenging task. In this context, besides considering user requirements and business rules, there are several concerns that must also be considered when designing a test suite, including user interaction, integration with legacy systems, and access to relational or non-relational databases. In addition, test engineers often have to decide whether to test in the different levels (e.g., unit, integration, and system testing) or not, whether to use mock objects or not, and so on. Sadly, these decisions often conflict to each other. In this paper, we report an 18-month experience on using different approaches and tools to test two enterprise systems (SISBOL and SISDOT) from the Brazilian Army. SISBOL is an enterprise system based on the REST architectural style, using JEE (Java Enterprise Edition) in the business and integration tiers and AngularJS in the presentation tier. On the other hand, SISDOT is a ""pure"" Java enterprise system, using Java Server Faces on the presentation tier. We found that using executable specifications (as recommended in approaches based on Behavior Driven Development) is not only valid in test first scenarios as well as giving confidence on the system requirements validation, but they also help to identify new execution paths when the source code had been already implemented—suggesting that it is also promising to introduce a BDD approach in later stages of the development than testing pure JEE systems at the integration level."				Included	Included	new_screen			2						
213	Behave	Distributed agile: Component-based user acceptance testing	Testing is conducted at multiple levels during the development of software. User Acceptance Testing conforms that the software meets user's criteria. In this paper, User Acceptance Testing is automatically conducted based on acceptance criteria. The acceptance criteria are written in the form of Given-When-Then Template. These acceptance criteria are broken down into steps and numbered. The dependencies among the steps are determined as Given->When->Then. Henceforth, the steps are arranged in a dependency graph. This graph further leads to the creation of a decision table in which the outcome of one step leads to the outcomes of its dependent steps. The decision table forms the basis of generation of a binary weighted dependency tree. This tree becomes the means to form test coverage (number of combinations to test) which forms the basis of generation of acceptance test cases.		P. Pandit; S. Tahiliani; M. Sharma	2016 Symposium on Colossal Data Analysis and Networking (CDAN)	Testing is conducted at multiple levels during the development of software. User Acceptance Testing conforms that the software meets user's criteria. In this paper, User Acceptance Testing is automatically conducted based on acceptance criteria. The acceptance criteria are written in the form of Given-When-Then Template. These acceptance criteria are broken down into steps and numbered. The dependencies among the steps are determined as Given->When->Then. Henceforth, the steps are arranged in a dependency graph. This graph further leads to the creation of a decision table in which the outcome of one step leads to the outcomes of its dependent steps. The decision table forms the basis of generation of a binary weighted dependency tree. This tree becomes the means to form test coverage (number of combinations to test) which forms the basis of generation of acceptance test cases.				Included	Included	new_screen			2						
214	Behave	Modeling Test Cases in BPMN for Behavior-Driven Development	Testing large-scale process integration solutions is complex and cumbersome. To tackle this problem, researchers employed behavior-driven development. They used the Business Process Model and Notation language to model domain-specific test cases. These test cases can be understood by both developers and business stakeholders and can be executed automatically.		Lübke, Daniel; van Lessen, Tammo	IEEE Softw.	Testing large-scale process integration solutions is complex and cumbersome. To tackle this problem, researchers employed behavior-driven development. They used the Business Process Model and Notation language to model domain-specific test cases. These test cases can be understood by both developers and business stakeholders and can be executed automatically.				Included	Included	new_screen			2						
215	Behave	A study of value in agile software development organizations	The Agile manifesto focuses on the delivery of valuable software. In Lean, the principles emphasise value, where every activity that does not add value is seen as waste. Despite the strong focus on value, and that the primary critical success factor for software intensive product development lies in the value domain, no empirical study has investigated specifically what value is. This paper presents an empirical study that investigates how value is interpreted and prioritised, and how value is assured and measured. Data was collected through semi-structured interviews with 23 participants from 14 agile software development organisations. The contribution of this study is fourfold. First, it examines how value is perceived amongst agile software development organisations. Second, it compares the perceptions and priorities of the perceived values by domains and roles. Third, it includes an examination of what practices are used to achieve value in industry, and what hinders the achievement of value. Fourth, it characterises what measurements are used to assure, and evaluate value-creation activities.	Value, Agile software development, Empirical	Alahyari, Hiva; Berntsson Svensson, Richard; Gorschek, Tony	Journal of Systems and Software	The Agile manifesto focuses on the delivery of valuable software. In Lean, the principles emphasise value, where every activity that does not add value is seen as waste. Despite the strong focus on value, and that the primary critical success factor for software intensive product development lies in the value domain, no empirical study has investigated specifically what value is. This paper presents an empirical study that investigates how value is interpreted and prioritised, and how value is assured and measured. Data was collected through semi-structured interviews with 23 participants from 14 agile software development organisations. The contribution of this study is fourfold. First, it examines how value is perceived amongst agile software development organisations. Second, it compares the perceptions and priorities of the perceived values by domains and roles. Third, it includes an examination of what practices are used to achieve value in industry, and what hinders the achievement of value. Fourth, it characterises what measurements are used to assure, and evaluate value-creation activities.				Excluded	Excluded	new_screen			2						
216	Behave	User and System Stories: An Agile Approach for Managing Requirements in AOSE	The agile software development life cycle is widely used in industry today due to its highly flexible and iterative processes that facilitate rapid prototyping. There has been recent work in bringing concepts and processes from agile methodologies to agent-oriented software engineering (AOSE). We contribute to this effort by presenting in this paper a novel approach to capturing requirements of agent systems in AOSE using and extending agile concepts. In this paper, we propose to adopt and extend the well-known concept of User Stories to facilitate the development of agent systems. We introduce a novel concept, System Story, that defines requirements from the perspective of the system. These System Stories are refinements of User Stories and provide more intuitive mappings to agent concepts in the design and implementation. We show how our approach allows better traceability of requirements between stories and the different software development artifacts. We validate our proposal with a feature-based comparison to recent related work, and a preliminary user evaluation based on a drone simulation of a simple search and rescue case study.		Rodriguez, Sebastian; Thangarajah, John; Winikoff, Michael	Proceedings of the 20th International Conference on Autonomous Agents and MultiAgent Systems	The agile software development life cycle is widely used in industry today due to its highly flexible and iterative processes that facilitate rapid prototyping. There has been recent work in bringing concepts and processes from agile methodologies to agent-oriented software engineering (AOSE). We contribute to this effort by presenting in this paper a novel approach to capturing requirements of agent systems in AOSE using and extending agile concepts. In this paper, we propose to adopt and extend the well-known concept of User Stories to facilitate the development of agent systems. We introduce a novel concept, System Story, that defines requirements from the perspective of the system. These System Stories are refinements of User Stories and provide more intuitive mappings to agent concepts in the design and implementation. We show how our approach allows better traceability of requirements between stories and the different software development artifacts. We validate our proposal with a feature-based comparison to recent related work, and a preliminary user evaluation based on a drone simulation of a simple search and rescue case study.				Excluded	Excluded	new_screen			2						
217	Behave	The Art of Rails (Programmer to Programmer)	The Art of Rails(r) Any programmer knows that an API is only half the story, and with Ruby on Rails(r) this is especially true. Good Rails development, like good web development, is much more about the design choices you make than the framework you have at your disposal. Written by an experienced web application developer, this book picks up where the API leaves off and explains how to take good Rails code and turn it into beautiful Rails code: simple, effective, reusable, evolvable code. In a blend of design and programming, this book identifies and describes the very latest in design patterns, programming abstractions, and development methodologies that have emerged for the modern web. Ruby on Rails offers a completely new way of thinking about and using these emerging techniques, and learning to think like a Rails developer will enable you to rapidly design and write high-quality code with elegance and maintainability. With each design technique, you will discover how Rails incorporates it into its domain-specific language, and you will learn how to weave it seamlessly into your own Rails applications. Then you will learn how to take the next step and transform yourself from user into creator, making your own additions to Rails and crafting a development environment tailored to your specific needs. What you will learn from this book * Techniques for organizing your code between and within Model, View, and Controller to eliminate code repetition and maximize your effectiveness * How to think like a REST-based developer and use Rails 2.0 to translate these thoughts into your code * Advanced Ruby and meta-programming: how to use features such as block-based development, monkey patching, and dynamic APIs to build your own additions to the Rails framework * Design patterns for AJAX, web APIs, HTML decomposition, schema development, meta-programming, and more * Behavior-driven development: A new style of testing and development centered arou nd stories and behaviors instead of method calls and assertions * Ways to make your development both productive and fun in the software you write Who this book is for This book is for developers familiar with Ruby on Rails who are looking to advance their skills by learning the design and coding techniques that enable a mastery of web application development with Rails. Wrox guides are crafted to make learning programming languages and technologies easier than you think. Written by programmers for programmers, they provide a structured, tutorial format that will guide you through all the techniques involved.		Benson, Edward		The Art of Rails(r) Any programmer knows that an API is only half the story, and with Ruby on Rails(r) this is especially true. Good Rails development, like good web development, is much more about the design choices you make than the framework you have at your disposal. Written by an experienced web application developer, this book picks up where the API leaves off and explains how to take good Rails code and turn it into beautiful Rails code: simple, effective, reusable, evolvable code. In a blend of design and programming, this book identifies and describes the very latest in design patterns, programming abstractions, and development methodologies that have emerged for the modern web. Ruby on Rails offers a completely new way of thinking about and using these emerging techniques, and learning to think like a Rails developer will enable you to rapidly design and write high-quality code with elegance and maintainability. With each design technique, you will discover how Rails incorporates it into its domain-specific language, and you will learn how to weave it seamlessly into your own Rails applications. Then you will learn how to take the next step and transform yourself from user into creator, making your own additions to Rails and crafting a development environment tailored to your specific needs. What you will learn from this book * Techniques for organizing your code between and within Model, View, and Controller to eliminate code repetition and maximize your effectiveness * How to think like a REST-based developer and use Rails 2.0 to translate these thoughts into your code * Advanced Ruby and meta-programming: how to use features such as block-based development, monkey patching, and dynamic APIs to build your own additions to the Rails framework * Design patterns for AJAX, web APIs, HTML decomposition, schema development, meta-programming, and more * Behavior-driven development: A new style of testing and development centered arou nd stories and behaviors instead of method calls and assertions * Ways to make your development both productive and fun in the software you write Who this book is for This book is for developers familiar with Ruby on Rails who are looking to advance their skills by learning the design and coding techniques that enable a mastery of web application development with Rails. Wrox guides are crafted to make learning programming languages and technologies easier than you think. Written by programmers for programmers, they provide a structured, tutorial format that will guide you through all the techniques involved.				Excluded	Excluded	new_screen			2						
218	Behave	The blockchain: State-of-the-art and research challenges	The blockchain revolutionizes the creation of both scalable information technology systems and diversified applications by integrating the increasingly popular artificial intelligence, cloud computing, and big data. Various industries have recently begun to implement the exploration of blockchain. It will not take long for the blockchain to spread all over the world. In order to identify and further the development of the blockchain technology, this paper reviews the extant studies on the blockchain and its key components, blockchain-based IoT, blockchain-based security, blockchain-based data management, and the main applications based on the blockchain, and it delineates potential trends and challenges. This study provides a comprehensive overview of state-of-the-art blockchain and describes a forward-looking direction.	Blockchain, Decentralization, Smart contract, Security, Privacy	Lu, Yang	Journal of Industrial Information Integration	The blockchain revolutionizes the creation of both scalable information technology systems and diversified applications by integrating the increasingly popular artificial intelligence, cloud computing, and big data. Various industries have recently begun to implement the exploration of blockchain. It will not take long for the blockchain to spread all over the world. In order to identify and further the development of the blockchain technology, this paper reviews the extant studies on the blockchain and its key components, blockchain-based IoT, blockchain-based security, blockchain-based data management, and the main applications based on the blockchain, and it delineates potential trends and challenges. This study provides a comprehensive overview of state-of-the-art blockchain and describes a forward-looking direction.				Excluded	Excluded	new_screen			2						
219	Behave	A User‐Centered Behavioral Software Development Model	The concept of usability, which affects the quality and cost of the software projects, has become essential in recent years. There is a need to integrate usability testing activities and techniques into the development processes; however, integration is difficult. Therefore, this study proposes user‐centered behavioral (UCB) software development model, which aims to bridge the gap between human–computer interaction (HCI) and software engineering (SE) disciplines. A triangulation methodology of mixed methods is used to understand the current situation in software development companies in terms of usability and user‐centered software development by survey and interviews. Their results are then used to inform the development of the proposed model. The UCB software development model proposes a process in which several tools and techniques from SE and HCI are integrated to facilitate the production of highly usable software. In essence, the model proposes an iterative process that combines behavior‐driven development (BDD)—an agile approach that enables a better understanding and analysis of the requirements—with the style guides, usability tests, heuristic evaluation, and Wizard of Oz techniques of HCI. The model was evaluated in a pilot project and then is improved based on feedback gathered. Participants' feedback supported the effectiveness of the proposed model.The UCB software development model proposes a process in which several tools and techniques from SE and HCI are integrated to create a model that will facilitate the production of highly usable software. In essence, the model proposes an iterative process that combines behavior‐driven development (BDD)—an agile approach that enables a better understanding and analysis of the requirements—with the style guides, usability tests, heuristic evaluation, and Wizard of Oz techniques of HCI. image	software engineering; agile methodology; behavior‐driven development (BDD); human–computer interaction (HCI); user‐centered design; user‐centered software development model	Güncan, Damla; Onay Durdu, Pınar	J. Softw. Evol. Process	The concept of usability, which affects the quality and cost of the software projects, has become essential in recent years. There is a need to integrate usability testing activities and techniques into the development processes; however, integration is difficult. Therefore, this study proposes user‐centered behavioral (UCB) software development model, which aims to bridge the gap between human–computer interaction (HCI) and software engineering (SE) disciplines. A triangulation methodology of mixed methods is used to understand the current situation in software development companies in terms of usability and user‐centered software development by survey and interviews. Their results are then used to inform the development of the proposed model. The UCB software development model proposes a process in which several tools and techniques from SE and HCI are integrated to facilitate the production of highly usable software. In essence, the model proposes an iterative process that combines behavior‐driven development (BDD)—an agile approach that enables a better understanding and analysis of the requirements—with the style guides, usability tests, heuristic evaluation, and Wizard of Oz techniques of HCI. The model was evaluated in a pilot project and then is improved based on feedback gathered. Participants' feedback supported the effectiveness of the proposed model.The UCB software development model proposes a process in which several tools and techniques from SE and HCI are integrated to create a model that will facilitate the production of highly usable software. In essence, the model proposes an iterative process that combines behavior‐driven development (BDD)—an agile approach that enables a better understanding and analysis of the requirements—with the style guides, usability tests, heuristic evaluation, and Wizard of Oz techniques of HCI. image				Excluded	Excluded	new_screen			2						
220	Behave	Behavior Driven Development for circuit design and verification	The design of hardware systems is a challenging and erroneous task where about 70% of the effort in designing these systems is spent on verification. In general, testing and verification are usually tasks that are being applied as a post-process to the implementation. In this paper, we propose a new design flow based on Behavior Driven Development (BDD), an agile technique for the development of software in which acceptance tests written in natural language play a central role and are the starting point in the design flow. We advance the flow such that the specifics that arise when modeling hardware are taken into account. Furthermore, we present a technique that allows for the automatic generalization of test cases to properties that are suitable for formal verification. This allows the designer to apply formal verification techniques based on test cases without specifying properties. We implemented our approach and evaluated the flow for an illustrative example that successfully demonstrates the advantages of the proposed flow.		M. Diepenbeck; M. Soeken; D. Große; R. Drechsler	2012 IEEE International High Level Design Validation and Test Workshop (HLDVT)	The design of hardware systems is a challenging and erroneous task where about 70% of the effort in designing these systems is spent on verification. In general, testing and verification are usually tasks that are being applied as a post-process to the implementation. In this paper, we propose a new design flow based on Behavior Driven Development (BDD), an agile technique for the development of software in which acceptance tests written in natural language play a central role and are the starting point in the design flow. We advance the flow such that the specifics that arise when modeling hardware are taken into account. Furthermore, we present a technique that allows for the automatic generalization of test cases to properties that are suitable for formal verification. This allows the designer to apply formal verification techniques based on test cases without specifying properties. We implemented our approach and evaluated the flow for an illustrative example that successfully demonstrates the advantages of the proposed flow.				Included	Included	new_screen			2						
221	Behave	Behavior driven development for circuit design and verification	The design of hardware systems is a challenging and erroneous task where about 70% of the effort in designing these systems is spent on verification. In general, testing and verification are usually tasks that are being applied as a post-process to the implementation. In this paper, we propose a new design flow based on Behavior Driven Development (BDD), an agile technique for the development of software in which acceptance tests written in natural language play a central role and are the starting point in the design flow. We advance the flow such that the specifics that arise when modeling hardware are taken into account. Furthermore, we present a technique that allows for the automatic generalization of test cases to properties that are suitable for formal verification. This allows the designer to apply formal verification techniques based on test cases without specifying properties. We implemented our approach and evaluated the flow for an illustrative example that successfully demonstrates the advantages of the proposed flow. © 2012 IEEE.		Diepenbeck M., Soeken M., Große D., Drechsler R.	Proceedings - IEEE International High-Level Design Validation and Test Workshop, HLDVT	The design of hardware systems is a challenging and erroneous task where about 70% of the effort in designing these systems is spent on verification. In general, testing and verification are usually tasks that are being applied as a post-process to the implementation. In this paper, we propose a new design flow based on Behavior Driven Development (BDD), an agile technique for the development of software in which acceptance tests written in natural language play a central role and are the starting point in the design flow. We advance the flow such that the specifics that arise when modeling hardware are taken into account. Furthermore, we present a technique that allows for the automatic generalization of test cases to properties that are suitable for formal verification. This allows the designer to apply formal verification techniques based on test cases without specifying properties. We implemented our approach and evaluated the flow for an illustrative example that successfully demonstrates the advantages of the proposed flow. © 2012 IEEE.				Excluded	Excluded	new_screen			2						
222	Behave	Behaviour driven development for tests and verification	The design of hardware systems is a challenging and error-prone task, where a signifcant portion of the effort is spent for testing and verification. Usually testing and verification are applied as a post-process to the implementation. Meanwhile, for the development of software, test-first approaches such as test driven development (TDD) have become increasingly important. In this paper, we propose a new design flow based on behaviour driven development (BDD), an extension of TDD, where acceptance tests written in natural language drive the implementation. We extend this idea by allowing the specification of properties in natural language and use them as a starting point in the design flow. The flow also includes an automatic generalisation of test cases to properties that are used for formal verification. In this way, testing and formal verification are combined in a seamless manner, while keeping the requirements - from which both tests and formal properties are derived - in a single consistent document. The approach has been implemented and evaluated on several examples to demonstrate the advantages of the proposed flow. © 2014 Springer International Publishing Switzerland.		Diepenbeck M., Kühne U., Soeken M., Drechsler R.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	The design of hardware systems is a challenging and error-prone task, where a signifcant portion of the effort is spent for testing and verification. Usually testing and verification are applied as a post-process to the implementation. Meanwhile, for the development of software, test-first approaches such as test driven development (TDD) have become increasingly important. In this paper, we propose a new design flow based on behaviour driven development (BDD), an extension of TDD, where acceptance tests written in natural language drive the implementation. We extend this idea by allowing the specification of properties in natural language and use them as a starting point in the design flow. The flow also includes an automatic generalisation of test cases to properties that are used for formal verification. In this way, testing and formal verification are combined in a seamless manner, while keeping the requirements - from which both tests and formal properties are derived - in a single consistent document. The approach has been implemented and evaluated on several examples to demonstrate the advantages of the proposed flow. © 2014 Springer International Publishing Switzerland.				Included	Included	new_screen			2						
223	Behave	The ASSERT Virtual Machine: A Predictable Platform for Real-Time Systems	The development of real-time control systems is a complex process which has to face often conflicting requirements, especially those related to the performance of the control methods and the real-time behaviour of the system. The ASSERT Virtual Machine provides a reliable execution platform for such systems, which allows developers to cope with functional and real-time aspects separately. In order to guarantee the required real-time properties, the virtual machine only accepts software components which have a predictable temporal behaviour which can be analysed at system design time. Such components can be automatically generated from a high-level description of a system which embodies the functional components (e.g. control algorithms) into a set of containers providing the appropriate concurrent and realtime behaviour. The ASSERT Virtual Machine has been implemented in Ada 2005, using a predictable tasking subset of the language known as the Ravenscar profile. A prototype has been validated on several pilot-scale spacecraft control systems, with good results.	Computers for control, real-time systems, programming environments, software engineering, model-driven development	de la Puente, Juan A.; Zamorano, Juan; Pulido, José A.; Urueña, Santiago	IFAC Proceedings Volumes	The development of real-time control systems is a complex process which has to face often conflicting requirements, especially those related to the performance of the control methods and the real-time behaviour of the system. The ASSERT Virtual Machine provides a reliable execution platform for such systems, which allows developers to cope with functional and real-time aspects separately. In order to guarantee the required real-time properties, the virtual machine only accepts software components which have a predictable temporal behaviour which can be analysed at system design time. Such components can be automatically generated from a high-level description of a system which embodies the functional components (e.g. control algorithms) into a set of containers providing the appropriate concurrent and realtime behaviour. The ASSERT Virtual Machine has been implemented in Ada 2005, using a predictable tasking subset of the language known as the Ravenscar profile. A prototype has been validated on several pilot-scale spacecraft control systems, with good results.				Excluded	Excluded	new_screen			2						
224	Behave	Scenarios in the Loop: Integrated Requirements Analysis and Automotive System Validation	The development of safety-relevant systems in the automotive industry requires the definition of high-quality requirements and tests for the coordination and monitoring of development activities in an agile development environment. In this paper we describe a Scenarios in the Loop (SCIL) approach. SCIL combines (1) natural language requirements specification based on Behavior-Driven Development (BDD) with (2) formal and test-driven requirements modeling and analysis, and (3) integrates discipline-specific tools for software and system validation during development. A central element of SCIL is a flexible and executable scenario-based modeling language, the Scenario Modeling Language for Kotlin (SMLK). SMLK allows for an intuitive requirements formalization, and supports engineers to move iteratively, and continuously aided by automated checks, from stakeholder requirements to the validation of the implemented system. We evaluated the approach using a real example from the field of e-mobility.	automotive systems engineering; BizDevOps; requirements analysis; system validation	Wiecher, Carsten; Japs, Sergej; Kaiser, Lydia; Greenyer, Joel; Dumitrescu, Roman; Wolff, Carsten	Proceedings of the 23rd ACM/IEEE International Conference on Model Driven Engineering Languages and Systems: Companion Proceedings	The development of safety-relevant systems in the automotive industry requires the definition of high-quality requirements and tests for the coordination and monitoring of development activities in an agile development environment. In this paper we describe a Scenarios in the Loop (SCIL) approach. SCIL combines (1) natural language requirements specification based on Behavior-Driven Development (BDD) with (2) formal and test-driven requirements modeling and analysis, and (3) integrates discipline-specific tools for software and system validation during development. A central element of SCIL is a flexible and executable scenario-based modeling language, the Scenario Modeling Language for Kotlin (SMLK). SMLK allows for an intuitive requirements formalization, and supports engineers to move iteratively, and continuously aided by automated checks, from stakeholder requirements to the validation of the implemented system. We evaluated the approach using a real example from the field of e-mobility.				Included	Included	new_screen			2						
225	Behave	Continuous Security through Integration Testing in an Electronic Health Records System	The estimated average cost of a healthcare data breach in 2019 was $6.45 million, which is the highest among all industries. Yet, security remains an afterthought in many digital health applications. Formal methods for testing for bugs are commonplace in software development through the use of unit testing, integration testing, system testing, and acceptance testing. More so, in modern software engineering, continuous integration is a well-known concept to run automated tests soon after any code change, when the system builds and notifies the development team of the test results. In this paper, we describe the use of a popular Python unit testing framework to implement a formal method of security testing. Common Vulnerability Scoring System (CVSS) is used to calculate metrics that represent the state of security of a deployed system. We developed a series of Pytest Behavioral Driven Development (BDD) scripts to test the Authentication and Availability of a widely used Electronic Health Records System called OpenMRS. The advantage of using the BDD approach is that testing scripts, called Gherkin files, can be read, and understood by the developers as well as the non-developer stakeholders. The use of Gherkin serves two purposes: firstly, it serves as the project’s documentation, and secondly, it automates the tests. The use of the CVSS score between 0 to 10 becomes an objective metric to compare every code change, thus achieving continuous security. We plan to expand BDD scripts to attacks like Denial of Service, Session Hijacking, SQL Injection, and other privilege escalation attacks.	Behavior Driven Development;Common Vulnerability Scoring System;Continuous Security;Electronic Health Records;Integration testing;OpenMRS	S. Purkayastha; S. Goyal; T. Phillips; H. Wu; B. Haakenson; X. Zou	2020 International Conference on Software Security and Assurance (ICSSA)	The estimated average cost of a healthcare data breach in 2019 was $6.45 million, which is the highest among all industries. Yet, security remains an afterthought in many digital health applications. Formal methods for testing for bugs are commonplace in software development through the use of unit testing, integration testing, system testing, and acceptance testing. More so, in modern software engineering, continuous integration is a well-known concept to run automated tests soon after any code change, when the system builds and notifies the development team of the test results. In this paper, we describe the use of a popular Python unit testing framework to implement a formal method of security testing. Common Vulnerability Scoring System (CVSS) is used to calculate metrics that represent the state of security of a deployed system. We developed a series of Pytest Behavioral Driven Development (BDD) scripts to test the Authentication and Availability of a widely used Electronic Health Records System called OpenMRS. The advantage of using the BDD approach is that testing scripts, called Gherkin files, can be read, and understood by the developers as well as the non-developer stakeholders. The use of Gherkin serves two purposes: firstly, it serves as the project’s documentation, and secondly, it automates the tests. The use of the CVSS score between 0 to 10 becomes an objective metric to compare every code change, thus achieving continuous security. We plan to expand BDD scripts to attacks like Denial of Service, Session Hijacking, SQL Injection, and other privilege escalation attacks.				Included	Included	new_screen			2						
226	Behave	Design Driven Testing: Test Smarter, Not Harder	The groundbreaking book Design Driven Testing brings sanity back to the software development process by flipping around the concept of Test Driven Development (TDD)restoring the concept of using testing to verify a design instead of pretending that unit tests are a replacement for design. Anyone who feels that TDD is Too Damn Difficult will appreciate this book. Design Driven Testing shows that, by combining a forward-thinking development process with cutting-edge automation, testing can be a finely targeted, business-driven, rewarding effort. In other words, youll learn how to test smarter, not harder. Applies a feedback-driven approach to each stage of the project lifecycle. Illustrates a lightweight and effective approach using a core subset of UML. Follows a real-life example project using Java and Flex/ActionScript. Presents bonus chapters for advanced DDTers covering unit-test antipatterns (and their opposite, test-conscious design patterns), and showing how to create your own test transformation templates in Enterprise Architect. What youll learn Create unit and behavioral tests using JUnit, NUnit, FlexUnit. Generate acceptance tests for all usage paths through use case thread expansion. Generate requirement tests for functional requirements. Run complex acceptance tests across the enterprise. Isolate individual control points for self-contained unit/behavioral tests. Apply Behavior Driven Development frameworks like JBehave and NBehave Design Driven Testing should appeal to developers, project managers, testers, business analysts, architectsin fact anyone who builds software that needs to be tested. While equally applicable on both large and small projects, Design Driven Testing is especially helpful to those developers who need to verify their software against formal requirements. Such developers will benefit greatly from the rational and disciplined approach espoused by the authors.		Stephens, Matt; Rosenberg, Doug		The groundbreaking book Design Driven Testing brings sanity back to the software development process by flipping around the concept of Test Driven Development (TDD)restoring the concept of using testing to verify a design instead of pretending that unit tests are a replacement for design. Anyone who feels that TDD is Too Damn Difficult will appreciate this book. Design Driven Testing shows that, by combining a forward-thinking development process with cutting-edge automation, testing can be a finely targeted, business-driven, rewarding effort. In other words, youll learn how to test smarter, not harder. Applies a feedback-driven approach to each stage of the project lifecycle. Illustrates a lightweight and effective approach using a core subset of UML. Follows a real-life example project using Java and Flex/ActionScript. Presents bonus chapters for advanced DDTers covering unit-test antipatterns (and their opposite, test-conscious design patterns), and showing how to create your own test transformation templates in Enterprise Architect. What youll learn Create unit and behavioral tests using JUnit, NUnit, FlexUnit. Generate acceptance tests for all usage paths through use case thread expansion. Generate requirement tests for functional requirements. Run complex acceptance tests across the enterprise. Isolate individual control points for self-contained unit/behavioral tests. Apply Behavior Driven Development frameworks like JBehave and NBehave Design Driven Testing should appeal to developers, project managers, testers, business analysts, architectsin fact anyone who builds software that needs to be tested. While equally applicable on both large and small projects, Design Driven Testing is especially helpful to those developers who need to verify their software against formal requirements. Such developers will benefit greatly from the rational and disciplined approach espoused by the authors.				Excluded	Excluded	new_screen			2						
227	Behave	Development of health software using behaviour driven development - BDD	The health software industry is facing an immense challenge of managing quality and preventing software failures. Poorly defined requirements are one of the significant cause of health software failures. Agile practices are being increasingly used by the software industry to develop systems on time and within budget with improved software quality and user acceptance. Behaviour-driven development (BDD) is an agile software engineering practice that can help to improve health software quality vastly. BDD achieves this by prioritising the illustration of software's behaviour using ubiquitous language, followed by automated acceptance testing to assess if the illustrated behaviour was achieved. This paper presents a review of BDD literature, including the characteristics of BDD and examines how BDD can benefit health software quality. The paper reviews health software standards and guidelines, to examine their compatibility with a BDD approach. Finally, the paper details future plans for the development of a framework that provides health software companies with a detailed step by step guideline on how to use BDD to develop safer health software. Copyright © 2020 by SCITEPRESS - Science and Technology Publications, Lda. All rights reserved.		Anjum M.Z., Mahon S.T.M., MahonMcCaffery F.	MODELSWARD 2020 - Proceedings of the 8th International Conference on Model-Driven Engineering and Software Development	The health software industry is facing an immense challenge of managing quality and preventing software failures. Poorly defined requirements are one of the significant cause of health software failures. Agile practices are being increasingly used by the software industry to develop systems on time and within budget with improved software quality and user acceptance. Behaviour-driven development (BDD) is an agile software engineering practice that can help to improve health software quality vastly. BDD achieves this by prioritising the illustration of software's behaviour using ubiquitous language, followed by automated acceptance testing to assess if the illustrated behaviour was achieved. This paper presents a review of BDD literature, including the characteristics of BDD and examines how BDD can benefit health software quality. The paper reviews health software standards and guidelines, to examine their compatibility with a BDD approach. Finally, the paper details future plans for the development of a framework that provides health software companies with a detailed step by step guideline on how to use BDD to develop safer health software. Copyright © 2020 by SCITEPRESS - Science and Technology Publications, Lda. All rights reserved.				Excluded	Excluded	new_screen			2						
228	Behave	Behaviour-driven development applied to the conformance testing of INSPIRE web services	The implementation of the INSPIRE directive requires to check the conformity of a large number of network services with the implementing rules of INSPIRE. The evaluation whether a service is fully conformant with INSPIRE is complex and requires the use of specialized testing tools that should report how verification has been made and should identify non-conformances. The use of these tools requires a high degree of technical knowledge. This fact makes very difficult for non-technical stakeholders (end users, managers, domain experts, etc.) to participate effectively in conformance testing, hinders stakeholders understanding of the causes and consequences of non-conformant results and may cause in some stakeholders disinterest in conformance testing. This work explores the suitability of a behaviour-driven development (BDD) approach to the conformance testing of OGC Web services in the context of the INSPIRE directive. BDD emphasizes the participation of non-technical parties in the design of acceptance tests by means of automatable abstract tests expressed in a human readable format. Using this idea as base, this work describes a BDD based workflow to derive abstract test suites and executable test suites from INSPIRE implementation requirements that can be written in the language used by non-technical stakeholders. This work also analyses if BDD and popular BDD tools, such as Gherkin and Cucumber, are compatible with ISO 19105:2000 testing methodology. As demonstration, we present an online conformance tool for INSPIRE View and Discovery services that executes BDD test suites. © Springer International Publishing Switzerland 2014.		Lopez-Pellicer F.J., Latre M.Á., Nogueras-Iso J., Javier Zarazaga-Soria F., Barrera J.	Lecture Notes in Geoinformation and Cartography	The implementation of the INSPIRE directive requires to check the conformity of a large number of network services with the implementing rules of INSPIRE. The evaluation whether a service is fully conformant with INSPIRE is complex and requires the use of specialized testing tools that should report how verification has been made and should identify non-conformances. The use of these tools requires a high degree of technical knowledge. This fact makes very difficult for non-technical stakeholders (end users, managers, domain experts, etc.) to participate effectively in conformance testing, hinders stakeholders understanding of the causes and consequences of non-conformant results and may cause in some stakeholders disinterest in conformance testing. This work explores the suitability of a behaviour-driven development (BDD) approach to the conformance testing of OGC Web services in the context of the INSPIRE directive. BDD emphasizes the participation of non-technical parties in the design of acceptance tests by means of automatable abstract tests expressed in a human readable format. Using this idea as base, this work describes a BDD based workflow to derive abstract test suites and executable test suites from INSPIRE implementation requirements that can be written in the language used by non-technical stakeholders. This work also analyses if BDD and popular BDD tools, such as Gherkin and Cucumber, are compatible with ISO 19105:2000 testing methodology. As demonstration, we present an online conformance tool for INSPIRE View and Discovery services that executes BDD test suites. © Springer International Publishing Switzerland 2014.				Included	Included	new_screen			2						
229	Behave	Towards a Thing-In-the-Loop Approach for the Verification and Validation of IoT Systems	The Internet of Things (IoT) is rapidly increasing its diffusion, posing great challenges to the research community. IoT systems are composed by smart objects (Things) that are interconnected in order to provide new products and services. The interaction of heterogeneous and distributed smart things guided by software with the physical world brings new sources of safety issues. To this reason, providing valuable and effective solutions to support the verification and validation of such systems is needed. In this paper we introduce a model-driven Thing-In-the-Loop verification and validation approach that transfers the best practices adopted in different embedded system domains towards the IoT world. Starting from models and scenarios representing the structure and behaviors of the IoT system as well as models of its context our approach generates appropriate test cases that are executed in accordance with Model-in-the-Loop, Software-in-the-Loop and Hardware-in-the-Loop techniques. We preliminarily evaluated the feasibility of our approach by applying it in the context of a Smart Mobility case study.	Internet of Things; Model-driven engineering; Thing-In-the-loop; verification and validation	Amalfitano, Domenico; Amatucci, Nicola; De Simone, Vincenzo; Riccio, Vincenzo; Rita, Fasolino Anna	Proceedings of the 1st ACM Workshop on the Internet of Safe Things	The Internet of Things (IoT) is rapidly increasing its diffusion, posing great challenges to the research community. IoT systems are composed by smart objects (Things) that are interconnected in order to provide new products and services. The interaction of heterogeneous and distributed smart things guided by software with the physical world brings new sources of safety issues. To this reason, providing valuable and effective solutions to support the verification and validation of such systems is needed. In this paper we introduce a model-driven Thing-In-the-Loop verification and validation approach that transfers the best practices adopted in different embedded system domains towards the IoT world. Starting from models and scenarios representing the structure and behaviors of the IoT system as well as models of its context our approach generates appropriate test cases that are executed in accordance with Model-in-the-Loop, Software-in-the-Loop and Hardware-in-the-Loop techniques. We preliminarily evaluated the feasibility of our approach by applying it in the context of a Smart Mobility case study.				Excluded	Excluded	new_screen			2						
230	Behave	Supporting smart construction with dependable edge computing infrastructures and applications	The Internet of Things (IoT) such as the use of robots, sensors, actuators, electronic signalization and a variety of other Internet enabled physical devices may provide for new advanced smart applications to be used in construction in the very near future. Such applications require real-time responses and are therefore time-critical. Therefore, in order to support collaboration, control, monitoring, supply management, safety and other construction processes, they have to meet dependability requirements, including requirements for high Quality of Service (QoS). Dependability and high QoS can be achieved by using adequate number and quality of computing resources, such as processing, memory and networking elements, geographically close to the smart environments. The goal of this study is to develop a practical edge computing architecture and design, which can be used to support smart construction environments with high QoS. This study gives particular attention to the solution design, which relies on latest cloud and software engineering approaches and technologies, and provides elasticity, interoperability and adaptation to companies' specific needs. Two edge computing applications supporting video communications and construction process documentation are developed and demonstrate a viable edge computing design for smart construction.	Smart construction, Dependability, Internet of Things, Container-based systems, Edge computing	Kochovski, Petar; Stankovski, Vlado	Automation in Construction	The Internet of Things (IoT) such as the use of robots, sensors, actuators, electronic signalization and a variety of other Internet enabled physical devices may provide for new advanced smart applications to be used in construction in the very near future. Such applications require real-time responses and are therefore time-critical. Therefore, in order to support collaboration, control, monitoring, supply management, safety and other construction processes, they have to meet dependability requirements, including requirements for high Quality of Service (QoS). Dependability and high QoS can be achieved by using adequate number and quality of computing resources, such as processing, memory and networking elements, geographically close to the smart environments. The goal of this study is to develop a practical edge computing architecture and design, which can be used to support smart construction environments with high QoS. This study gives particular attention to the solution design, which relies on latest cloud and software engineering approaches and technologies, and provides elasticity, interoperability and adaptation to companies' specific needs. Two edge computing applications supporting video communications and construction process documentation are developed and demonstrate a viable edge computing design for smart construction.				Excluded	Excluded	new_screen			2						
231	Behave	Towards Behavior-Driven Graphical User Interface Testing	The majority of users interacts with an application through its graphical user interface (GUI). To ensure high quality and expected behavior, those graphical user interfaces have to be tested thoroughly. Yet, creating graphical user interface test cases is considered expensive in comparison to unit or integration tests. In addition, test cases are perceived to be expensive to run and brittle, therefore causing a lot of false negative test results. Behavior-driven test case design addresses this challenges by bringing requirement specifications and test cases closer together. Although industry-proven tools map test specifications automatically, test methods making test scripts executable need to be implemented manually. The specification language Slang introduced by this paper generates automatically executable test cases from BDD-like feature descriptions that integrate low-fidelity prototypes in form of wireframesketcher models. To quantify the economic advantage of our approach an AB/BA crossover designed experiment was conducted. The experiment showed that creating automatically executable test cases utilizing Slang takes 63% less time compared to the industry-proven tool JBehave. In addition to presenting the experiment's results, the paper elaborates on first experience from applying the approach in a large Swiss bank. The findings of our experiments are supported by results from applying our approach in real-world scenarios. In addition, experiment as well as case study participants appreciated the sophisticated editor support of Slang.	behavior-driven development; domain-specific language; GUI test case generation; model-driven engineering; case study	Bünder, Hendrik; Kuchen, Herbert	SIGAPP Appl. Comput. Rev.	The majority of users interacts with an application through its graphical user interface (GUI). To ensure high quality and expected behavior, those graphical user interfaces have to be tested thoroughly. Yet, creating graphical user interface test cases is considered expensive in comparison to unit or integration tests. In addition, test cases are perceived to be expensive to run and brittle, therefore causing a lot of false negative test results. Behavior-driven test case design addresses this challenges by bringing requirement specifications and test cases closer together. Although industry-proven tools map test specifications automatically, test methods making test scripts executable need to be implemented manually. The specification language Slang introduced by this paper generates automatically executable test cases from BDD-like feature descriptions that integrate low-fidelity prototypes in form of wireframesketcher models. To quantify the economic advantage of our approach an AB/BA crossover designed experiment was conducted. The experiment showed that creating automatically executable test cases utilizing Slang takes 63% less time compared to the industry-proven tool JBehave. In addition to presenting the experiment's results, the paper elaborates on first experience from applying the approach in a large Swiss bank. The findings of our experiments are supported by results from applying our approach in real-world scenarios. In addition, experiment as well as case study participants appreciated the sophisticated editor support of Slang.				Included	Included	new_screen			2						
232	Behave	The behavior driven development applied to the software quality test: A case study applied to the promotion of sports financing in Brazil	The mechanisms of private investment in Brazilian sport are one of the main sources of resources that athletes hold to promote participation in high-performance competitions. In order to improve this flow, softwares are designed to shorten the path between donors and recipients. These tools, such as 'Meu Campeãu' used in this paper, require efficient analysis of the quality of the product offered. Concepts known as agile methodologies have brought a new style to the analysis of the software developed, and one of them has gained considerable prominence, known such as BDD (Behavior Driven Development), so this paper aims to analyze the implementation of Behavior Driven Development in the software quality verification process 'Meu Campeãu'. © 2019 AISTI.		Cavalcante M.G., Sales J.I.	Iberian Conference on Information Systems and Technologies, CISTI	The mechanisms of private investment in Brazilian sport are one of the main sources of resources that athletes hold to promote participation in high-performance competitions. In order to improve this flow, softwares are designed to shorten the path between donors and recipients. These tools, such as 'Meu Campeãu' used in this paper, require efficient analysis of the quality of the product offered. Concepts known as agile methodologies have brought a new style to the analysis of the software developed, and one of them has gained considerable prominence, known such as BDD (Behavior Driven Development), so this paper aims to analyze the implementation of Behavior Driven Development in the software quality verification process 'Meu Campeãu'. © 2019 AISTI.				Included	Included	new_screen			2						
233	Behave	Graph-based and scenario-driven microservice analysis, retrieval, and testing	The microservice architecture (MSA) differs fundamentally from the monolithic, layered architecture. The use of microservices provides a high degree of autonomy, composability, scalability, and fault-tolerance. MSA is regarded by many as a promising architecture for smart-city applications; however, a number of issues remain, including (1) the management of complex call relationships among microservices; (2) ensuring the quality of the overall software system even as new microservices are added and existing ones are modified, and (3) locating existing microservices that satisfy new requirements. In this paper, we propose a novel approach to the development of microservice-based systems, referred to as GSMART (Graph-based and Scenario-driven Microservice Analysis, Retrieval and Testing). GSMART enables the automatic generation of a “Service Dependency Graph (SDG)” by which to visualize and analyze dependency relationships between microservices as well as between services and scenarios. It also enables the automatic retrieval of test cases required for system changes to reduce the time and costs associated with regression testing. A microservice retrieval method using VSM and word2vec accelerates the development of new microservices tailored specifically to the needs of users based on user-provided scenarios. Experiment results demonstrate the feasibility, effectiveness, and efficiency of all of the main features of GSMART.	Microservice retrieval, Microservice testing, Microservice analysis, Service dependency graph, Behavior-driven development	Ma, Shang-Pin; Fan, Chen-Yuan; Chuang, Yen; Liu, I.-Hsiu; Lan, Ci-Wei	Future Generation Computer Systems	The microservice architecture (MSA) differs fundamentally from the monolithic, layered architecture. The use of microservices provides a high degree of autonomy, composability, scalability, and fault-tolerance. MSA is regarded by many as a promising architecture for smart-city applications; however, a number of issues remain, including (1) the management of complex call relationships among microservices; (2) ensuring the quality of the overall software system even as new microservices are added and existing ones are modified, and (3) locating existing microservices that satisfy new requirements. In this paper, we propose a novel approach to the development of microservice-based systems, referred to as GSMART (Graph-based and Scenario-driven Microservice Analysis, Retrieval and Testing). GSMART enables the automatic generation of a “Service Dependency Graph (SDG)” by which to visualize and analyze dependency relationships between microservices as well as between services and scenarios. It also enables the automatic retrieval of test cases required for system changes to reduce the time and costs associated with regression testing. A microservice retrieval method using VSM and word2vec accelerates the development of new microservices tailored specifically to the needs of users based on user-provided scenarios. Experiment results demonstrate the feasibility, effectiveness, and efficiency of all of the main features of GSMART.				Included	Included	new_screen			2						
234	Behave	CEUR Workshop Proceedings	The proceedings contain 10 papers. The topics discussed include: pattern-driven knowledge systems engineering; an ontology debugger for the semantic Wiki KnowWE; behaviour-driven development for computer-interpretable clinical guidelines; ensuring the semantic correctness of workflow processes: an ontological approach; integration of activity modeller with Bayesian network based recommender for business processes; towards an ontological analysis of BPMN; CAPJA - a connector architecture for prolog and Java; migration of rule inference engine to mobile platform. challenges and case study; knowledge modeling with the open source tool myCBR; and SBVRwiki.		[No author name available]	CEUR Workshop Proceedings	The proceedings contain 10 papers. The topics discussed include: pattern-driven knowledge systems engineering; an ontology debugger for the semantic Wiki KnowWE; behaviour-driven development for computer-interpretable clinical guidelines; ensuring the semantic correctness of workflow processes: an ontological approach; integration of activity modeller with Bayesian network based recommender for business processes; towards an ontological analysis of BPMN; CAPJA - a connector architecture for prolog and Java; migration of rule inference engine to mobile platform. challenges and case study; knowledge modeling with the open source tool myCBR; and SBVRwiki.				Excluded	Excluded	new_screen			2						
235	Behave	Proceedings - 34th Brazilian Symposium on Software Engineering, SBES 2020	The proceedings contain 101 papers. The topics discussed include: on the influence of different perspectives on evaluating the quality of teamwork in the context of agile software development; challenges in agile transformation journey - a qualitative study; agile global software development: a systematic literature review; behavior-driven development: an expert panel to evaluate benefits and challenges [insightful ideas and emerging results; adaptations of scrum roles in software projects: survey and representation tentative with feature models; are code smell co-occurrences harmful to internal quality attributes? a mixed-method study; recommending composite refactorings for smell removal: heuristics and evaluation; a catalog of object-relational mapping code smells for java; and probabilistic model-based analysis to improve software energy efficiency.		[No author name available]	ACM International Conference Proceeding Series	The proceedings contain 101 papers. The topics discussed include: on the influence of different perspectives on evaluating the quality of teamwork in the context of agile software development; challenges in agile transformation journey - a qualitative study; agile global software development: a systematic literature review; behavior-driven development: an expert panel to evaluate benefits and challenges [insightful ideas and emerging results; adaptations of scrum roles in software projects: survey and representation tentative with feature models; are code smell co-occurrences harmful to internal quality attributes? a mixed-method study; recommending composite refactorings for smell removal: heuristics and evaluation; a catalog of object-relational mapping code smells for java; and probabilistic model-based analysis to improve software energy efficiency.				Excluded	Excluded	new_screen			2						
236	Behave	Proceedings - 2021 IEEE/ACM 6th International Workshop on Metamorphic Testing, MET 2021	The proceedings contain 11 papers. The topics discussed include: robustness evaluation of stacked generative adversarial networks using metamorphic testing; metamorphic detection of repackaged malware; applying metamorphic testing to homomorphic cryptography; BMT: behavior driven development-based metamorphic testing for autonomous driving models; enhancing Euro NCAP standards with metamorphic testing for verification of advanced driver-assistance systems; towards automated metamorphic test identification for ocean system models; metamorphic testing on the continuum of verification and validation of simulation models; and metamorphic testing for image-based calcium imaging analysis pipelines.		[No author name available]	Proceedings - 2021 IEEE/ACM 6th International Workshop on Metamorphic Testing, MET 2021	The proceedings contain 11 papers. The topics discussed include: robustness evaluation of stacked generative adversarial networks using metamorphic testing; metamorphic detection of repackaged malware; applying metamorphic testing to homomorphic cryptography; BMT: behavior driven development-based metamorphic testing for autonomous driving models; enhancing Euro NCAP standards with metamorphic testing for verification of advanced driver-assistance systems; towards automated metamorphic test identification for ocean system models; metamorphic testing on the continuum of verification and validation of simulation models; and metamorphic testing for image-based calcium imaging analysis pipelines.				Excluded	Excluded	new_screen			2						
237	Behave	21st International Conference on Agile Software Development, XP 2020	The proceedings contain 16 papers. The special focus in this conference is on Agile Software Development. The topics include: “When in Rome, Do as the Romans Do”: Cultural Barriers to Being Agile in Distributed Teams; a Quantitative Exploration of the 9-Factor Theory: Distribution of Leadership Roles Between Scrum Master and Agile Team; what an Agile Leader Does: The Group Dynamics Perspective; “This is Just a Prototype”: How Ethics Are Ignored in Software Startup-Like Environments; hypotheses Elicitation in Early-Stage Software Startups Based on Cognitive Mapping; results from a Replicated Experiment on the Affective Reactions of Novice Developers When Applying Test-Driven Development; examining the Current State of System Testing Methodologies in Quality Assurance; onboarding: How Newcomers Integrate into an Agile Project Team; combining User-Centered Design and Lean Startup with Agile Software Development: A Case Study of Two Agile Teams; agile Software Development Practices and Success in Outsourced Projects: The Moderating Role of Requirements Risk; on the Use of Design Thinking: A Survey of the Brazilian Agile Software Development Community; characterising the Quality of Behaviour Driven Development Specifications; “I Don’t Understand!”: Toward a Model to Evaluate the Role of User Story Quality; large-Scale Agile Transformation: A Case Study of Transforming Business, Development and Operations.		[No author name available]	Lecture Notes in Business Information Processing	The proceedings contain 16 papers. The special focus in this conference is on Agile Software Development. The topics include: “When in Rome, Do as the Romans Do”: Cultural Barriers to Being Agile in Distributed Teams; a Quantitative Exploration of the 9-Factor Theory: Distribution of Leadership Roles Between Scrum Master and Agile Team; what an Agile Leader Does: The Group Dynamics Perspective; “This is Just a Prototype”: How Ethics Are Ignored in Software Startup-Like Environments; hypotheses Elicitation in Early-Stage Software Startups Based on Cognitive Mapping; results from a Replicated Experiment on the Affective Reactions of Novice Developers When Applying Test-Driven Development; examining the Current State of System Testing Methodologies in Quality Assurance; onboarding: How Newcomers Integrate into an Agile Project Team; combining User-Centered Design and Lean Startup with Agile Software Development: A Case Study of Two Agile Teams; agile Software Development Practices and Success in Outsourced Projects: The Moderating Role of Requirements Risk; on the Use of Design Thinking: A Survey of the Brazilian Agile Software Development Community; characterising the Quality of Behaviour Driven Development Specifications; “I Don’t Understand!”: Toward a Model to Evaluate the Role of User Story Quality; large-Scale Agile Transformation: A Case Study of Transforming Business, Development and Operations.				Excluded	Excluded	new_screen			2						
238	Behave	2020 IEEE International Conference on Problems of Infocommunications Science and Technology, PIC S and T 2020 - Proceedings	The proceedings contain 171 papers. The topics discussed include: last mile technique for wireless delivery system using an accelerating lens; compact polarizers for satellite information systems; highly-distributed systems: what is inside?; behavior driven development approach in the modern quality control process; analysis of influence of UDP parameters on QoS in IP network; categorical analysis of logical networks in application to intelligent radar systems; models and information technology for reliable design of the functioning processes of flexible production systems as complex human-machine systems; advanced code-based electronic digital signature scheme; required safety component of automotive cyber-physical systems; and structure optimization of the multi-channel on-board radar with antenna aperture synthesis and algorithm for power line selection on the background of the earth surface.		[No author name available]	2020 IEEE International Conference on Problems of Infocommunications Science and Technology, PIC S and T 2020 - Proceedings	The proceedings contain 171 papers. The topics discussed include: last mile technique for wireless delivery system using an accelerating lens; compact polarizers for satellite information systems; highly-distributed systems: what is inside?; behavior driven development approach in the modern quality control process; analysis of influence of UDP parameters on QoS in IP network; categorical analysis of logical networks in application to intelligent radar systems; models and information technology for reliable design of the functioning processes of flexible production systems as complex human-machine systems; advanced code-based electronic digital signature scheme; required safety component of automotive cyber-physical systems; and structure optimization of the multi-channel on-board radar with antenna aperture synthesis and algorithm for power line selection on the background of the earth surface.				Excluded	Excluded	new_screen			2						
239	Behave	CEUR Workshop Proceedings	The proceedings contain 19 papers. The topics discussed include: product configuration in the wild: strategies for conflicting decisions in web configurators; configuring release plans; insights for configuration in natural language; group decision support for requirements management processes; Chatbot-based tourist recommendations using model-based reasoning; the effect of default options on consumer decisions in the product configuration process; cost benefit analysis in product configuration systems; do you read me? on the limits of manufacturing part numbers for communicating product variety; behavior-driven development in product configuration systems; integrating semantic web technologies and ASP for product configuration; measuring the complexity of product configuration systems; generating configuration models from requirements to assist in product management - dependency engine and its performance assessment; quasi-finite domains: dealing with the infinite in mass customization; software configuration diagnosis - a survey of existing methods and open challenges; knowledge retrieval for configuring risks when answering calls to tenders or direct customer demands; how to deal with engineering-to-order product/system configuration?; towards knowledge infrastructure for highly variant voltage transmission systems; and configuration lifecycle management - an assessment of the benefits based on maturity.		[No author name available]	CEUR Workshop Proceedings	The proceedings contain 19 papers. The topics discussed include: product configuration in the wild: strategies for conflicting decisions in web configurators; configuring release plans; insights for configuration in natural language; group decision support for requirements management processes; Chatbot-based tourist recommendations using model-based reasoning; the effect of default options on consumer decisions in the product configuration process; cost benefit analysis in product configuration systems; do you read me? on the limits of manufacturing part numbers for communicating product variety; behavior-driven development in product configuration systems; integrating semantic web technologies and ASP for product configuration; measuring the complexity of product configuration systems; generating configuration models from requirements to assist in product management - dependency engine and its performance assessment; quasi-finite domains: dealing with the infinite in mass customization; software configuration diagnosis - a survey of existing methods and open challenges; knowledge retrieval for configuring risks when answering calls to tenders or direct customer demands; how to deal with engineering-to-order product/system configuration?; towards knowledge infrastructure for highly variant voltage transmission systems; and configuration lifecycle management - an assessment of the benefits based on maturity.				Excluded	Excluded	new_screen			2						
240	Behave	8th International Conference on Model and Data Engineering, MEDI 2018, International Workshop on Modeling, Verification and Testing of Dependable Critical Systems, DETECT 2018, Model and Data Engineering for Social Good Workshop, MEDI4SG 2018, 2nd International Workshop on Cybersecurity and Functional Safety in Cyber-Physical Systems, IWCFS 2018, International Workshop on Formal Model for Mastering Multifaceted Systems, REMEDY 2018	The proceedings contain 21 papers. The special focus in this conference is on Model and Data Engineering. The topics include: Towards a requirements engineering approach for capturing uncertainty in cyber-physical systems environment; assessment of emerging standards for safety and security co-design on a railway case study; generation of behavior-driven development C++ tests from abstract state machine scenarios; hybrid systems and event-B: A formal approach to signalised left-turn assist; handling reparation in incremental construction of realizable conversation protocols; Analyzing a ROS based architecture for its cross reuse in ISO26262 settings; reliability in fully probabilistic event-B: How to bound the enabling of events; systematic construction of critical embedded systems using event-B; component design and adaptation based on behavioral contracts; An MDA approach for the specification of relay-based diagrams; Towards real-time semantics for a distributed event-based MOP language; Automatic planning: From event-B to PDDL; a problem-oriented approach to critical system design and diagnosis support; formal specification and verification of cloud resource allocation using timed petri-nets; Petri nets to event-B: Handling mathematical sequences through an ERTMS L3 Case; model-based verification and testing methodology for safety-critical airborne systems; gamification and serious games based learning for early childhood in rural areas; context-based sentiment analysis: A survey; a multi-agent system-based distributed intrusion detection system for a cloud computing.		[No author name available]	Communications in Computer and Information Science	The proceedings contain 21 papers. The special focus in this conference is on Model and Data Engineering. The topics include: Towards a requirements engineering approach for capturing uncertainty in cyber-physical systems environment; assessment of emerging standards for safety and security co-design on a railway case study; generation of behavior-driven development C++ tests from abstract state machine scenarios; hybrid systems and event-B: A formal approach to signalised left-turn assist; handling reparation in incremental construction of realizable conversation protocols; Analyzing a ROS based architecture for its cross reuse in ISO26262 settings; reliability in fully probabilistic event-B: How to bound the enabling of events; systematic construction of critical embedded systems using event-B; component design and adaptation based on behavioral contracts; An MDA approach for the specification of relay-based diagrams; Towards real-time semantics for a distributed event-based MOP language; Automatic planning: From event-B to PDDL; a problem-oriented approach to critical system design and diagnosis support; formal specification and verification of cloud resource allocation using timed petri-nets; Petri nets to event-B: Handling mathematical sequences through an ERTMS L3 Case; model-based verification and testing methodology for safety-critical airborne systems; gamification and serious games based learning for early childhood in rural areas; context-based sentiment analysis: A survey; a multi-agent system-based distributed intrusion detection system for a cloud computing.				Excluded	Excluded	new_screen			2						
241	Behave	17th AGILE Conference on Geographic Information Science, AGILE 2014	The proceedings contain 22 papers. The special focus in this conference is on Geographic Information Science. The topics include: Estimating completeness of vgi datasets by analyzing community activity over time periods; estimation of building types on openstreetmap based on urban morphology analysis; qualitative representations of extended spatial objects in sketch maps; exploring the geographical relations between social media and flood phenomena to improve situational awareness; event identification from georeferenced images; a recursive bayesian filter for anomalous behavior detection in trajectory data; using GPS logs to identify agronomical activities; assessing the influence of preprocessing methods on raw GPS-Data for automated change point detection; mining frequent spatio-temporal patterns in wind speed and direction; the text encoding algorithm for latitude/longitude/time; fast SNN-Based clustering approach for large geospatial data sets; RSS and sensor fusion algorithms for indoor location systems on Smartphones; an image segmentation process enhancement for land cover mapping from very high resolution remote sensing data application in a rural area; line matching for integration of photographic and geographic databases; encoding and querying historic map content; an area merge operation for smooth zooming; point labeling with sliding labels in interactive maps; comparing verbal instructions and sketch maps.; behaviour-driven development applied to the conformance testing of INSPIRE web services; making the web of data available via web feature services; a geospatial exploration of comparable cities and a gis-based process for calculating visibility impact from buildings during transmission line routing.		[No author name available]	Lecture Notes in Geoinformation and Cartography	The proceedings contain 22 papers. The special focus in this conference is on Geographic Information Science. The topics include: Estimating completeness of vgi datasets by analyzing community activity over time periods; estimation of building types on openstreetmap based on urban morphology analysis; qualitative representations of extended spatial objects in sketch maps; exploring the geographical relations between social media and flood phenomena to improve situational awareness; event identification from georeferenced images; a recursive bayesian filter for anomalous behavior detection in trajectory data; using GPS logs to identify agronomical activities; assessing the influence of preprocessing methods on raw GPS-Data for automated change point detection; mining frequent spatio-temporal patterns in wind speed and direction; the text encoding algorithm for latitude/longitude/time; fast SNN-Based clustering approach for large geospatial data sets; RSS and sensor fusion algorithms for indoor location systems on Smartphones; an image segmentation process enhancement for land cover mapping from very high resolution remote sensing data application in a rural area; line matching for integration of photographic and geographic databases; encoding and querying historic map content; an area merge operation for smooth zooming; point labeling with sliding labels in interactive maps; comparing verbal instructions and sketch maps.; behaviour-driven development applied to the conformance testing of INSPIRE web services; making the web of data available via web feature services; a geospatial exploration of comparable cities and a gis-based process for calculating visibility impact from buildings during transmission line routing.				Excluded	Excluded	new_screen			2						
242	Behave	CEUR Workshop Proceedings	The proceedings contain 24 papers. The topics discussed include: modeling test cases in BPMN for behavior-driven development; automating data exchange in process choreographies; gameful business process modeling; a game theoretic perspective on business processes; elastic process optimization and scheduling in the cloud; learning from quality issues of BPMN models from industry; the process of creating a domain specific modeling method; requirements catalog for business process modeling recommender systems; evaluating wiki collaborative features in ontology authoring; a visual language for modeling multiple perspectives of business process compliance rules; detecting flight trajectory anomalies and predicting diversions in freight transportation; and plausibility checking of formal business process specifications in linear temporal logic.		[No author name available]	CEUR Workshop Proceedings	The proceedings contain 24 papers. The topics discussed include: modeling test cases in BPMN for behavior-driven development; automating data exchange in process choreographies; gameful business process modeling; a game theoretic perspective on business processes; elastic process optimization and scheduling in the cloud; learning from quality issues of BPMN models from industry; the process of creating a domain specific modeling method; requirements catalog for business process modeling recommender systems; evaluating wiki collaborative features in ontology authoring; a visual language for modeling multiple perspectives of business process compliance rules; detecting flight trajectory anomalies and predicting diversions in freight transportation; and plausibility checking of formal business process specifications in linear temporal logic.				Excluded	Excluded	new_screen			2						
243	Behave	2012 IEEE International High Level Design Validation and Test Workshop, HLDVT 2012	The proceedings contain 24 papers. The topics discussed include: sequential equivalence checking of hard instances with targeted inductive invariants and efficient filtering strategies; behavior driven development for circuit design and verification; using decision diagrams to compactly represent the state space for explicit model checking; automatic generation of deadlock detection algorithms for a family of micro-architecture description languages of communication fabrics; automatic generation of Verilog bus transactors from natural language protocol specifications; single-source hardware modeling of different abstraction levels with state charts; using haloes in mixed-signal assertion based verification; a formal method to improve SystemVerilog functional coverage; a functional test generation technique for RTL datapaths; constrained signal selection for post-silicon validation; and monitoring distributed reactive systems.		[No author name available]	Proceedings - IEEE International High-Level Design Validation and Test Workshop, HLDVT	The proceedings contain 24 papers. The topics discussed include: sequential equivalence checking of hard instances with targeted inductive invariants and efficient filtering strategies; behavior driven development for circuit design and verification; using decision diagrams to compactly represent the state space for explicit model checking; automatic generation of deadlock detection algorithms for a family of micro-architecture description languages of communication fabrics; automatic generation of Verilog bus transactors from natural language protocol specifications; single-source hardware modeling of different abstraction levels with state charts; using haloes in mixed-signal assertion based verification; a formal method to improve SystemVerilog functional coverage; a functional test generation technique for RTL datapaths; constrained signal selection for post-silicon validation; and monitoring distributed reactive systems.				Excluded	Excluded	new_screen			2						
244	Behave	Objects, Models, Components, Patterns - 50th International Conference, TOOLS 2012, Proceedings	The proceedings contain 24 papers. The topics discussed include: supporting compile-time debugging and precise error reporting in meta-programs; identifying a unifying mechanism for the implementation of concurrency abstractions on multi-language virtual machines; verification of snapshotable trees using access permissions and typestate; multiparty session C: safe parallel programming with message optimisation; non-interference on UMI state-charts; representing uniqueness constraints in object-relational mapping; detection of seed methods for quantification of feature confinement; assisted behavior driven development using natural language processing; learning to classify bug reports into components; incremental dynamic updates with first-class contexts; and elucidative development for model-based documentation.		[No author name available]	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	The proceedings contain 24 papers. The topics discussed include: supporting compile-time debugging and precise error reporting in meta-programs; identifying a unifying mechanism for the implementation of concurrency abstractions on multi-language virtual machines; verification of snapshotable trees using access permissions and typestate; multiparty session C: safe parallel programming with message optimisation; non-interference on UMI state-charts; representing uniqueness constraints in object-relational mapping; detection of seed methods for quantification of feature confinement; assisted behavior driven development using natural language processing; learning to classify bug reports into components; incremental dynamic updates with first-class contexts; and elucidative development for model-based documentation.				Excluded	Excluded	new_screen			2						
245	Behave	IFIP WG 13.2/13.5 Joint 6th International Conference on Human-Centered Software Engineering, HCSE 2016 and 8th International Conference on Human Error, Safety, and System Development, HESSD 2016	The proceedings contain 25 papers. The special focus in this conference is on Agile, Human-Centered Software Engineering, Usability Evaluation, Testing, Socio-Technical, Ethical Considerations, Human Error, Safety-Critical Systems, User, Developer Experience, Models, Methods, Adopting Tools, Demos and Posters. The topics include: Supporting the HCI aspect of agile software development by tool support for UI-pattern transformations; usability problems experienced by different groups of skilled internet users; user-test results injection into task-based design process for the assessment and improvement of both usability and user experience; framework for relative web usability evaluation on usability features in MDD; testing prototypes and final user interfaces through an ontological perspective for behavior-driven development; complementary tools and techniques for supporting fitness-for-purpose of interactive critical systems; a conceptual ux-aware model of requirements; audio guidance for runner training; enterprise model-driven agile human-centered software engineering; collaborative task modelling on the web and declarative prototyping with data; a first prototype integrated in HAMSTERS.		[No author name available]	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	The proceedings contain 25 papers. The special focus in this conference is on Agile, Human-Centered Software Engineering, Usability Evaluation, Testing, Socio-Technical, Ethical Considerations, Human Error, Safety-Critical Systems, User, Developer Experience, Models, Methods, Adopting Tools, Demos and Posters. The topics include: Supporting the HCI aspect of agile software development by tool support for UI-pattern transformations; usability problems experienced by different groups of skilled internet users; user-test results injection into task-based design process for the assessment and improvement of both usability and user experience; framework for relative web usability evaluation on usability features in MDD; testing prototypes and final user interfaces through an ontological perspective for behavior-driven development; complementary tools and techniques for supporting fitness-for-purpose of interactive critical systems; a conceptual ux-aware model of requirements; audio guidance for runner training; enterprise model-driven agile human-centered software engineering; collaborative task modelling on the web and declarative prototyping with data; a first prototype integrated in HAMSTERS.				Excluded	Excluded	new_screen			2						
246	Behave	Enterprise Information Systems of the Future - 6th IFIP WG 8.9 Working Conference, CONFENIS 2012, Revised Selected Papers	The proceedings contain 25 papers. The topics discussed include: process innovation: redesigning an enterprise backbone system; sub-process discovery: opportunities for process diagnostics; measuring the impact of suspension on the process enactment environment during process evolution; user perceptions, motivations and implications on ERP usage: an Indian higher education context; a decision support system based on RCM approach to define maintenance strategies; towards more flexible enterprise information systems; a proposal of a process model for requirements elicitation in information mining projects; a financial perspective on improving ICT service delivery: a case at the Belgian railways; looking for a fit for purpose: business process maturity models from a user's perspective; enterprise information systems security: a case study in the banking sector; and implementing behavior driven development in an open source ERP.		[No author name available]	Lecture Notes in Business Information Processing	The proceedings contain 25 papers. The topics discussed include: process innovation: redesigning an enterprise backbone system; sub-process discovery: opportunities for process diagnostics; measuring the impact of suspension on the process enactment environment during process evolution; user perceptions, motivations and implications on ERP usage: an Indian higher education context; a decision support system based on RCM approach to define maintenance strategies; towards more flexible enterprise information systems; a proposal of a process model for requirements elicitation in information mining projects; a financial perspective on improving ICT service delivery: a case at the Belgian railways; looking for a fit for purpose: business process maturity models from a user's perspective; enterprise information systems security: a case study in the banking sector; and implementing behavior driven development in an open source ERP.				Excluded	Excluded	new_screen			2						
247	Behave	2017 8th International Conference on Information and Communication Systems, ICICS 2017	The proceedings contain 65 papers. The topics discussed include: using behavior-driven development with hardware-software co-design for autonomous load management; dealing with decisional natural language why-question in business intelligence; sentence-aligned parallel corpus Amazigh-English; corpora for sentiment analysis of Arabic text in social media; ALIF editor for generating Arabic normalized lexicons; a brain friendly tool to facilitate research-teaching nexus: mind maps; adaptive e-learning web-based English tutor using data mining techniques and Jackson's learning styles; and towards a model-based approach for developing and QA of online business processes.		[No author name available]	2017 8th International Conference on Information and Communication Systems, ICICS 2017	The proceedings contain 65 papers. The topics discussed include: using behavior-driven development with hardware-software co-design for autonomous load management; dealing with decisional natural language why-question in business intelligence; sentence-aligned parallel corpus Amazigh-English; corpora for sentiment analysis of Arabic text in social media; ALIF editor for generating Arabic normalized lexicons; a brain friendly tool to facilitate research-teaching nexus: mind maps; adaptive e-learning web-based English tutor using data mining techniques and Jackson's learning styles; and towards a model-based approach for developing and QA of online business processes.				Excluded	Excluded	new_screen			2						
248	Behave	4th International Conference on Computer Science and Computational Intelligence: Enabling Collaboration to Escalate Impact of Research Results for Society, ICCSCI 2019	The proceedings contain 87 papers. The topics discussed include: comparative performance of filtering methods for reducing noise in ischemic posterior Fossa CT images; gender demography classification on instagram based on user's comments section; automotive security with authorization and tracking via gps; combination of test-driven development and behavior-driven development for improving backend testing performance; modeling of the acute lymphoblastic leukemia detection based on the principal object characteristics of the color image; music recommender system based on genre using convolutional recurrent neural networks; MobileNet convolutional neural networks and support vector machines for palmprint recognition; MVC architecture: a comparative study between laravel framework and slim framework in freelancer project monitoring system web based; and recommendation of scheduling tourism routes using tabu search method (case study Bandung).		[No author name available]	Procedia Computer Science	The proceedings contain 87 papers. The topics discussed include: comparative performance of filtering methods for reducing noise in ischemic posterior Fossa CT images; gender demography classification on instagram based on user's comments section; automotive security with authorization and tracking via gps; combination of test-driven development and behavior-driven development for improving backend testing performance; modeling of the acute lymphoblastic leukemia detection based on the principal object characteristics of the color image; music recommender system based on genre using convolutional recurrent neural networks; MobileNet convolutional neural networks and support vector machines for palmprint recognition; MVC architecture: a comparative study between laravel framework and slim framework in freelancer project monitoring system web based; and recommendation of scheduling tourism routes using tabu search method (case study Bandung).				Excluded	Excluded	new_screen			2						
249	Behave	CLOSER 2016 - Proceedings of the 6th International Conference on Cloud Computing and Services Science	The proceedings contain 88 papers. The topics discussed include: native cloud applications; SemNaaS: semantic web for network as a service; design time validation for the correct execution of BPMN collaborations; evidence collection in cloud provider chains; decision support system for adoption of cloud-based services; towards auditing of cloud provider chains using CloudTrust protocol; testing of web services using behavior-driven development; from architecture modeling to application provisioning for the cloud by combining UML and TOSCA; a scalable architecture for distributed OSGi in the cloud; LADY: dynamic resolution of assemblies for extensible and distributed .NET applications; and toward cloud-based classification and annotation support.		[No author name available]	CLOSER 2016 - Proceedings of the 6th International Conference on Cloud Computing and Services Science	The proceedings contain 88 papers. The topics discussed include: native cloud applications; SemNaaS: semantic web for network as a service; design time validation for the correct execution of BPMN collaborations; evidence collection in cloud provider chains; decision support system for adoption of cloud-based services; towards auditing of cloud provider chains using CloudTrust protocol; testing of web services using behavior-driven development; from architecture modeling to application provisioning for the cloud by combining UML and TOSCA; a scalable architecture for distributed OSGi in the cloud; LADY: dynamic resolution of assemblies for extensible and distributed .NET applications; and toward cloud-based classification and annotation support.				Excluded	Excluded	new_screen			2						
250	Behave	A Service Framework for Parallel Test Execution on a Developer's Local Development Workstation	The proliferation of distributed microservices driven by service oriented architecture and the effectiveness of agile software development processes such as Test Driven Development (TDD), Behavior Driven Development (BDD), inspired by extreme programming (XP), have driven the challenging necessity to receive prompt test feedback during software development iteratively. Although few test frameworks can execute unit tests in memory in parallel, no existing test frameworks can reliably perform parallel execution for the tests that rely on file system access, database fixtures and network communication. Isolated test execution environment with dedicated resources is a prerequisite to address these challenges. No previous research addresses this need to run groups of tests in parallel on the same development host. In this paper, to cut down test execution time, we present a service framework for parallel tests execution in a developer's containerized sandbox using operating system level virtualization provided by Docker, the new hot driver for Platform as a Service (PaaS).	agile development; cloud testing; Docker; parallel testing; test execution environment	Rahman, Mazedur; Chen, Zehua; Gao, Jerry	Proceedings of the 2015 IEEE Symposium on Service-Oriented System Engineering	The proliferation of distributed microservices driven by service oriented architecture and the effectiveness of agile software development processes such as Test Driven Development (TDD), Behavior Driven Development (BDD), inspired by extreme programming (XP), have driven the challenging necessity to receive prompt test feedback during software development iteratively. Although few test frameworks can execute unit tests in memory in parallel, no existing test frameworks can reliably perform parallel execution for the tests that rely on file system access, database fixtures and network communication. Isolated test execution environment with dedicated resources is a prerequisite to address these challenges. No previous research addresses this need to run groups of tests in parallel on the same development host. In this paper, to cut down test execution time, we present a service framework for parallel tests execution in a developer's containerized sandbox using operating system level virtualization provided by Docker, the new hot driver for Platform as a Service (PaaS).				Excluded	Excluded	new_screen			2						
251	Behave	A Systematic Literature Review on Quality Criteria for Agile Requirements Specifications	The quality of requirements is typically considered as an important factor for the quality of the end product. For traditional up-front requirements specifications, a number of standards have been defined on what constitutes good quality : Requirements should be complete, unambiguous, specific, time-bounded, consistent, etc. For agile requirements specifications, no new standards have been defined yet, and it is not clear yet whether traditional quality criteria still apply. To investigate what quality criteria for assessing the correctness of written agile requirements exist, we have conducted a systematic literature review. The review resulted in a list of 16 selected papers on this topic. These selected papers describe 28 different quality criteria for agile requirements specifications. We categorize and analyze these criteria and compare them with those from traditional requirements engineering. We discuss findings from the 16 papers in the form of recommendations for practitioners on quality assessment of agile requirements. At the same time, we indicate the open points in the form of a research agenda for researchers working on this topic .	Systematic literature review; Agile requirement; Correctness; Just-in-time; Quality assessment; Quality criteria	Heck, Petra; Zaidman, Andy	Software Quality Journal	The quality of requirements is typically considered as an important factor for the quality of the end product. For traditional up-front requirements specifications, a number of standards have been defined on what constitutes good quality : Requirements should be complete, unambiguous, specific, time-bounded, consistent, etc. For agile requirements specifications, no new standards have been defined yet, and it is not clear yet whether traditional quality criteria still apply. To investigate what quality criteria for assessing the correctness of written agile requirements exist, we have conducted a systematic literature review. The review resulted in a list of 16 selected papers on this topic. These selected papers describe 28 different quality criteria for agile requirements specifications. We categorize and analyze these criteria and compare them with those from traditional requirements engineering. We discuss findings from the 16 papers in the form of recommendations for practitioners on quality assessment of agile requirements. At the same time, we indicate the open points in the form of a research agenda for researchers working on this topic .				Excluded	Excluded	new_screen			2						
252	Behave	The Rails 3 Way	The Rails 3 Way is a comprehensive resource that digs into the new features in Rails 3 and perhaps more importantly, the rationale behind them.Yehuda Katz, Rails Core The Bible for Ruby on Rails Application Development Ruby on Rails strips complexity from the development process, enabling professional developers to focus on what matters most: delivering business value via clean and maintainable code. The Rails 3 Way is the only comprehensive, authoritative guide to delivering production-quality code with Rails 3. Pioneering Rails expert Obie Fernandez and a team of leading experts illuminate the entire Rails 3 API, along with the idioms, design approaches, and libraries that make developing applications with Rails so powerful. Drawing on their unsurpassed experience and track record, they address the real challenges development teams face, showing how to use Rails 3 to maximize your productivity. Using numerous detailed code examples, the author systematically covers Rails 3 key capabilities and subsystems, making this book a reference that you will turn to again and again. He presents advanced Rails programming techniques that have been proven effective in day-to-day usage on dozens of production Rails systems and offers important insights into behavior-driven development and production considerations such as scalability. Dive deep into the Rails 3 codebase and discover why Rails is designed the way it isand how to make it do what you want it to do. This book will help you Learn whats new in Rails 3 Increase your productivity as a web application developer Realize the overall joy in programming with Rails Leverage Rails powerful capabilities for building REST-compliant APIs Drive implementation and protect long-term maintainability using RSpec Design and manipulate your domain layer using Active Record Understand and program complex program flows using Action Controller Master sophisticated URL routing concepts Use Ajax techniques via Rails 3 support for unobtrusive JavaScript Learn to extend Rails with popular gems and plugins, and how to write your own Extend Rails with the best third-party plug-ins and write your own Integrate email services into your applications with Action Mailer Improve application responsiveness with background processing Create your own non-Active Record domain classes using Active Model Master Rails utility classes and extensions in Active Support		Fernandez, Obie		The Rails 3 Way is a comprehensive resource that digs into the new features in Rails 3 and perhaps more importantly, the rationale behind them.Yehuda Katz, Rails Core The Bible for Ruby on Rails Application Development Ruby on Rails strips complexity from the development process, enabling professional developers to focus on what matters most: delivering business value via clean and maintainable code. The Rails 3 Way is the only comprehensive, authoritative guide to delivering production-quality code with Rails 3. Pioneering Rails expert Obie Fernandez and a team of leading experts illuminate the entire Rails 3 API, along with the idioms, design approaches, and libraries that make developing applications with Rails so powerful. Drawing on their unsurpassed experience and track record, they address the real challenges development teams face, showing how to use Rails 3 to maximize your productivity. Using numerous detailed code examples, the author systematically covers Rails 3 key capabilities and subsystems, making this book a reference that you will turn to again and again. He presents advanced Rails programming techniques that have been proven effective in day-to-day usage on dozens of production Rails systems and offers important insights into behavior-driven development and production considerations such as scalability. Dive deep into the Rails 3 codebase and discover why Rails is designed the way it isand how to make it do what you want it to do. This book will help you Learn whats new in Rails 3 Increase your productivity as a web application developer Realize the overall joy in programming with Rails Leverage Rails powerful capabilities for building REST-compliant APIs Drive implementation and protect long-term maintainability using RSpec Design and manipulate your domain layer using Active Record Understand and program complex program flows using Action Controller Master sophisticated URL routing concepts Use Ajax techniques via Rails 3 support for unobtrusive JavaScript Learn to extend Rails with popular gems and plugins, and how to write your own Extend Rails with the best third-party plug-ins and write your own Integrate email services into your applications with Action Mailer Improve application responsiveness with background processing Create your own non-Active Record domain classes using Active Model Master Rails utility classes and extensions in Active Support				Excluded	Excluded	new_screen			2						
253	Behave	Using executable specification and regression testing for broadcast mechanism of visual programming language on smartphones	The rapid advancement of mobile computing technology and the rising usage of mobile apps made our daily life more productive. The mobile app should operate all the time bug-free in order to improve user satisfaction and offers great business value to the end user. At the same time, smartphones are full of special features that make testing of apps more challenging. Actually, the quality is a must for successful applications and it cannot be achieved without testing and verification. In this paper, we present the behavior driven development methodology and Cucumber framework to automate regression testing for Android apps. Particularly, the proposed methods use the visual programming language for smartphones (Catrobat) as a reference. The Catrobat program scripts communicate via a broadcast mechanism. The objective is to test the broadcast mechanism from different angles and track regression errors as well as specify and diagnose bugs with the help of executable specifications. The results show that the methods are able to effectively reveal deficiencies in the broadcast mechanism, and ensure that the app meets end users' expectations and needs. © 2018, International Association of Online Engineering.		Ali Z., Ayyal Awwad A.M., Slany W.	International Journal of Interactive Mobile Technologies	The rapid advancement of mobile computing technology and the rising usage of mobile apps made our daily life more productive. The mobile app should operate all the time bug-free in order to improve user satisfaction and offers great business value to the end user. At the same time, smartphones are full of special features that make testing of apps more challenging. Actually, the quality is a must for successful applications and it cannot be achieved without testing and verification. In this paper, we present the behavior driven development methodology and Cucumber framework to automate regression testing for Android apps. Particularly, the proposed methods use the visual programming language for smartphones (Catrobat) as a reference. The Catrobat program scripts communicate via a broadcast mechanism. The objective is to test the broadcast mechanism from different angles and track regression errors as well as specify and diagnose bugs with the help of executable specifications. The results show that the methods are able to effectively reveal deficiencies in the broadcast mechanism, and ensure that the app meets end users' expectations and needs. © 2018, International Association of Online Engineering.				Included	Included	new_screen			2						
254	Behave	Reconciling requirements and continuous integration in an agile context	The RE'18 theme is: 'Crossing Boundaries and Increasing Impact'. In this context we propose a tutorial on Requirements in an Agile context that aims at exploring the boundaries between requirements, specifications, stories, scenarios and tests. It follows the recent work started in the RE community about agility, from a practical point of view. © 2018 IEEE.		Mosser S., Bruel J.-M.	Proceedings - 2018 IEEE 26th International Requirements Engineering Conference, RE 2018	The RE'18 theme is: 'Crossing Boundaries and Increasing Impact'. In this context we propose a tutorial on Requirements in an Agile context that aims at exploring the boundaries between requirements, specifications, stories, scenarios and tests. It follows the recent work started in the RE community about agility, from a practical point of view. © 2018 IEEE.				Excluded	Excluded	new_screen			2						
255	Behave	The impact of tailoring criteria on agile practices adoption: A survey with novice agile practitioners in Brazil	The software development industry adopts agile methods in different ways by considering contextual requirements. To fulfill organizational needs, adoption strategies consider agile methods tailoring. However, tailoring according to the context of the organization remains a problem to be solved. Literature on criteria for adopting software development methods exists, but not specifically for agile methods. Given this scenario, the following research question arises: what is the impact of software method tailoring criteria on the adoption of agile practices? To answer this question, we conducted a survey among agile practitioners in Brazil to gather data about importance of the tailoring criteria and agile practices adopted. A model for agile practices adoption based on the tailoring criteria is proposed using the results of the survey with a majority of novice agile practitioners. The proposed model was validated using PLS-SEM (partial least squares structural equation modeling) and the survey data. Results show that adoption of agile practices was influenced by criteria such as external environment, previous knowledge and internal environment. Results also indicate that organizations tend to use hybrid/custom software methods and select agile practices according to their needs.	Agile method tailoring, Tailoring criteria, Agile practices selection, Agile practices adoption, PLS-SEM, Software method tailoring	Campanelli, Amadeu Silveira; Camilo, Ronaldo Darwich; Parreiras, Fernando Silva	Journal of Systems and Software	The software development industry adopts agile methods in different ways by considering contextual requirements. To fulfill organizational needs, adoption strategies consider agile methods tailoring. However, tailoring according to the context of the organization remains a problem to be solved. Literature on criteria for adopting software development methods exists, but not specifically for agile methods. Given this scenario, the following research question arises: what is the impact of software method tailoring criteria on the adoption of agile practices? To answer this question, we conducted a survey among agile practitioners in Brazil to gather data about importance of the tailoring criteria and agile practices adopted. A model for agile practices adoption based on the tailoring criteria is proposed using the results of the survey with a majority of novice agile practitioners. The proposed model was validated using PLS-SEM (partial least squares structural equation modeling) and the survey data. Results show that adoption of agile practices was influenced by criteria such as external environment, previous knowledge and internal environment. Results also indicate that organizations tend to use hybrid/custom software methods and select agile practices according to their needs.				Excluded	Excluded	new_screen			2						
256	Behave	Rules of thumb to increase the software quality through testing	The software maintenance typically requires 40-80% of the overall project costs, and this considerable variability mostly depends on the software internal quality: the more the software is designed and implemented to constantly welcome new changes, the lower will be the maintenance costs. The internal quality is typically enforced through testing, which in turn also affects the development and maintenance costs. This is the reason why testing methodologies have become a major concern for any company that builds - or is involved in building - software. Although there is no testing approach that suits all contexts, we infer some general guidelines learned during the Development of the Italian Single-dish COntrol System (DISCOS), which is a project aimed at producing the control software for the three INAF radio telescopes (the Medicina and Noto dishes, and the newly-built SRT). These guidelines concern both the development and the maintenance phases, and their ultimate goal is to maximize the DISCOS software quality through a Behavior-Driven Development (BDD) workflow beside a continuous delivery pipeline. We consider different topics and patterns; they involve the proper apportion of the tests (from end-to-end to low-level tests), the choice between hardware simulators and mockers, why and how to apply TDD and the dependency injection to increase the test coverage, the emerging technologies available for test isolation, bug fixing, how to protect the system from the external resources changes (firmware updating, hardware substitution, etc.) and, eventually, how to accomplish BDD starting from functional tests and going through integration and unit tests. We discuss pros and cons of each solution and point out the motivations of our choices either as a general rule or narrowed in the context of the DISCOS project. © COPYRIGHT SPIE. Downloading of the abstract is permitted for personal use only.		Buttu M., Bartolini M., Migoni C., Orlati A., Poppi S., Righini S.	Proceedings of SPIE - The International Society for Optical Engineering	The software maintenance typically requires 40-80% of the overall project costs, and this considerable variability mostly depends on the software internal quality: the more the software is designed and implemented to constantly welcome new changes, the lower will be the maintenance costs. The internal quality is typically enforced through testing, which in turn also affects the development and maintenance costs. This is the reason why testing methodologies have become a major concern for any company that builds - or is involved in building - software. Although there is no testing approach that suits all contexts, we infer some general guidelines learned during the Development of the Italian Single-dish COntrol System (DISCOS), which is a project aimed at producing the control software for the three INAF radio telescopes (the Medicina and Noto dishes, and the newly-built SRT). These guidelines concern both the development and the maintenance phases, and their ultimate goal is to maximize the DISCOS software quality through a Behavior-Driven Development (BDD) workflow beside a continuous delivery pipeline. We consider different topics and patterns; they involve the proper apportion of the tests (from end-to-end to low-level tests), the choice between hardware simulators and mockers, why and how to apply TDD and the dependency injection to increase the test coverage, the emerging technologies available for test isolation, bug fixing, how to protect the system from the external resources changes (firmware updating, hardware substitution, etc.) and, eventually, how to accomplish BDD starting from functional tests and going through integration and unit tests. We discuss pros and cons of each solution and point out the motivations of our choices either as a general rule or narrowed in the context of the DISCOS project. © COPYRIGHT SPIE. Downloading of the abstract is permitted for personal use only.				Excluded	Excluded	new_screen			2						
257	Behave	Automated testing framework development based on social interaction and communication principles	The speed of development of the IT industry as well as the computational power which are increasing exponentially, create great competitiveness in the process of development but also in the launching of software products on the market. Automated testing comes to help with these challenges by trying to increase the speed of development by offering fast feedback and trustworthy quality by means of repeated runs of the implemented tests. This isn't a problem just on a technical level, but also on a social level, especially in the area of communication and understanding the requirements of the client. This work presents the implementation of an automated testing framework which also addresses the social problems. BDD or “Behavior Driven Development” includes an approach which would like to line up the area of client requests to the technical area, offering a uniform platform of collaboration and development. The implementation of this principle is applied in an MVP (Minimum Viable Product) type project which is meant to demonstrate the technical solution which may draw together, both socially and communication wise, the business teams and the technical implementation teams.	testing process;BDD;automated testing;Gherkin language	A. Contan; L. Miclea; C. Dehelean	2017 14th International Conference on Engineering of Modern Electric Systems (EMES)	The speed of development of the IT industry as well as the computational power which are increasing exponentially, create great competitiveness in the process of development but also in the launching of software products on the market. Automated testing comes to help with these challenges by trying to increase the speed of development by offering fast feedback and trustworthy quality by means of repeated runs of the implemented tests. This isn't a problem just on a technical level, but also on a social level, especially in the area of communication and understanding the requirements of the client. This work presents the implementation of an automated testing framework which also addresses the social problems. BDD or “Behavior Driven Development” includes an approach which would like to line up the area of client requests to the technical area, offering a uniform platform of collaboration and development. The implementation of this principle is applied in an MVP (Minimum Viable Product) type project which is meant to demonstrate the technical solution which may draw together, both socially and communication wise, the business teams and the technical implementation teams.				Included	Included	new_screen			2						
258	Behave	Enabling faith-inspired education on the sustainable development goals through e-learning	The Sustainable Development Goals (SDGs) are composed from a variety of universal goals. They come with a heavy load on ethical demands while they do not provide any ethical guidance. One possibility to fill this void is to teach the SDGs with a faith-based narrative. Grown out of a workshop by Bread for World we will present our approach of Ownership-inspired Behavior-driven development, which is a strategy for an e-learning governance to introduce an Android app to support e-learning on the SDGs in theological education in remote areas in the Global South. Our goal is to develop a governance strategy for higher theological education to fill the SDGs with a faith-based narrative by using e-learning technology. Based on the staircase curriculum for the education of future church leaders developed by the British FBO Relay Trust we introduce the theoretical framework for this goal, which makes the transfer from a hierarchical governance structure found in many African societies into a dynamic e-learning framework. © Springer International Publishing AG 2018.		Gottschalk J., Winther-Nielsen N.	World Sustainability Series	The Sustainable Development Goals (SDGs) are composed from a variety of universal goals. They come with a heavy load on ethical demands while they do not provide any ethical guidance. One possibility to fill this void is to teach the SDGs with a faith-based narrative. Grown out of a workshop by Bread for World we will present our approach of Ownership-inspired Behavior-driven development, which is a strategy for an e-learning governance to introduce an Android app to support e-learning on the SDGs in theological education in remote areas in the Global South. Our goal is to develop a governance strategy for higher theological education to fill the SDGs with a faith-based narrative by using e-learning technology. Based on the staircase curriculum for the education of future church leaders developed by the British FBO Relay Trust we introduce the theoretical framework for this goal, which makes the transfer from a hierarchical governance structure found in many African societies into a dynamic e-learning framework. © Springer International Publishing AG 2018.				Excluded	Excluded	new_screen			2						
259	Behave	Using BDD and SBVR to Refine Business Goals into an Event-B Model: A Research Idea	The transition from a requirements document to a formal specification in Event-B is usually manual and ad-hoc. In order to bridge this gap, we propose a method based on Behavior-Driven Development, an agile approach, and that uses a structured natural language conformant to the formalism of the Semantics of Business Vocabulary and Business Rules (SBVR) standard. This method will successively refine a list of high-level business goals into an Event-B model using transformations. In this paper we present our research idea, describing the steps of this method and showing an example based on the Train System scenario described by Abrial.	BDD; event-B; formal methods; method; requirements; SBVR	Siqueira, Fabio Levy; de Sousa, Thiago C.; Silva, Paulo S. Muniz	Proceedings of the 5th International FME Workshop on Formal Methods in Software Engineering	The transition from a requirements document to a formal specification in Event-B is usually manual and ad-hoc. In order to bridge this gap, we propose a method based on Behavior-Driven Development, an agile approach, and that uses a structured natural language conformant to the formalism of the Semantics of Business Vocabulary and Business Rules (SBVR) standard. This method will successively refine a list of high-level business goals into an Event-B model using transformations. In this paper we present our research idea, describing the steps of this method and showing an example based on the Train System scenario described by Abrial.				Included	Included	new_screen			2						
260	Behave	Using behaviour-driven development with hardware-software co-design for autonomous load management	The typical approach to designing embedded systems manages the specification and design of the hardware and software separately. HW/SW Co-design is used, in embedded computing, to allow the hardware and the software to be designed and implemented together and make sure that the non-functional properties are met. Behavior-driven development (BDD) is an agile software development approach that spurs collaboration of project stakeholders to ensure the right software is developed to meet their needs. BDD describes the behavior of the system as executable user stories and focuses on how the system behaves for users interact with the system. In this paper, we introduce an approach that integrates BDD with HW/SW Co-design. The approach provides the ability to describe the behavior of the software as executable user stories in a HW/SW Co-design environment. The approach is evaluated using a renewable energy project in collaboration with a private company in Canada to build a system for autonomous load management of self-forming renewable energy nanogrids.	Embedded Systems;Behaviour-Driven Development;Hardware-Software Co-Design;Test-driven development;Nanogrid systems;Agile software	M. Alhaj; G. Arbez; L. Peyton	2017 8th International Conference on Information and Communication Systems (ICICS)	The typical approach to designing embedded systems manages the specification and design of the hardware and software separately. HW/SW Co-design is used, in embedded computing, to allow the hardware and the software to be designed and implemented together and make sure that the non-functional properties are met. Behavior-driven development (BDD) is an agile software development approach that spurs collaboration of project stakeholders to ensure the right software is developed to meet their needs. BDD describes the behavior of the system as executable user stories and focuses on how the system behaves for users interact with the system. In this paper, we introduce an approach that integrates BDD with HW/SW Co-design. The approach provides the ability to describe the behavior of the software as executable user stories in a HW/SW Co-design environment. The approach is evaluated using a renewable energy project in collaboration with a private company in Canada to build a system for autonomous load management of self-forming renewable energy nanogrids.				Included	Included	new_screen			2						
261	Behave	Towards automated requirements checking throughout development processes of interactive systems	The user-centered development process of interactive systems is iterative and, during multiple iterations, users have the opportunity to bring new requirements that are very likely to have an impact, not only in future development, but also affect previously developed artifacts. Manual testing of all artifacts when new requirements are introduced can be cumbersome and time consuming. For that, we need flexible methods to ensure continuous consistency and accuracy among the various artifacts employed to build interactive systems. The ultimate goal of this position paper is to briefly present our vision on an approach for automating the requirements assessment using a Behavior-Driven Development perspective. Thereby, automated tests can run early in the design process, providing a continuous quality assurance of requirements, and helping clients and teams to identify potential problems and inconsistencies before commitments with software implementation.		Silva T.R., Winckler M.A.A.	CEUR Workshop Proceedings	The user-centered development process of interactive systems is iterative and, during multiple iterations, users have the opportunity to bring new requirements that are very likely to have an impact, not only in future development, but also affect previously developed artifacts. Manual testing of all artifacts when new requirements are introduced can be cumbersome and time consuming. For that, we need flexible methods to ensure continuous consistency and accuracy among the various artifacts employed to build interactive systems. The ultimate goal of this position paper is to briefly present our vision on an approach for automating the requirements assessment using a Behavior-Driven Development perspective. Thereby, automated tests can run early in the design process, providing a continuous quality assurance of requirements, and helping clients and teams to identify potential problems and inconsistencies before commitments with software implementation.				Excluded	Excluded	new_screen			2						
262	Behave	Automated Test Input Generation via Model Inference Based on User Story and Acceptance Criteria for Mobile Application Development	"There has been observed explosive growth in the development of mobile applications (apps) for Android and iOS operating systems, which has led to the direct impact towards mobile app development. In order to design and propose quality-oriented apps, it is the primary responsibility of developers to devote time and sufficient efforts towards testing to make the apps bug-free and operational in the hands of end-users without any hiccup. Manual testing procedures take a prolonged amount of time in writing test cases, and in some cases, the full testing requirements are not met. Besides, the insufficient knowledge of tester also impacts the overall quality and bug-free apps. To overcome the obstacles of testing, we propose a new testing methodology cum tool called ""AgileUATM"" which works primarily towards white-box and black-box testing. To evaluate the validity of the proposed tool, we put the tool in a real-time operational environment concerning mobile test apps. By using this tool, all the acceptance criteria are determined via user stories. The testers/developers specify requirements with formal specifications based on programs properties, predicates, invariants, and constraints. The results show that the proposed tool generated effective and accurate test cases, test input. Meanwhile, expected output was also generated in a unified fashion from the user stories to meet acceptance criteria. The proposed solution also reduced the development time to identify test data as compared to manual Behavior-Driven Development (BDD) methodologies. This tool can support the developers to get a better idea about the required tests and able to translate the customer's natural languages to computer languages as well. This paper fulfills an approach to suitably test mobile application development. © 2020 World Scientific Publishing Company."		Nguyen D.-M., Huynh Q.-T., Ha N.-H., Nguyen T.-H.	International Journal of Software Engineering and Knowledge Engineering	"There has been observed explosive growth in the development of mobile applications (apps) for Android and iOS operating systems, which has led to the direct impact towards mobile app development. In order to design and propose quality-oriented apps, it is the primary responsibility of developers to devote time and sufficient efforts towards testing to make the apps bug-free and operational in the hands of end-users without any hiccup. Manual testing procedures take a prolonged amount of time in writing test cases, and in some cases, the full testing requirements are not met. Besides, the insufficient knowledge of tester also impacts the overall quality and bug-free apps. To overcome the obstacles of testing, we propose a new testing methodology cum tool called ""AgileUATM"" which works primarily towards white-box and black-box testing. To evaluate the validity of the proposed tool, we put the tool in a real-time operational environment concerning mobile test apps. By using this tool, all the acceptance criteria are determined via user stories. The testers/developers specify requirements with formal specifications based on programs properties, predicates, invariants, and constraints. The results show that the proposed tool generated effective and accurate test cases, test input. Meanwhile, expected output was also generated in a unified fashion from the user stories to meet acceptance criteria. The proposed solution also reduced the development time to identify test data as compared to manual Behavior-Driven Development (BDD) methodologies. This tool can support the developers to get a better idea about the required tests and able to translate the customer's natural languages to computer languages as well. This paper fulfills an approach to suitably test mobile application development. © 2020 World Scientific Publishing Company."				Included	Included	new_screen			2						
263	Behave	Security and privacy behavior definition for behavior driven development	There is an issue when security measures are implemented and tested while using agile software development techniques such as Behavior Driven Development (BDD). We need to define the necessary levels of security and the privacy behaviors and acceptance criteria for the BDD. A method for defining the acceptance criteria (BehaveSafe) by creating a threat and countermeasure graph called theT&C graph is proposed in this paper. We have estimated the efficiency of our method with a web based system. © Springer International Publishing Switzerland 2014.		Okubo T., Kakizaki Y., Kobashi T., Washizaki H., Ogata S., Kaiya H., Yoshioka N.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	There is an issue when security measures are implemented and tested while using agile software development techniques such as Behavior Driven Development (BDD). We need to define the necessary levels of security and the privacy behaviors and acceptance criteria for the BDD. A method for defining the acceptance criteria (BehaveSafe) by creating a threat and countermeasure graph called theT&C graph is proposed in this paper. We have estimated the efficiency of our method with a web based system. © Springer International Publishing Switzerland 2014.				Included	Included	new_screen			2						
264	Behave	Effort Estimation using Bayesian Networks for Agile Development	This article proposes an automatic method to estimate the effort of development based on narrative texts. Narrative used the agile method. We propose techniques of symbolic analysis of natural language were used for extraction of verbs and nouns, and verbal reduction (verbs in infinitive), and the standardization of keywords through synonyms. For the machine learning was used if the naive Bayesian classifier model. Apply and test the model in real environment that used the narratives in the Portuguese language in the form of BDD (Behavior Driven Development). In these tests, obtaining an accuracy of 83% in the estimates of the story points.	Bayesian network model;Agile;Estimation	C. Ratke; H. H. Hoffmann; T. Gaspar; P. E. Floriani	2019 2nd International Conference on Computer Applications & Information Security (ICCAIS)	This article proposes an automatic method to estimate the effort of development based on narrative texts. Narrative used the agile method. We propose techniques of symbolic analysis of natural language were used for extraction of verbs and nouns, and verbal reduction (verbs in infinitive), and the standardization of keywords through synonyms. For the machine learning was used if the naive Bayesian classifier model. Apply and test the model in real environment that used the narratives in the Portuguese language in the form of BDD (Behavior Driven Development). In these tests, obtaining an accuracy of 83% in the estimates of the story points.				Excluded	Excluded	new_screen			2						
265	Behave	Test-Driven Java Development - Second Edition: Invoke TDD Principles for End-to-End Application Development	This book will teach the concepts of test driven development in Java so you can build clean, maintainable and robust code Key Features Explore the most popular TDD tools and frameworks and become more proficient in building applicationsCreate applications with better code design, fewer bugs, and higher test coverage, enabling you to get them to market quickly Implement test-driven programming methods into your development workflows Book Description Test-driven development (TDD) is a development approach that relies on a test-first procedure that emphasizes writing a test before writing the necessary code, and then refactoring the code to optimize it. The value of performing TDD with Java, one of the longest established programming languages, is to improve the productivity of programmers and the maintainability and performance of code, and develop a deeper understanding of the language and how to employ it effectively. Starting with the basics of TDD and understanding why its adoption is beneficial, this book will take you from the first steps of TDD with Java until you are confident enough to embrace the practice in your day-to-day routine. You'll be guided through setting up tools, frameworks, and the environment you need, and we will dive right into hands-on exercises with the goal of mastering one practice, tool, or framework at a time. You'll learn about the Red-Green-Refactor procedure, how to write unit tests, and how to use them as executable documentation. With this book, you'll also discover how to design simple and easily maintainable code, work with mocks, utilize behavior-driven development, refactor old legacy code, and release a half-finished feature to production with feature toggles. You will finish this book with a deep understanding of the test-driven development methodology and the confidence to apply it to application programming with Java. What you will learn Explore the tools and frameworks required for effective TDD development Perform the Red-Green-Refactor process efficiently, the pillar around which all other TDD procedures are based Master effective unit testing in isolation from the rest of your code Design simple and easily maintainable code by implementing different techniques Use mocking frameworks and techniques to easily write and quickly execute tests Develop an application to implement behavior-driven development in conjunction with unit testing Enable and disable features using feature toggles Who This Book Is ForIf you're an experienced Java developer and want to implement more effective methods of programming systems and applications, then this book is for you.		Garcia, Alex; Farcic, Viktor		This book will teach the concepts of test driven development in Java so you can build clean, maintainable and robust code Key Features Explore the most popular TDD tools and frameworks and become more proficient in building applicationsCreate applications with better code design, fewer bugs, and higher test coverage, enabling you to get them to market quickly Implement test-driven programming methods into your development workflows Book Description Test-driven development (TDD) is a development approach that relies on a test-first procedure that emphasizes writing a test before writing the necessary code, and then refactoring the code to optimize it. The value of performing TDD with Java, one of the longest established programming languages, is to improve the productivity of programmers and the maintainability and performance of code, and develop a deeper understanding of the language and how to employ it effectively. Starting with the basics of TDD and understanding why its adoption is beneficial, this book will take you from the first steps of TDD with Java until you are confident enough to embrace the practice in your day-to-day routine. You'll be guided through setting up tools, frameworks, and the environment you need, and we will dive right into hands-on exercises with the goal of mastering one practice, tool, or framework at a time. You'll learn about the Red-Green-Refactor procedure, how to write unit tests, and how to use them as executable documentation. With this book, you'll also discover how to design simple and easily maintainable code, work with mocks, utilize behavior-driven development, refactor old legacy code, and release a half-finished feature to production with feature toggles. You will finish this book with a deep understanding of the test-driven development methodology and the confidence to apply it to application programming with Java. What you will learn Explore the tools and frameworks required for effective TDD development Perform the Red-Green-Refactor process efficiently, the pillar around which all other TDD procedures are based Master effective unit testing in isolation from the rest of your code Design simple and easily maintainable code by implementing different techniques Use mocking frameworks and techniques to easily write and quickly execute tests Develop an application to implement behavior-driven development in conjunction with unit testing Enable and disable features using feature toggles Who This Book Is ForIf you're an experienced Java developer and want to implement more effective methods of programming systems and applications, then this book is for you.				Excluded	Excluded	new_screen			2						
266	Behave	Behavior-driven development using specification by example: An approach for delivering the right software built in right way	"This chapter highlights a crucial problem seen often in software development that is bridging the communication gap between business and Development"" (BDD) methodology supplemented with ""Specification By Example"" approach of delivering the right software that matters. Effective communication has always been a challenge between clients, business stakeholders, project managers, developers, testers and business analysts because a ""ubiquitous"" language that every one can easily understand and use does not exist. Specification By Example serves as that ubiquitous language for all, helps build right software that matters through effective communication. Specifications are written in plain English language using the Gherkin syntax to describe various behaviors of software. BDD tools help write software specification using gherkin language and also create a living documentation that is automatically generated by programming language reflecting the current state of software at any given point of time. © 2016 by IGI Global. All rights reserved."		Menon P.R.	Emerging Innovations in Agile Software Development	"This chapter highlights a crucial problem seen often in software development that is bridging the communication gap between business and Development"" (BDD) methodology supplemented with ""Specification By Example"" approach of delivering the right software that matters. Effective communication has always been a challenge between clients, business stakeholders, project managers, developers, testers and business analysts because a ""ubiquitous"" language that every one can easily understand and use does not exist. Specification By Example serves as that ubiquitous language for all, helps build right software that matters through effective communication. Specifications are written in plain English language using the Gherkin syntax to describe various behaviors of software. BDD tools help write software specification using gherkin language and also create a living documentation that is automatically generated by programming language reflecting the current state of software at any given point of time. © 2016 by IGI Global. All rights reserved."				Excluded	Excluded	new_screen			2						
267	Behave	The Business Transformation Framework and Enterprise Architecture Framework for Managers in Business Innovation: An Applied Holistic Mathematical Model	This journal article proposes a cross-business domain applied holistic mathematical model (AHMM) that is the result of a lifetime long research on business transformations, applied mathematics, software modelling, business engineering, financial analysis, and global enterprise architecture. This ultimate research is based on an authentic and proprietary mixed research method that is supported by an underlining mainly qualitative holistic reasoning model module. The proposed AHMM formalism attempts to mimic some functions of the human brain, which uses empirical processes that are mainly based on the beam-search, like heuristic decision-making process. The AHMM can be used to implement a decision-making system or an expert system that can integrate in the enterprise’s business, information and communication technology environments. The AHMM uses a behaviour driven development environment or a natural language environment that can be easily adopted by the project’s development teams. The AHMM offers a high level implementation environment that can be used by any team member without any prior computer sciences qualification. The AHMM can be used also to model enterprise architecture (EA) blueprints, business transformation projects, or knowledge management systems; it is supported by many real-life cases of various business domains. The uniqueness of this research is that the AHMM promotes a holistic unbundling process, the alignment of various EA standards and transformation strategies to support business transformation projects. © 2021 IGI Global. All rights reserved.		Trad A.	International Journal of Service Science, Management, Engineering, and Technology	This journal article proposes a cross-business domain applied holistic mathematical model (AHMM) that is the result of a lifetime long research on business transformations, applied mathematics, software modelling, business engineering, financial analysis, and global enterprise architecture. This ultimate research is based on an authentic and proprietary mixed research method that is supported by an underlining mainly qualitative holistic reasoning model module. The proposed AHMM formalism attempts to mimic some functions of the human brain, which uses empirical processes that are mainly based on the beam-search, like heuristic decision-making process. The AHMM can be used to implement a decision-making system or an expert system that can integrate in the enterprise’s business, information and communication technology environments. The AHMM uses a behaviour driven development environment or a natural language environment that can be easily adopted by the project’s development teams. The AHMM offers a high level implementation environment that can be used by any team member without any prior computer sciences qualification. The AHMM can be used also to model enterprise architecture (EA) blueprints, business transformation projects, or knowledge management systems; it is supported by many real-life cases of various business domains. The uniqueness of this research is that the AHMM promotes a holistic unbundling process, the alignment of various EA standards and transformation strategies to support business transformation projects. © 2021 IGI Global. All rights reserved.				Excluded	Excluded	new_screen			2						
268	Behave	Ontological syntax highlighting	This paper deals with the special type of syntax highlighting which is powered by combination of DEMO methodology (Design & Engineering Methodology for Organizations), BDD technique (Behaviour-Driven Development). Main contribution of this paper is the idea how to highlight business relevant code in IDEs (Integrated Development Environments) and notice a developer about the fact that important part of code base is edited. The proposal of the implementation encounters usage of code coverage technique and user stories derived upon DEMO methodology. © 2018 Author(s).		Matula J., Zacek J.	AIP Conference Proceedings	This paper deals with the special type of syntax highlighting which is powered by combination of DEMO methodology (Design & Engineering Methodology for Organizations), BDD technique (Behaviour-Driven Development). Main contribution of this paper is the idea how to highlight business relevant code in IDEs (Integrated Development Environments) and notice a developer about the fact that important part of code base is edited. The proposal of the implementation encounters usage of code coverage technique and user stories derived upon DEMO methodology. © 2018 Author(s).				Included	Included	new_screen			2						
269	Behave	A History of the Groovy Programming Language	This paper describes the history of the Groovy programming language. At the time of Groovy’s inception, Java was a dominant programming language with a wealth of useful libraries. Despite this, it was perceived by some to be evolving slowing and to have shortcomings for scripting, rapid prototyping and when trying to write minimalistic code. Other languages seemed to be innovating faster than Java and, while overcoming some of Java’s shortcomings, used syntax that was less familiar to Java developers. Integration with Java libraries was also non-optimal. Groovy was created as a complementary language to Java—its dynamic counterpart. It would look and feel like Java but focus on extensibility and rapid innovation. Groovy would borrow ideas from dynamic languages like Ruby, Python and Smalltalk where needed to provide compelling JVM solutions for some of Java’s shortcomings. Groovy supported innovation through its runtime and compile-time metaprogramming capabilities. It supported simple operator overloading, had a flexible grammar and was extensible. These characteristics made it suitable for growing the language to have new commands (verbs) and properties (nouns) specific to a particular domain, a so called Domain Specific Language (DSL). While still intrinsically linked with Java, over time Groovy has evolved from a niche dynamic scripting language into a compelling mainstream language. After many years as a principally dynamically-typed language, a static nature was added to Groovy. Code could be statically type checked or when dynamic features weren’t needed, they could be turned off entirely for Java-like performance. A number of nuances to the static nature came about to support the style of coding used by Groovy developers. Many choices made by Groovy in its design, later appeared in other languages (Swift, C#, Kotlin, Ceylon, PHP, Ruby, Coffeescript, Scala, Frege, TypeScript and Java itself). This includes Groovy’s dangling closure, Groovy builders, null-safe navigation, the Elvis operator, ranges, the spaceship operator, and flow typing. For most languages, we don’t know to what extent Groovy played a part in their choices. We do know that Kotlin took inspiration from Groovy’s dangling closures, builder concept, default it parameter for closures, templates and interpolated strings, null-safe navigation and the Elvis operator. The leadership, governance and sponsorship arrangements of Groovy have evolved over time, but Groovy has always been a successful highly collaborative open source project driven more by the needs of the community than by a vision of a particular company or person.	Closure; Domain Specific Languages; Dynamic typing; Extensibility; Functional programming; Metaprogramming; Object-oriented; Scripting; Static typing	King, Paul	Proc. ACM Program. Lang.	This paper describes the history of the Groovy programming language. At the time of Groovy’s inception, Java was a dominant programming language with a wealth of useful libraries. Despite this, it was perceived by some to be evolving slowing and to have shortcomings for scripting, rapid prototyping and when trying to write minimalistic code. Other languages seemed to be innovating faster than Java and, while overcoming some of Java’s shortcomings, used syntax that was less familiar to Java developers. Integration with Java libraries was also non-optimal. Groovy was created as a complementary language to Java—its dynamic counterpart. It would look and feel like Java but focus on extensibility and rapid innovation. Groovy would borrow ideas from dynamic languages like Ruby, Python and Smalltalk where needed to provide compelling JVM solutions for some of Java’s shortcomings. Groovy supported innovation through its runtime and compile-time metaprogramming capabilities. It supported simple operator overloading, had a flexible grammar and was extensible. These characteristics made it suitable for growing the language to have new commands (verbs) and properties (nouns) specific to a particular domain, a so called Domain Specific Language (DSL). While still intrinsically linked with Java, over time Groovy has evolved from a niche dynamic scripting language into a compelling mainstream language. After many years as a principally dynamically-typed language, a static nature was added to Groovy. Code could be statically type checked or when dynamic features weren’t needed, they could be turned off entirely for Java-like performance. A number of nuances to the static nature came about to support the style of coding used by Groovy developers. Many choices made by Groovy in its design, later appeared in other languages (Swift, C#, Kotlin, Ceylon, PHP, Ruby, Coffeescript, Scala, Frege, TypeScript and Java itself). This includes Groovy’s dangling closure, Groovy builders, null-safe navigation, the Elvis operator, ranges, the spaceship operator, and flow typing. For most languages, we don’t know to what extent Groovy played a part in their choices. We do know that Kotlin took inspiration from Groovy’s dangling closures, builder concept, default it parameter for closures, templates and interpolated strings, null-safe navigation and the Elvis operator. The leadership, governance and sponsorship arrangements of Groovy have evolved over time, but Groovy has always been a successful highly collaborative open source project driven more by the needs of the community than by a vision of a particular company or person.				Excluded	Excluded	new_screen			2						
270	Behave	Integrating behavior driven development and programming by contract	This paper developed a Contracted Behavior Driven Development (CBDD) method that extends and combines the ideas behind Test/Behavior Driven Development (TDD/BDD) and Programming by Contract (PBC) to improve the overall stability and quality of a system. A tool is developed to derive unit tests automatically by analyzing human written specifications for preconditions and post-conditions when coupled with data definitions. These results will be used to generate code to be run by a unit testing framework before deployment, either as part of a continuous integration environment or by individual developers. The tool will also generate wireframe classes implementing pre and post-conditions within the code and using runtime contract analysis to generate information when an exception occurs, thereby helping to automate verification of bug fixes. © 2013 Springer-Verlag Berlin Heidelberg.		Schoeneman L., Liu J.B.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	This paper developed a Contracted Behavior Driven Development (CBDD) method that extends and combines the ideas behind Test/Behavior Driven Development (TDD/BDD) and Programming by Contract (PBC) to improve the overall stability and quality of a system. A tool is developed to derive unit tests automatically by analyzing human written specifications for preconditions and post-conditions when coupled with data definitions. These results will be used to generate code to be run by a unit testing framework before deployment, either as part of a continuous integration environment or by individual developers. The tool will also generate wireframe classes implementing pre and post-conditions within the code and using runtime contract analysis to generate information when an exception occurs, thereby helping to automate verification of bug fixes. © 2013 Springer-Verlag Berlin Heidelberg.				Included	Included	new_screen			2						
271	Behave	Transit use and the work commute: Analyzing the role of last mile issues	This paper examines the role that public transport last mile problems play in mode choice decisions of commuters, while controlling for trip, built environment, and decision maker related variables. Last-mile problems arise due to lack of adequate connectivity between transit stops and trip origin or termination points. The paper is motivated by previous literature which has pointed out that high-quality public transit needs to consider end-to-end connectivity from trip origins to destinations. In contrast to previous work on transit last mile problems, which has focused on physical distance and sidewalks to transit stops, we consider a wider range of area factors including transit availability, job accessibility, parking costs, the quality of the pedestrian environment and risks to pedestrians from vehicular traffic, and social characteristics such as street-level crime. Using a discrete choice model, our goal is to unpack ways in which such factors contribute to the last-mile problem in home-based work trips, while controlling for these wider range of factors as well as the usual variables such as cost and trip time that inform mode choice. We find that the prevalence of non-domestic violent crimes reduces the odds of using all types of non-motorized alternatives as well as transit that is accessed either by walking or driving. Using compensating variation to measure welfare changes, we show that there are significant benefits that could be brought to transit service users through increasing safety in the transit access trip. By separately controlling for origin and destination transit accessibility, we show that improved destination accessibility significantly boosts transit use to a greater degree than increases in origin level accessibility. These findings argue for improving accessibility and related job densities at employment centers.	Transit use, Last mile problems, Crime, Accessibility, Destination accessibility, Mode choice	Tilahun, Nebiyou; Thakuriah, Piyushimita (Vonu); Li, Moyin; Keita, Yaye	Journal of Transport Geography	This paper examines the role that public transport last mile problems play in mode choice decisions of commuters, while controlling for trip, built environment, and decision maker related variables. Last-mile problems arise due to lack of adequate connectivity between transit stops and trip origin or termination points. The paper is motivated by previous literature which has pointed out that high-quality public transit needs to consider end-to-end connectivity from trip origins to destinations. In contrast to previous work on transit last mile problems, which has focused on physical distance and sidewalks to transit stops, we consider a wider range of area factors including transit availability, job accessibility, parking costs, the quality of the pedestrian environment and risks to pedestrians from vehicular traffic, and social characteristics such as street-level crime. Using a discrete choice model, our goal is to unpack ways in which such factors contribute to the last-mile problem in home-based work trips, while controlling for these wider range of factors as well as the usual variables such as cost and trip time that inform mode choice. We find that the prevalence of non-domestic violent crimes reduces the odds of using all types of non-motorized alternatives as well as transit that is accessed either by walking or driving. Using compensating variation to measure welfare changes, we show that there are significant benefits that could be brought to transit service users through increasing safety in the transit access trip. By separately controlling for origin and destination transit accessibility, we show that improved destination accessibility significantly boosts transit use to a greater degree than increases in origin level accessibility. These findings argue for improving accessibility and related job densities at employment centers.				Excluded	Excluded	new_screen			2						
272	Behave	Extending behavior-driven development for assessing user interface design artifacts	This paper presents a scenario-based approach to specify requirements and tests by extending Behavior-Driven Development (BDD) with the aim of ensuring the consistency between user requirements and user interface design artifacts. The approach has been evaluated by exploiting user requirements specified by a group of potential Product Owners (POs) for a web system to book business trips. Such requirements gave rise to a set of User Stories that have been refined and used to automatically check the consistency of task models, user interface (UI) prototypes, and final UIs of the system. The results have shown our approach was able to identify different types of inconsistencies in the set of analyzed artifacts and consistently keep the semantic traces between them. © 2019 Knowledge Systems Institute Graduate School. All rights reserved.		Silva T.R., Winckler M., Trætteberg H.	Proceedings of the International Conference on Software Engineering and Knowledge Engineering, SEKE	This paper presents a scenario-based approach to specify requirements and tests by extending Behavior-Driven Development (BDD) with the aim of ensuring the consistency between user requirements and user interface design artifacts. The approach has been evaluated by exploiting user requirements specified by a group of potential Product Owners (POs) for a web system to book business trips. Such requirements gave rise to a set of User Stories that have been refined and used to automatically check the consistency of task models, user interface (UI) prototypes, and final UIs of the system. The results have shown our approach was able to identify different types of inconsistencies in the set of analyzed artifacts and consistently keep the semantic traces between them. © 2019 Knowledge Systems Institute Graduate School. All rights reserved.				Included	Included	new_screen			2						
273	Behave	Beast Methodology: An Agile Testing Methodology for Multi-Agent Systems Based on Behaviour Driven Development	This paper presents a testing methodology to apply Behaviour Driven Development (BDD) techniques while developing Multi-Agent Systems (MASs), termed BEhavioural Agent Simple Testing (BEAST) Methodology. This methodology is supported by the open source framework (BEAST Tool) which automatically generates test cases skeletons from BDD scenarios specifications. The developed framework allows the testing of MASs based on JADE or JADEX platforms. In addition, this framework offers a set of configurable Mock Agents with the aim of being able to execute tests while the MAS is under development. The BEAST Methodology presents transparent traceability from user requirements to test cases. Thus, the stakeholders can be aware of the project status. The methodology and the associated tool have been validated in the development of a MAS for fault diagnosis in FTTH (Fiber To The Home) networks. The results have been measured in quantifiable way obtaining a reduction of the tests implementation time.	Behaviour-driven development; Multi-agent systems; Agile; Methodology; Mock-agents; Test	Carrera, Álvaro; Iglesias, Carlos A.; Garijo, Mercedes	Information Systems Frontiers	This paper presents a testing methodology to apply Behaviour Driven Development (BDD) techniques while developing Multi-Agent Systems (MASs), termed BEhavioural Agent Simple Testing (BEAST) Methodology. This methodology is supported by the open source framework (BEAST Tool) which automatically generates test cases skeletons from BDD scenarios specifications. The developed framework allows the testing of MASs based on JADE or JADEX platforms. In addition, this framework offers a set of configurable Mock Agents with the aim of being able to execute tests while the MAS is under development. The BEAST Methodology presents transparent traceability from user requirements to test cases. Thus, the stakeholders can be aware of the project status. The methodology and the associated tool have been validated in the development of a MAS for fault diagnosis in FTTH (Fiber To The Home) networks. The results have been measured in quantifiable way obtaining a reduction of the tests implementation time.				Excluded	Excluded	new_screen			2						
274	Behave	Beast methodology: An agile testing methodology for multi-agent systems based on behaviour driven development	This paper presents a testing methodology to apply Behaviour Driven Development (BDD) techniques while developing Multi-Agent Systems (MASs), termed BEhavioural Agent Simple Testing (BEAST) Methodology. This methodology is supported by the open source framework (BEAST Tool) which automatically generates test cases skeletons from BDD scenarios specifications. The developed framework allows the testing of MASs based on JADE or JADEX platforms. In addition, this framework offers a set of configurable Mock Agents with the aim of being able to execute tests while the MAS is under development. The BEAST Methodology presents transparent traceability from user requirements to test cases. Thus, the stakeholders can be aware of the project status. The methodology and the associated tool have been validated in the development of a MAS for fault diagnosis in FTTH (Fiber To The Home) networks. The results have been measured in quantifiable way obtaining a reduction of the tests implementation time. © 2013 Springer Science+Business Media New York.		Carrera A., Iglesias C.A., Garijo M.	Information Systems Frontiers	This paper presents a testing methodology to apply Behaviour Driven Development (BDD) techniques while developing Multi-Agent Systems (MASs), termed BEhavioural Agent Simple Testing (BEAST) Methodology. This methodology is supported by the open source framework (BEAST Tool) which automatically generates test cases skeletons from BDD scenarios specifications. The developed framework allows the testing of MASs based on JADE or JADEX platforms. In addition, this framework offers a set of configurable Mock Agents with the aim of being able to execute tests while the MAS is under development. The BEAST Methodology presents transparent traceability from user requirements to test cases. Thus, the stakeholders can be aware of the project status. The methodology and the associated tool have been validated in the development of a MAS for fault diagnosis in FTTH (Fiber To The Home) networks. The results have been measured in quantifiable way obtaining a reduction of the tests implementation time. © 2013 Springer Science+Business Media New York.				Included	Included	new_screen			2						
275	Behave	A Study of Test Techniques for Integration with Domain Driven Design	This paper presents an exploratory study on agile techniques for software testing Test-Driven Development and Behaviour-Driven Development for integration with the agile software development technique known as Domain-Driven Design. It also comprises a comparison between both test approaches, enhancing the strengths and weaknesses of each one. To make it feasible the integration proposal, an example of domain using Apache Isis framework was developed. According to the study performed, the possibility of creating an automatic test generator to make it agile the validation of entities attributes of the domain model was noted.	Behaviour-Driven Development; Apache Isis; Domain-Driven Development; Software Test; Test-Driven Development	Santos, Eloisa Cristina Silva; Beder, Delano Medeiros; Penteado, Rosângela A. Dellosso	Proceedings of the 2015 12th International Conference on Information Technology - New Generations	This paper presents an exploratory study on agile techniques for software testing Test-Driven Development and Behaviour-Driven Development for integration with the agile software development technique known as Domain-Driven Design. It also comprises a comparison between both test approaches, enhancing the strengths and weaknesses of each one. To make it feasible the integration proposal, an example of domain using Apache Isis framework was developed. According to the study performed, the possibility of creating an automatic test generator to make it agile the validation of entities attributes of the domain model was noted.				Included	Included	new_screen			2						
276	Behave	A Behaviour-Driven Development Approach for Cyber-Physical Production Systems	This paper proposes a method for iterative engineering of cyber-physical production systems (CPPS) that allows early testing of virtual prototypes and early involvement of domain experts. It is based on behaviour-driven development (BDD) from agile software engineering, which is adapted to address a set of issues relevant for CPPS engineering including the use of standardised CPPS models, integration testing, test environments, and brownfield development. The paper describes these adaptations and synthesises them into a procedural model of BDD for CPPS. Finally, a prototypical test system for CPPS is presented that partially implements the approach. © 2020 IEEE.		Kannengiesser U., Krenn F., Stary C.	Proceedings - 2020 IEEE Conference on Industrial Cyberphysical Systems, ICPS 2020	This paper proposes a method for iterative engineering of cyber-physical production systems (CPPS) that allows early testing of virtual prototypes and early involvement of domain experts. It is based on behaviour-driven development (BDD) from agile software engineering, which is adapted to address a set of issues relevant for CPPS engineering including the use of standardised CPPS models, integration testing, test environments, and brownfield development. The paper describes these adaptations and synthesises them into a procedural model of BDD for CPPS. Finally, a prototypical test system for CPPS is presented that partially implements the approach. © 2020 IEEE.				Included	Included	new_screen			2						
277	Behave	Lu-Lu	This paper proposes Lu-Lu as an add-on architecture to open MMOGs and social network games, which has been developed to utilise a key set of ingredients that underline collaborative decision making games as reported within the research literature: personalisation, team matching, non-optimal decision making, leading, decisiveness index, scoring, levelling, and multiple stages. The implementation of Lu-Lu is demonstrated as an add-on to the classic supply chain beer game, including customisation of Lu-Lu to facilitate information exchange through the Facebook games platform, e.g., Graph API and Scores API. Performance assessment of Lu-Lu using Behaviour-Driven Development suggests a successful integration of all key ingredients within Lu-Lu's architecture, yielding autonomous behaviour that improves both player enjoyment and decision making.	Collaborative; Decision making; Game; MPEG-7; Personalisation; Profiling	Daylamani-Zad, Damon; Angelides, Marios C.; Agius, Harry	Decis. Support Syst.	This paper proposes Lu-Lu as an add-on architecture to open MMOGs and social network games, which has been developed to utilise a key set of ingredients that underline collaborative decision making games as reported within the research literature: personalisation, team matching, non-optimal decision making, leading, decisiveness index, scoring, levelling, and multiple stages. The implementation of Lu-Lu is demonstrated as an add-on to the classic supply chain beer game, including customisation of Lu-Lu to facilitate information exchange through the Facebook games platform, e.g., Graph API and Scores API. Performance assessment of Lu-Lu using Behaviour-Driven Development suggests a successful integration of all key ingredients within Lu-Lu's architecture, yielding autonomous behaviour that improves both player enjoyment and decision making.				Excluded	Excluded	new_screen			2						
278	Behave	Lu-Lu: A framework for collaborative decision making games	This paper proposes Lu-Lu as an add-on architecture to open MMOGs and social network games, which has been developed to utilise a key set of ingredients that underline collaborative decision making games as reported within the research literature: personalisation, team matching, non-optimal decision making, leading, decisiveness index, scoring, levelling, and multiple stages. The implementation of Lu-Lu is demonstrated as an add-on to the classic supply chain beer game, including customisation of Lu-Lu to facilitate information exchange through the Facebook games platform, e.g., Graph API and Scores API. Performance assessment of Lu-Lu using Behaviour-Driven Development suggests a successful integration of all key ingredients within Lu-Lu's architecture, yielding autonomous behaviour that improves both player enjoyment and decision making.	Collaborative, Decision making, Game, Profiling, Personalisation, MPEG-7	Daylamani-Zad, Damon; Angelides, Marios C.; Agius, Harry	Decision Support Systems	This paper proposes Lu-Lu as an add-on architecture to open MMOGs and social network games, which has been developed to utilise a key set of ingredients that underline collaborative decision making games as reported within the research literature: personalisation, team matching, non-optimal decision making, leading, decisiveness index, scoring, levelling, and multiple stages. The implementation of Lu-Lu is demonstrated as an add-on to the classic supply chain beer game, including customisation of Lu-Lu to facilitate information exchange through the Facebook games platform, e.g., Graph API and Scores API. Performance assessment of Lu-Lu using Behaviour-Driven Development suggests a successful integration of all key ingredients within Lu-Lu's architecture, yielding autonomous behaviour that improves both player enjoyment and decision making.				Excluded	Excluded	new_screen			2						
279	Behave	An Approach for Guiding Developers in the Choice of Security Solutions and in the Generation of Concrete Test Cases	This paper tackles the problems of choosing security solutions and writing concrete security test cases for software, which are two tasks of the software life cycle requiring time, expertise and experience. We propose in this paper a method, based upon the notion of knowledge base, for helping developers devise more secure applications from the threat modelling step up to the testing one. The first stage of the approach consists of the acquisition and integration of publicly available security data into a data store. This one is used to assist developers in the design of attack-defense trees expressing the attacker possibilities to compromise an application and the defenses that may be implemented. These defenses are given under the form of security pattern combinations, a security pattern being a generic and reusable solution to design more secure applications. In the second stage, these trees are used to guide developers in the test case generation. Test verdicts show whether an application is vulnerable to the threats modelled by an ADTree and whether the consequences of the chosen security patterns are observed from the application (a consequence leading to some observable events partly showing that a pattern is correctly implemented). We applied this approach to web applications and evaluated it on 24 participants. The results are very encouraging in terms of the two criteria: comprehensibility and effectiveness.	Security; Attack-defense trees; Security patterns; Test case generation	Salva, Sébastien; Regainia, Loukmen	Software Quality Journal	This paper tackles the problems of choosing security solutions and writing concrete security test cases for software, which are two tasks of the software life cycle requiring time, expertise and experience. We propose in this paper a method, based upon the notion of knowledge base, for helping developers devise more secure applications from the threat modelling step up to the testing one. The first stage of the approach consists of the acquisition and integration of publicly available security data into a data store. This one is used to assist developers in the design of attack-defense trees expressing the attacker possibilities to compromise an application and the defenses that may be implemented. These defenses are given under the form of security pattern combinations, a security pattern being a generic and reusable solution to design more secure applications. In the second stage, these trees are used to guide developers in the test case generation. Test verdicts show whether an application is vulnerable to the threats modelled by an ADTree and whether the consequences of the chosen security patterns are observed from the application (a consequence leading to some observable events partly showing that a pattern is correctly implemented). We applied this approach to web applications and evaluated it on 24 participants. The results are very encouraging in terms of the two criteria: comprehensibility and effectiveness.				Excluded	Excluded	new_screen			2						
280	Behave	Parsing BDD Stories for Automated Verification of Software Artefacts	This position paper reports on our ongoing developments towards the automated verification of software artefacts by parsing sentences on Behaviour-Driven Development (BDD) stories. The solution we propose is based on different strategies for analysing the consistency of user requirements specified in BDD stories on task models, graphical user interfaces (GUIs), GUI prototypes, and domain models. We illustrate our solution through concrete examples and discuss its challenges and limitations. © 2020, Electronic Communications of the EASST. All rights reserved.		Silva T.R., Fitzgerald B.	Electronic Communications of the EASST	This position paper reports on our ongoing developments towards the automated verification of software artefacts by parsing sentences on Behaviour-Driven Development (BDD) stories. The solution we propose is based on different strategies for analysing the consistency of user requirements specified in BDD stories on task models, graphical user interfaces (GUIs), GUI prototypes, and domain models. We illustrate our solution through concrete examples and discuss its challenges and limitations. © 2020, Electronic Communications of the EASST. All rights reserved.				Included	Included	new_screen			2						
281	Behave	Tit for tat and big steps: The case of Swedish banks’ internationalization 1961–2010	This study examines four major Swedish banks’ internationalization process patterns during the period 1961–2010. The study complements earlier studies by also considering the banks’ levels of market commitment. One objective is to determine if ‘Tit for tat’-behaviour seen in earlier studies of Swedish banks still prevails after the deregulation. Adding to earlier studies, this study also considers the level of market activities and commitments. A secondary purpose is to examine how the financial crisis has affected the banks with reference to the banks’ internationalization patterns. The empirical study is based on archival data on the studied banks’ foreign operations. The results show that the banks’ behaviour follows ‘Tit for tat’-behaviour but that the internationalization has accelerated after the deregulation, hence being carried out with ‘big steps’ rather than small steps. The analysis also shows that the mimetic behaviour is complemented by other types of internationalization behaviours. The differences in bank internationalization also mean that the effect of a financial crisis varies depending on how the banks have internationalized.	Banks, Commitment, Financial crisis, Internationalization process, Longitudinal study	Ekman, Peter; Hadjikhani, Annoch Isa; Pajuvirta, Andreas; Thilenius, Peter	International Business Review	This study examines four major Swedish banks’ internationalization process patterns during the period 1961–2010. The study complements earlier studies by also considering the banks’ levels of market commitment. One objective is to determine if ‘Tit for tat’-behaviour seen in earlier studies of Swedish banks still prevails after the deregulation. Adding to earlier studies, this study also considers the level of market activities and commitments. A secondary purpose is to examine how the financial crisis has affected the banks with reference to the banks’ internationalization patterns. The empirical study is based on archival data on the studied banks’ foreign operations. The results show that the banks’ behaviour follows ‘Tit for tat’-behaviour but that the internationalization has accelerated after the deregulation, hence being carried out with ‘big steps’ rather than small steps. The analysis also shows that the mimetic behaviour is complemented by other types of internationalization behaviours. The differences in bank internationalization also mean that the effect of a financial crisis varies depending on how the banks have internationalized.				Excluded	Excluded	new_screen			2						
282	Behave	A case study of agile software development for safety-Critical systems projects	This study explores the introduction of agile software development within an avionics company engaged in safety-critical system engineering. There is increasing pressure throughout the software industry for development efforts to adopt agile software development in order to respond more rapidly to changing requirements and make more frequent deliveries of systems to customers for review and integration. This pressure is also being experienced in safety-critical industries, where release cycles on typically large and complex systems may run to several years on projects spanning decades. However, safety-critical system developments are normally highly regulated, which may constrain the adoption of agile software development or require adaptation of selected methods or practices. To investigate this potential conflict, we conducted a series of interviews with practitioners in the company, exploring their experiences of adopting agile software development and the challenges encountered. The study also explores the opportunities for altering the existing software process in the company to better fit agile software development to the constraints of software development for safety-critical systems. We conclude by identifying immediate future research directions to better align the tempo of software development for safety-critical systems and agile software development.		Islam, Gibrail; Storer, Tim	Reliability Engineering & System Safety	This study explores the introduction of agile software development within an avionics company engaged in safety-critical system engineering. There is increasing pressure throughout the software industry for development efforts to adopt agile software development in order to respond more rapidly to changing requirements and make more frequent deliveries of systems to customers for review and integration. This pressure is also being experienced in safety-critical industries, where release cycles on typically large and complex systems may run to several years on projects spanning decades. However, safety-critical system developments are normally highly regulated, which may constrain the adoption of agile software development or require adaptation of selected methods or practices. To investigate this potential conflict, we conducted a series of interviews with practitioners in the company, exploring their experiences of adopting agile software development and the challenges encountered. The study also explores the opportunities for altering the existing software process in the company to better fit agile software development to the constraints of software development for safety-critical systems. We conclude by identifying immediate future research directions to better align the tempo of software development for safety-critical systems and agile software development.				Excluded	Excluded	new_screen			2						
283	Behave	Does IT team climate matter? An empirical study of the impact of co-workers and the Confucian work ethic on deviance behavior	This study seeks to determine the impact of IT co-workers on individual deviance behavior in organizations. Using data collected from 322 IT employees and their supervisors in Chinese software companies, we also examine the impact of the Confucian work ethic on deviant behavior. The results suggest that both co-workers’ production deviance and the Confucian work ethic have impacts on individuals’ production deviance. The influence of IT co-workers’ production deviance was greater in high team climates and low team climates than in neutral team climates. The Confucian work ethic has no significant influence on production deviance in low team climates.	Confucian work ethic, IT co-worker production deviance, IT team climate	Zhang, Hanpeng; Luo, Xin (Robert); Liao, Qinyu; Peng, Lifang	Information & Management	This study seeks to determine the impact of IT co-workers on individual deviance behavior in organizations. Using data collected from 322 IT employees and their supervisors in Chinese software companies, we also examine the impact of the Confucian work ethic on deviant behavior. The results suggest that both co-workers’ production deviance and the Confucian work ethic have impacts on individuals’ production deviance. The influence of IT co-workers’ production deviance was greater in high team climates and low team climates than in neutral team climates. The Confucian work ethic has no significant influence on production deviance in low team climates.				Excluded	Excluded	new_screen			2						
284	Behave	Legislation-driven development of a Gift Aid system using Event-B	This work presents our approach to formally model the Swiftaid system design, a digital platform that enables donors to automatically add Gift Aid to donations made via card payments. Following principles of Behaviour-Driven Development, we use Gherkin to capture requirements specified in legislation, specifically the UK Charity (Gift Aid Declarations) Regulations 2016. The Gherkin scenarios provide a basis for subsequent formal modelling and analysis using Event-B, Rodin and ProB. Interactive model simulations assist communication between domain experts, software architects and other stakeholders during requirements capture and system design, enabling the emergent system behaviour to be validated. Our approach was employed within the development of the real Swiftaid product, launched by Streeva in February 2019. Our analysis helped conclude that there was not a strong enough business case for one of the features, whichwas shown to provide nominal user convenience at the expense of increased complexity. This work provides a case study in allying formal and agile software development to enable rapid development of robust software. © 2020, The Author(s).		Williams D.M., Darwish S., Schneider S., Michael D.R.	Formal Aspects of Computing	This work presents our approach to formally model the Swiftaid system design, a digital platform that enables donors to automatically add Gift Aid to donations made via card payments. Following principles of Behaviour-Driven Development, we use Gherkin to capture requirements specified in legislation, specifically the UK Charity (Gift Aid Declarations) Regulations 2016. The Gherkin scenarios provide a basis for subsequent formal modelling and analysis using Event-B, Rodin and ProB. Interactive model simulations assist communication between domain experts, software architects and other stakeholders during requirements capture and system design, enabling the emergent system behaviour to be validated. Our approach was employed within the development of the real Swiftaid product, launched by Streeva in February 2019. Our analysis helped conclude that there was not a strong enough business case for one of the features, whichwas shown to provide nominal user convenience at the expense of increased complexity. This work provides a case study in allying formal and agile software development to enable rapid development of robust software. © 2020, The Author(s).				Included	Included	new_screen			2						
285	Behave	Test Descriptions with ETSI TDL	To address the need for abstract, high-level test descriptions that can be shared among different stakeholders, the European Telecommunications Standards Institute (ETSI) commissioned the design of the Test Description Language (TDL). TDL is designed as a domain-specific language for testing, consisting of a standardised abstract syntax (meta-model) and concrete syntaxes for textual specification, graphical design, and model exchange between tools. Its main purpose is to support a test methodology that is followed in the standardisation work for software-intense systems at ETSI and is applicable in industrial projects as well. TDL enables the formal specification of both test objectives derived from system requirements and test descriptions refining the test objectives. The latter serve as blueprint for the implementation of executable tests. A standardised mapping of TDL specifications to test scripts in the standardised test execution language TTCN-3 widens the reach of TDL to ensure compatibility and consistency of generated executable tests. An open-source toolset has been developed as a common platform to accelerate the adoption of TDL and lower the barrier to entry for users and tool vendors. Reports from pilot applications within three ETSI standardisation groups demonstrate the practicality of the chosen approach.	Model-based testing; Domain-specific modelling; Test description language; Test methodology; Testing in standardisation	Makedonski, Philip; Adamis, Gusztáv; Käärik, Martti; Kristoffersen, Finn; Carignani, Michele; Ulrich, Andreas; Grabowski, Jens	Software Quality Journal	To address the need for abstract, high-level test descriptions that can be shared among different stakeholders, the European Telecommunications Standards Institute (ETSI) commissioned the design of the Test Description Language (TDL). TDL is designed as a domain-specific language for testing, consisting of a standardised abstract syntax (meta-model) and concrete syntaxes for textual specification, graphical design, and model exchange between tools. Its main purpose is to support a test methodology that is followed in the standardisation work for software-intense systems at ETSI and is applicable in industrial projects as well. TDL enables the formal specification of both test objectives derived from system requirements and test descriptions refining the test objectives. The latter serve as blueprint for the implementation of executable tests. A standardised mapping of TDL specifications to test scripts in the standardised test execution language TTCN-3 widens the reach of TDL to ensure compatibility and consistency of generated executable tests. An open-source toolset has been developed as a common platform to accelerate the adoption of TDL and lower the barrier to entry for users and tool vendors. Reports from pilot applications within three ETSI standardisation groups demonstrate the practicality of the chosen approach.				Excluded	Excluded	new_screen			2						
286	Behave	Enabling IoT Platform Interoperability Using a Systematic Development Approach by Example	Today, the IoT landscape consists of a large number of vertical IoT platforms that are rarely interconnected. To enable creation of applications across platforms and domain boundaries interoperability needs to be established between IoT platforms. In this paper we present how this task can be simplified by utilizing a systematic software development process based on behavior- and domain-driven development. This process is illustrated using an example that uses the open source IoT interoperability framework symbIoTe to connect two indoor navigation platforms. We show that developers can actually profit from this approach but existing IoT interoperability frameworks are still cumbersome to use.	Internet of Things;IoT;interoperability;semantic interoperability;behavior-driven development;domain-driven design	M. Schneider; B. Hippchen; S. Abeck; M. Jacoby; R. Herzog	2018 Global Internet of Things Summit (GIoTS)	Today, the IoT landscape consists of a large number of vertical IoT platforms that are rarely interconnected. To enable creation of applications across platforms and domain boundaries interoperability needs to be established between IoT platforms. In this paper we present how this task can be simplified by utilizing a systematic software development process based on behavior- and domain-driven development. This process is illustrated using an example that uses the open source IoT interoperability framework symbIoTe to connect two indoor navigation platforms. We show that developers can actually profit from this approach but existing IoT interoperability frameworks are still cumbersome to use.				Included	Included	new_screen			2						
287	Behave	Mining reading patterns from eye-tracking data: method and demonstration	Understanding how developers interact with different software artifacts when performing comprehension tasks has a potential to improve developers’ productivity. In this paper, we propose a method to analyze eye-tracking data using process mining to find distinct reading patterns of how developers interacted with the different artifacts. To validate our approach, we conducted an exploratory study using eye-tracking involving 11 participants. We applied our method to investigate how developers interact with different artifacts during domain and code understanding tasks. To contextualize the reading patterns and to better understand the perceived benefits and challenges participants associated with the different artifacts and their choice of reading patterns, we complemented the eye-tracking data with the data obtained from think aloud. The study used behavior-driven development, a development practice that is increasingly used in Agile software development contexts, as a setting. The study shows that our method can be used to explore developers’ behavior at an aggregated level and identify behavioral patterns at varying levels of granularity. © 2019, Springer-Verlag GmbH Germany, part of Springer Nature.		Ioannou C., Nurdiani I., Burattin A., Weber B.	Software and Systems Modeling	Understanding how developers interact with different software artifacts when performing comprehension tasks has a potential to improve developers’ productivity. In this paper, we propose a method to analyze eye-tracking data using process mining to find distinct reading patterns of how developers interacted with the different artifacts. To validate our approach, we conducted an exploratory study using eye-tracking involving 11 participants. We applied our method to investigate how developers interact with different artifacts during domain and code understanding tasks. To contextualize the reading patterns and to better understand the perceived benefits and challenges participants associated with the different artifacts and their choice of reading patterns, we complemented the eye-tracking data with the data obtained from think aloud. The study used behavior-driven development, a development practice that is increasingly used in Agile software development contexts, as a setting. The study shows that our method can be used to explore developers’ behavior at an aggregated level and identify behavioral patterns at varying levels of granularity. © 2019, Springer-Verlag GmbH Germany, part of Springer Nature.				Excluded	Excluded	new_screen			2						
288	Behave	Testing Web Applications with State Objects	Use states to drive your tests.		van Deursen, Arie	Commun. ACM	Use states to drive your tests.				Excluded	Excluded	new_screen			2						
289	Behave	User Interface Prototype Generation from Agile Requirements Specifications Written in Concordia	User interface prototypes (UIP) are widely used to get feedback before building a software feature. They can prevent misunderstandings between the software development team and other stakeholders (e.g., users, investors) that lead to rework or a resulting software that does not meet their needs. UIP can also be a valuable resource in Agile software development, in which feedback is key. In this paper, we present an approach to generate UIP automatically from Agile requirements specifications written in Concordia and its corresponding prototype tool. The tool is able to generate UIP for web-based applications. We evaluated the approach and the tool with questionnaires, and the results revealed that: (i) the generated UIP are very similar to those drawn by respondents; (ii) the generated source code has good enough quality to be reused by developers; and (iii) they save design and development time.	user story; agile; concordia; generation; user interface	Pinto, Thiago Delgado; Gonçalves, Willian Inacio; Costa, Pablo Veiga	Proceedings of the 25th Brazillian Symposium on Multimedia and the Web	User interface prototypes (UIP) are widely used to get feedback before building a software feature. They can prevent misunderstandings between the software development team and other stakeholders (e.g., users, investors) that lead to rework or a resulting software that does not meet their needs. UIP can also be a valuable resource in Agile software development, in which feedback is key. In this paper, we present an approach to generate UIP automatically from Agile requirements specifications written in Concordia and its corresponding prototype tool. The tool is able to generate UIP for web-based applications. We evaluated the approach and the tool with questionnaires, and the results revealed that: (i) the generated UIP are very similar to those drawn by respondents; (ii) the generated source code has good enough quality to be reused by developers; and (iii) they save design and development time.				Included	Included	new_screen			2						
290	Behave	Remote but Connected: Ownership-Inspired Behavior-Driven Development and What an E-Learning Governance System for Africa Could Look like	Using e-learning technology is one key for developing sustainable education in urban and remote areas in Western Africa as it reduced the demands on students who are well integrated in their rural society to leave their homes for an expensive education. In this chapter we present Ownership-inspired Behavior-Driven Development (OIBBD), a development strategy designed for e-learning governance in remote areas in Africa to support sustainable education as part of the agenda 2030 and the Sustainable Development Goals (SDGs) and show how the design of a User Experience (UX), which is based on user-centered design and feedback from the African target group can be used to support the implementation of e-learning in Africa. We reflect on how a governance for sustainable development in theological education on the African continent can look like. We ask how such an e-learning governance can support remote e-learning in hard to reach areas in Africa and how this can be designed specifically of the needs of the African socio-culture. The guiding hypothesis of this chapter is, that especially leadership and its activation in African teachers can trigger them to develop ownership in using e-learning technology and this way supports the reaching of SDG 4, which deals with sustainable education. © 2018, Springer International Publishing AG.		Gottschalk J., Winther-Nielsen N.	World Sustainability Series	Using e-learning technology is one key for developing sustainable education in urban and remote areas in Western Africa as it reduced the demands on students who are well integrated in their rural society to leave their homes for an expensive education. In this chapter we present Ownership-inspired Behavior-Driven Development (OIBBD), a development strategy designed for e-learning governance in remote areas in Africa to support sustainable education as part of the agenda 2030 and the Sustainable Development Goals (SDGs) and show how the design of a User Experience (UX), which is based on user-centered design and feedback from the African target group can be used to support the implementation of e-learning in Africa. We reflect on how a governance for sustainable development in theological education on the African continent can look like. We ask how such an e-learning governance can support remote e-learning in hard to reach areas in Africa and how this can be designed specifically of the needs of the African socio-culture. The guiding hypothesis of this chapter is, that especially leadership and its activation in African teachers can trigger them to develop ownership in using e-learning technology and this way supports the reaching of SDG 4, which deals with sustainable education. © 2018, Springer International Publishing AG.				Excluded	Excluded	new_screen			2						
291	Behave	Approach of integrating behaviour-driven development with hardware/software codesign	Using typical approaches in designing embedded systems to manage the specification and design of the hardware and software is not suitable in today’s projects. In this paper, we propose a model-driven approach to integrate Hardware/Software codesign with Behaviour-Driven Development. Hardware/Software codesign approach allows the hardware and the software to be designed and implemented concurrently and optimizes the project design constraint, such as performance and cost. Behaviour-Driven Development spurs project stakeholders to collaborate to ensure the right software is developed to meet their needs and ensures that all project participants communicate in the same language. The approach exploits the advantages of each approach and provides the ability to describe the behaviour of the software as executable user stories in a Hardware/Software codesign environment. The approach is evaluated using a renewable energy project in collaboration with a private company in Canada to build a system for autonomous load management of self-forming renewable energy nanogrids. © 2019, ICIC International. All righs reserved.		Alhaj M., Arbez G., Peyton L.	International Journal of Innovative Computing, Information and Control	Using typical approaches in designing embedded systems to manage the specification and design of the hardware and software is not suitable in today’s projects. In this paper, we propose a model-driven approach to integrate Hardware/Software codesign with Behaviour-Driven Development. Hardware/Software codesign approach allows the hardware and the software to be designed and implemented concurrently and optimizes the project design constraint, such as performance and cost. Behaviour-Driven Development spurs project stakeholders to collaborate to ensure the right software is developed to meet their needs and ensures that all project participants communicate in the same language. The approach exploits the advantages of each approach and provides the ability to describe the behaviour of the software as executable user stories in a Hardware/Software codesign environment. The approach is evaluated using a renewable energy project in collaboration with a private company in Canada to build a system for autonomous load management of self-forming renewable energy nanogrids. © 2019, ICIC International. All righs reserved.				Included	Included	new_screen			2						
292	Behave	Modeling test cases in BPMN for behavior-driven development (extended abstract)	Validating analytical business processes and testing executable ones are difficult task in process development projects. Within the project Terravis, which builds a process hub for enabling fully digitalized mortgage processes between Swiss land registries, banks, notaries and other parties, these tasks became problematic. For improving stakeholder communication and extending the test scope, behavior-driven development was adapted to BPMN and business processes. This technique was introduced and very well received within the project, leading to better process documentation and better tests.		Lübke D., Van Lessen T.	CEUR Workshop Proceedings	Validating analytical business processes and testing executable ones are difficult task in process development projects. Within the project Terravis, which builds a process hub for enabling fully digitalized mortgage processes between Swiss land registries, banks, notaries and other parties, these tasks became problematic. For improving stakeholder communication and extending the test scope, behavior-driven development was adapted to BPMN and business processes. This technique was introduced and very well received within the project, leading to better process documentation and better tests.				Excluded	Excluded	new_screen			2						
293	Behave	Chapter 11 - Validation of DEVS Models Using AGILE-Based Methods	Validation of discrete event system specification (DEVS) models at the early phases of the discrete-event modeling and simulation design process is a crucial topic when dealing with complex DEVS models. Based on software engineering test methods, we present in this chapter a new approach, which integrates Agile test methods in the process of the simulation in order to design and test DEVS models. We propose an implementation in Python language based on the use of aspect programming concepts (patch, mocking objects, and decorators). This implementation is performed in the framework of the DEVSimPy environment with the definition of a plug-in dedicated to the automatic generation and execution of test scenario.	Modeling, Simulation, Discrete event, Formalism, AGILE, Validation	Capocchi, L.; Santucci, J. F.		Validation of discrete event system specification (DEVS) models at the early phases of the discrete-event modeling and simulation design process is a crucial topic when dealing with complex DEVS models. Based on software engineering test methods, we present in this chapter a new approach, which integrates Agile test methods in the process of the simulation in order to design and test DEVS models. We propose an implementation in Python language based on the use of aspect programming concepts (patch, mocking objects, and decorators). This implementation is performed in the framework of the DEVSimPy environment with the definition of a plug-in dedicated to the automatic generation and execution of test scenario.				Excluded	Excluded	new_screen			2						
294	Behave	Gherkin Syntax Extension for Parameterization of Network Switch Configurations in Test Specification	We applied test automation in the style of Behavior-Driven Development (BDD), an agile software development technique. In applying BDD, the problem is that a large amount of similar configurations of network switches have to be written in the BDD test specification files. To solve this problem, parameterization of configurations is considered effective. However, Gherkin, the BDD test specification language, does not provide syntax for parameterization. In this paper, we propose a syntax extension of Gherkin, which enables parameterization of configurations. From experiments on 11 configurations, parameterization using the proposed syntax extension can reduce the number of the lines used to describe configurations by 39%.	test specification;parameterization;BDD;Gherkin;syntax extension;network switch;configuration	T. Li; S. Tsubota; K. Hirono	2017 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)	We applied test automation in the style of Behavior-Driven Development (BDD), an agile software development technique. In applying BDD, the problem is that a large amount of similar configurations of network switches have to be written in the BDD test specification files. To solve this problem, parameterization of configurations is considered effective. However, Gherkin, the BDD test specification language, does not provide syntax for parameterization. In this paper, we propose a syntax extension of Gherkin, which enables parameterization of configurations. From experiments on 11 configurations, parameterization using the proposed syntax extension can reduce the number of the lines used to describe configurations by 39%.				Included	Included	new_screen			2						
295	Behave	Automation and consistency analysis of test cases written in natural language: An industrial context	We present here a novel test automation strategy that receives as input a freestyle natural language (NL) test case (consisting of a sequence of test steps) and produces executable test scripts. This strategy relies on a database of previously automated seed test steps, available for reuse. New steps are automated via a capturing process by a tester, without requiring any programming knowledge. Automated tests can be executed by a replay facility. We discuss the reuse improvement, implementation effort, and user feedback regarding the industrial applicability and usability of our capture & replay tool. We then show that restricting the input textual description to obey a proposed Controlled NL (CNL) brings significant advantages: (1) reuse improvement; (2) the possibility of integration with a test generation framework; and (3) definition of consistency notions for test actions and test action sequences, that ensure, respectively, well-formedness of each action and a proper configuration to safely execute a sequence of actions. We formalize these consistency notions in Alloy and use the Alloy Analyzer to carry out the consistency check; the scalability of the analysis is assessed via an evaluation considering a repository with real test cases; the practical context of our work is mobile device testing, involving a partnership with Motorola Mobility, a Lenovo company.	Test automation, Controlled natural language, Alloy, Test case consistency	Arruda, Filipe; Barros, Flávia; Sampaio, Augusto	Science of Computer Programming	We present here a novel test automation strategy that receives as input a freestyle natural language (NL) test case (consisting of a sequence of test steps) and produces executable test scripts. This strategy relies on a database of previously automated seed test steps, available for reuse. New steps are automated via a capturing process by a tester, without requiring any programming knowledge. Automated tests can be executed by a replay facility. We discuss the reuse improvement, implementation effort, and user feedback regarding the industrial applicability and usability of our capture & replay tool. We then show that restricting the input textual description to obey a proposed Controlled NL (CNL) brings significant advantages: (1) reuse improvement; (2) the possibility of integration with a test generation framework; and (3) definition of consistency notions for test actions and test action sequences, that ensure, respectively, well-formedness of each action and a proper configuration to safely execute a sequence of actions. We formalize these consistency notions in Alloy and use the Alloy Analyzer to carry out the consistency check; the scalability of the analysis is assessed via an evaluation considering a repository with real test cases; the practical context of our work is mobile device testing, involving a partnership with Motorola Mobility, a Lenovo company.				Excluded	Excluded	new_screen			2						
296	Behave	Automatic acceptance testing of the web application security with ITU-T X.805 framework	Web application development companies should ensure the high quality of their products. This can be achieved through high quality of the software development lifecycle. Web applications are mostly running on the Internet and are being exposed to many security threats and malicious operations. The mission of EUCISE2020 project (EUropean test bed for the maritime Common Information Sharing Environment in the 2020 perspective) is to enhance interoperability between systems and networks. The interconnections must be established in a decentralized way using cutting-edge technologies. Hence, it requires innovative and practical solutions from the web development companies. The research problem is being addressed with the Stanford Research Institute NABC (Needs, Approach, Benefits and Competition) method. Our approach is to conceptualize a testing scenario for the web application development process. The concept utilizes the International Telecommunication Union recommended standard security framework (ITU-T X.805) in the context of test automation for end-to-end communications. This study presents a new holistic solution in feature driven fashion. As a result, we propose that building acceptance test scenarios using ITU-T X.805 guidelines in Software Development Lifecycle is a sustainable approach.	EUCISE 2020;ITU-T Recommendation X.805;NABC analysis;web application development;automated testing scenario;behavior-driven development (BDD)	P. Rathod; V. Julkunen; T. Kaisti; J. Nissilä	2015 Second International Conference on Computer Science, Computer Engineering, and Social Media (CSCESM)	Web application development companies should ensure the high quality of their products. This can be achieved through high quality of the software development lifecycle. Web applications are mostly running on the Internet and are being exposed to many security threats and malicious operations. The mission of EUCISE2020 project (EUropean test bed for the maritime Common Information Sharing Environment in the 2020 perspective) is to enhance interoperability between systems and networks. The interconnections must be established in a decentralized way using cutting-edge technologies. Hence, it requires innovative and practical solutions from the web development companies. The research problem is being addressed with the Stanford Research Institute NABC (Needs, Approach, Benefits and Competition) method. Our approach is to conceptualize a testing scenario for the web application development process. The concept utilizes the International Telecommunication Union recommended standard security framework (ITU-T X.805) in the context of test automation for end-to-end communications. This study presents a new holistic solution in feature driven fashion. As a result, we propose that building acceptance test scenarios using ITU-T X.805 guidelines in Software Development Lifecycle is a sustainable approach.				Excluded	Excluded	new_screen			2						
297	Behave	Testing of Web Services Using Behavior-Driven Development	Web services are commonly used in the communication of software over the web. To fully trust a web service, it should be tested and certified, but testing of web services provoke new challenges. Behavior-Driven Development (BDD) can be applied to the testing of web services. Gherkin language is used to define scenarios in BDD. We used Gherkin language to define test cases for web services and we developed a tool to convert these test cases into JMeter test scripts.	Behavior-Driven Development; Software Testing; Gherkin; JMeter; Testing of Web Services; Web Services.	Oruç, Ahmet Furkan; Ovatman, Tolga	Proceedings of the 6th International Conference on Cloud Computing and Services Science - Volume 1 and 2	Web services are commonly used in the communication of software over the web. To fully trust a web service, it should be tested and certified, but testing of web services provoke new challenges. Behavior-Driven Development (BDD) can be applied to the testing of web services. Gherkin language is used to define scenarios in BDD. We used Gherkin language to define test cases for web services and we developed a tool to convert these test cases into JMeter test scripts.				Included	Included	new_screen			2						
298	Behave	ScrumOntoBDD: Agile software development based on scrum, ontologies and behaviour-driven development	When developing a Learning Management System (LMS) using Scrum, we noticed that it was quite often necessary to redefine some system behaviour scenarios, due to ambiguities in the requirement specifications, or due to misinterpretations of stories reported by the Product Owners (POs). The definition of test suites was also cumbersome, resulting in test suites that were incomplete or did not at all comply with the system requirements. Based on this experience and to deal with these problems, in this paper, we propose the ScrumOntoBDD approach to agile software development, which combines Scrum, ontologies and Behaviour-Driven Development (BDD). This approach is centred on the concepts and techniques of Scrum and BDD and focuses on the planning and analysis phases of the software life cycle, since the BDD tools currently provide little support to these phases, while most of the problems during the LMS development were found exactly there. We claim that our approach improves the software development practices in this respect. Furthermore, ScrumOntoBDD employs ontologies in order to reduce ambiguities intrinsic to the use of a natural language as a BDD ubiquitous language. In this paper, we illustrate and systematically evaluate our approach, showing that it is beneficial since it improves the communication between members of an agile development team. © 2021, The Author(s).		Lopes de Souza P., Lopes de Souza W., Ferreira Pires L.	Journal of the Brazilian Computer Society	When developing a Learning Management System (LMS) using Scrum, we noticed that it was quite often necessary to redefine some system behaviour scenarios, due to ambiguities in the requirement specifications, or due to misinterpretations of stories reported by the Product Owners (POs). The definition of test suites was also cumbersome, resulting in test suites that were incomplete or did not at all comply with the system requirements. Based on this experience and to deal with these problems, in this paper, we propose the ScrumOntoBDD approach to agile software development, which combines Scrum, ontologies and Behaviour-Driven Development (BDD). This approach is centred on the concepts and techniques of Scrum and BDD and focuses on the planning and analysis phases of the software life cycle, since the BDD tools currently provide little support to these phases, while most of the problems during the LMS development were found exactly there. We claim that our approach improves the software development practices in this respect. Furthermore, ScrumOntoBDD employs ontologies in order to reduce ambiguities intrinsic to the use of a natural language as a BDD ubiquitous language. In this paper, we illustrate and systematically evaluate our approach, showing that it is beneficial since it improves the communication between members of an agile development team. © 2021, The Author(s).				Included	Included	new_screen			2						
299	Behave	Formal Model Validation Through Acceptance Tests	When formal systems modelling is used as part of the development process, modellers need to understand the requirements in order to create appropriate models, and domain experts need to validate the final models to ensure they fit the needs of stakeholders. A suitable mechanism for such a validation are acceptance tests. In this paper we discuss how the principles of Behaviour-Driven Development (BDD) can be applied to (i) formal modelling and (ii) validation of behaviour specifications, thus coupling those two tasks. We show how to close the gap between the informal domain specification and the formal model, thus enabling the domain expert to write acceptance tests in a high-level language matching the formal specification. We analyse the applicability of this approach by providing the Gherkin scenarios for an formal model of a ‘fixed virtual block’ approach to train movement control, developed according to the Hybrid ERTMS/ETCS Level 3 principles specified by the EEIG ERTMS Users Group and presented as a case study on the 6. International ABZ Conference 2018. © 2019, Springer Nature Switzerland AG.		Fischer T., Dghyam D.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	When formal systems modelling is used as part of the development process, modellers need to understand the requirements in order to create appropriate models, and domain experts need to validate the final models to ensure they fit the needs of stakeholders. A suitable mechanism for such a validation are acceptance tests. In this paper we discuss how the principles of Behaviour-Driven Development (BDD) can be applied to (i) formal modelling and (ii) validation of behaviour specifications, thus coupling those two tasks. We show how to close the gap between the informal domain specification and the formal model, thus enabling the domain expert to write acceptance tests in a high-level language matching the formal specification. We analyse the applicability of this approach by providing the Gherkin scenarios for an formal model of a ‘fixed virtual block’ approach to train movement control, developed according to the Hybrid ERTMS/ETCS Level 3 principles specified by the EEIG ERTMS Users Group and presented as a case study on the 6. International ABZ Conference 2018. © 2019, Springer Nature Switzerland AG.				Included	Included	new_screen			2						
300	Behave	Executable requirements in a safety-critical context with Ada	When people who need the software and people who build the software do not understand each other, the success of a project may be impacted. In the same way, when it is difficult to know which test case corresponds to a given requirement, or if each and every requirement is fully covered by the test suite, we have a traceability issue that may also impact the success of the project. During the last few years, the agile community has suggested a new development paradigm in order to address this traceability issue. This approach is called Behaviour Driven Development (BDD). It is based on a new way of expressing requirements using a common language understandable by all parties at stake. After having described the Behaviour Driven Development in details, we introduce the XReq tool, an Open Source project developed by SOGILIS and part of the Open-DO project. It is designed to bring the Behaviour Driven Development to the Ada language and other statically typed languages. It also aims at facilitating the traceability of High and Low Level Tests in the context of DO-178B projects.		Bâillon C., Bouchez-Mongardé S.	Ada User Journal	When people who need the software and people who build the software do not understand each other, the success of a project may be impacted. In the same way, when it is difficult to know which test case corresponds to a given requirement, or if each and every requirement is fully covered by the test suite, we have a traceability issue that may also impact the success of the project. During the last few years, the agile community has suggested a new development paradigm in order to address this traceability issue. This approach is called Behaviour Driven Development (BDD). It is based on a new way of expressing requirements using a common language understandable by all parties at stake. After having described the Behaviour Driven Development in details, we introduce the XReq tool, an Open Source project developed by SOGILIS and part of the Open-DO project. It is designed to bring the Behaviour Driven Development to the Ada language and other statically typed languages. It also aims at facilitating the traceability of High and Low Level Tests in the context of DO-178B projects.				Included	Included	new_screen			2						
301	Behave	Creation of multiple conceptual models from user stories – a natural language processing approach	While Agile methodologies are used in software development, researchers have identified many issues related to requirements engineering in Agile approaches. Some of these issues relate to ambiguity in user stories, which is a widely-used requirements specification mechanism in Agile methodologies. This research proposes the use of conceptual models while developing user stories. We posit that the use of conceptual models helps reducing ambiguity in user stories. An important aspect of our research is the creation of an algorithm for automatic generation of such models while developing the user stories. © Springer Nature Switzerland AG 2019.		Gupta A., Poels G., Bera P.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	While Agile methodologies are used in software development, researchers have identified many issues related to requirements engineering in Agile approaches. Some of these issues relate to ambiguity in user stories, which is a widely-used requirements specification mechanism in Agile methodologies. This research proposes the use of conceptual models while developing user stories. We posit that the use of conceptual models helps reducing ambiguity in user stories. An important aspect of our research is the creation of an algorithm for automatic generation of such models while developing the user stories. © Springer Nature Switzerland AG 2019.				Excluded	Excluded	new_screen			2						
302	Behave	Test Automation with the Gauge Framework: Experience and Best Practices	While Behavior-driven development (BDD) tools such as Cucumber are powerful tools for automated testing, they have certain limitations. For example, they often enforce strict syntax for test cases, like the “Given-When-Then” format, which may not always be easy to write for a given test case. A new test automation framework named Gauge (gauge.org) addresses that limitation since it does not prescribe the BDD testing process with a strict syntax. In Gauge, writing a test case is as easy as writing down the flow of test cases in several itemized sentences in a natural language, like English. In the context of Testinium (testinium.com), a large software testing company which provides software testing services, tools and solutions to a large number of clients, we have actively used the Gauge framework since 2018 to develop large automated front-end test suites for several large web applications. In this paper/talk, the speakers will share several examples and best practices of developing automated tests in natural-language requirements using the Gauge framework. By learning from the ideas presented in the talk, readers (attendees) will be able to consider applying the Gauge framework in their own test automation projects. © 2020, Springer Nature Switzerland AG.		Garousi V., Keleş A.B., Balaman Y., Güler Z.Ö.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	While Behavior-driven development (BDD) tools such as Cucumber are powerful tools for automated testing, they have certain limitations. For example, they often enforce strict syntax for test cases, like the “Given-When-Then” format, which may not always be easy to write for a given test case. A new test automation framework named Gauge (gauge.org) addresses that limitation since it does not prescribe the BDD testing process with a strict syntax. In Gauge, writing a test case is as easy as writing down the flow of test cases in several itemized sentences in a natural language, like English. In the context of Testinium (testinium.com), a large software testing company which provides software testing services, tools and solutions to a large number of clients, we have actively used the Gauge framework since 2018 to develop large automated front-end test suites for several large web applications. In this paper/talk, the speakers will share several examples and best practices of developing automated tests in natural-language requirements using the Gauge framework. By learning from the ideas presented in the talk, readers (attendees) will be able to consider applying the Gauge framework in their own test automation projects. © 2020, Springer Nature Switzerland AG.				Excluded	Excluded	new_screen			2						
303	Behave	Leveraging Semi-formal Approaches for DepDevOps	While formal methods have long been praised by the dependable Cyber-Physical System community, continuous software engineering practices are now employing or promoting semi-formal approaches for achieving lean and agile processes. This paper is a discussion about using Behaviour Driven Development, particularly Gherkin and RSpec for DepDevOps, DevOps for dependable Cyber-Physical Systems. © 2020, Springer Nature Switzerland AG.		Zaeske W., Durak U.	Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)	While formal methods have long been praised by the dependable Cyber-Physical System community, continuous software engineering practices are now employing or promoting semi-formal approaches for achieving lean and agile processes. This paper is a discussion about using Behaviour Driven Development, particularly Gherkin and RSpec for DepDevOps, DevOps for dependable Cyber-Physical Systems. © 2020, Springer Nature Switzerland AG.				Included	Included	new_screen			2						
304	Behave	FormTester: Effective Integration of Model-Based and Manually Specified Test Cases	Whilst Model Based Testing (MBT) is an improvement over manual test specification, the leap from it to MBT can be hard. Only recently MBT tools for web applications have emerged that can recover models from existing manually specified test cases. However, there are further requirements for supporting both MBT and manually specified tests. First, we need support for the generation of test initialization procedures. Also, we want to identify areas of the system that are not testable due to defects. We present FormTester, a new MBT tool addressing these limitations. An evaluation with real web applications shows that FormTester helps to reduce the time spent on developing test cases.		Dixit, Rahul; Lutteroth, Christof; Weber, Gerald	Proceedings of the 37th International Conference on Software Engineering - Volume 2	Whilst Model Based Testing (MBT) is an improvement over manual test specification, the leap from it to MBT can be hard. Only recently MBT tools for web applications have emerged that can recover models from existing manually specified test cases. However, there are further requirements for supporting both MBT and manually specified tests. First, we need support for the generation of test initialization procedures. Also, we want to identify areas of the system that are not testable due to defects. We present FormTester, a new MBT tool addressing these limitations. An evaluation with real web applications shows that FormTester helps to reduce the time spent on developing test cases.				Excluded	Excluded	new_screen			2						
305	Behave	Software Automation Testing Secrets Revealed	Widely acknowledged one of the best practical guide to software test automation, Narayanan Palani's Automation Labs has been helping freshers write better automation test scripts for the last three years! Now this classic book has been fully updated and revised with leading-testing tools–and hundreds of new script samples–illustrating the art and science of automation testing. Capturing the body of knowledge available from strong professional experience and industry best practices, Palani synthesizes the most effective techniques and must-know principles into clear, pragmatic guidance. No matter what your experience level,test environment, or project size, this book will inform and stimulate your thinking–and help you build the highest quality automation scripts. Discover the timeless techniques and framework designing methods that help you:Design for TestNG, Visual Studio, Jenkins, Excel VBA, Selenium, HP UFT (formerly QTP), Ranorex, RFT and other wide ranged QA Testing Tools. Reap the benefits of well built selenium webdriver automation framework! Apply powerful programming techniques to build well-estabilished data driven framework, keyword driven framework, hybrid framework, Agile Continuous Integration Automation Framework. Exploit opportunities to design Web services based SOAP Automation Frameworks with the help of SOA, ETL basics and SQL Automation scripts to validate Database Systems! Use construction practices using Object Recognition Technology of test automation tools and capture dynamic web elements. Debug problems in software development life cycle to improve testing process using test estimation techniques, tool selection process. Build quality automation scripts by understanding the machine learning basics of selenium automation framework Resolve automation issues and introduce cucumber, Specflow based Behaviour Driven Development and Test Driven Development in functional testing.		Palani, Narayanan		Widely acknowledged one of the best practical guide to software test automation, Narayanan Palani's Automation Labs has been helping freshers write better automation test scripts for the last three years! Now this classic book has been fully updated and revised with leading-testing tools–and hundreds of new script samples–illustrating the art and science of automation testing. Capturing the body of knowledge available from strong professional experience and industry best practices, Palani synthesizes the most effective techniques and must-know principles into clear, pragmatic guidance. No matter what your experience level,test environment, or project size, this book will inform and stimulate your thinking–and help you build the highest quality automation scripts. Discover the timeless techniques and framework designing methods that help you:Design for TestNG, Visual Studio, Jenkins, Excel VBA, Selenium, HP UFT (formerly QTP), Ranorex, RFT and other wide ranged QA Testing Tools. Reap the benefits of well built selenium webdriver automation framework! Apply powerful programming techniques to build well-estabilished data driven framework, keyword driven framework, hybrid framework, Agile Continuous Integration Automation Framework. Exploit opportunities to design Web services based SOAP Automation Frameworks with the help of SOA, ETL basics and SQL Automation scripts to validate Database Systems! Use construction practices using Object Recognition Technology of test automation tools and capture dynamic web elements. Debug problems in software development life cycle to improve testing process using test estimation techniques, tool selection process. Build quality automation scripts by understanding the machine learning basics of selenium automation framework Resolve automation issues and introduce cucumber, Specflow based Behaviour Driven Development and Test Driven Development in functional testing.				Excluded	Excluded	new_screen			2						
306	Behave	ATDD by Example: A Practical Guide to Acceptance Test-Driven Development	With Acceptance Test-Driven Development (ATDD), business customers, testers, and developers can collaborate to produce testable requirements that help them build higher quality software more rapidly. However, ATDD is still widely misunderstood by many practitioners. ATDD by Example is the first practical, entry-level, hands-on guide to implementing and successfully applying it. ATDD pioneer Markus Grtner walks readers step by step through deriving the right systems from business users, and then implementing fully automated, functional tests that accurately reflect business requirements, are intelligible to stakeholders, and promote more effective development. Through two end-to-end case studies, Grtner demonstrates how ATDD can be applied using diverse frameworks and languages. Each case study is accompanied by an extensive set of artifacts, including test automation classes, step definitions, and full sample implementations. These realistic examples illuminate ATDDs fundamental principles, show how ATDD fits into the broader development process, highlight tips from Grtners extensive experience, and identify crucial pitfalls to avoid. Readers will learn to Master the thought processes associated with successful ATDD implementationUse ATDD with Cucumber to describe software in ways businesspeople can understand Test web pages using ATDD toolsBring ATDD to Java with the FitNesse wiki-based acceptance test framework Use examples more effectively in Behavior-Driven Development (BDD)Specify software collaboratively through innovative workshopsImplement more user-friendly and collaborative test automationTest more cleanly, listen to test results, and refactor tests for greater value If youre a tester, analyst, developer, or project manager, this book offers a concrete foundation for achieving real benefits with ATDD nowand it will help you reap even more value as you gain experience.		Grtner, Markus; Grtner, Markus		With Acceptance Test-Driven Development (ATDD), business customers, testers, and developers can collaborate to produce testable requirements that help them build higher quality software more rapidly. However, ATDD is still widely misunderstood by many practitioners. ATDD by Example is the first practical, entry-level, hands-on guide to implementing and successfully applying it. ATDD pioneer Markus Grtner walks readers step by step through deriving the right systems from business users, and then implementing fully automated, functional tests that accurately reflect business requirements, are intelligible to stakeholders, and promote more effective development. Through two end-to-end case studies, Grtner demonstrates how ATDD can be applied using diverse frameworks and languages. Each case study is accompanied by an extensive set of artifacts, including test automation classes, step definitions, and full sample implementations. These realistic examples illuminate ATDDs fundamental principles, show how ATDD fits into the broader development process, highlight tips from Grtners extensive experience, and identify crucial pitfalls to avoid. Readers will learn to Master the thought processes associated with successful ATDD implementationUse ATDD with Cucumber to describe software in ways businesspeople can understand Test web pages using ATDD toolsBring ATDD to Java with the FitNesse wiki-based acceptance test framework Use examples more effectively in Behavior-Driven Development (BDD)Specify software collaboratively through innovative workshopsImplement more user-friendly and collaborative test automationTest more cleanly, listen to test results, and refactor tests for greater value If youre a tester, analyst, developer, or project manager, this book offers a concrete foundation for achieving real benefits with ATDD nowand it will help you reap even more value as you gain experience.				Excluded	Excluded	new_screen			2						
307	Behave	A serious gaming framework for decision support on hydrological hazards	With increasing population and human intervention on the natural environment, hazards are a growing threat, coming in many forms, including floods, droughts, soil erosion, and water pollution. A key approach to mitigate hydrological disaster risk at the community level is informed planning with decision support systems. The literature shows emerging efforts on multi-hazard decision support systems for hydrological disasters and demonstrates the need for an engaging, accessible, and collaborative serious game environment facilitating the relationship between the environment and communities. In this study, a web-based decision support tool (DST) was developed for hydrological multi-hazard analysis while employing gamification techniques to introduce a competitive element. The serious gaming environment provides functionalities for intuitive management, visualization, and analysis of geospatial, hydrological, and economic data to help stakeholders in the decision-making process regarding hydrological hazard preparedness and response. Major contributions of the presented DST include involving the community in environmental decision making by reducing the technical complexity required for analysis, increasing community awareness for the environmental and socio-economic consequences of hydrological hazards, and allowing stakeholders to discover and discuss potential trade-offs to hazardous scenarios considering the limitations in budget, regulations, and technicality. The paper describes the software design approaches and system architecture applied for a modular, secure, and scalable software as well as the framework's intuitive web-based user interfaces for real-time and collaborative data analysis and damage assessment. Finally, a case study was conducted to demonstrate the usability of DST in a formal setting and to measure user satisfaction with surveys.	Serious games, Multi-hazard tournament, Decision support systems, Hydrological data management and visualization, Web-based systems	Sermet, Yusuf; Demir, Ibrahim; Muste, Marian	Science of The Total Environment	With increasing population and human intervention on the natural environment, hazards are a growing threat, coming in many forms, including floods, droughts, soil erosion, and water pollution. A key approach to mitigate hydrological disaster risk at the community level is informed planning with decision support systems. The literature shows emerging efforts on multi-hazard decision support systems for hydrological disasters and demonstrates the need for an engaging, accessible, and collaborative serious game environment facilitating the relationship between the environment and communities. In this study, a web-based decision support tool (DST) was developed for hydrological multi-hazard analysis while employing gamification techniques to introduce a competitive element. The serious gaming environment provides functionalities for intuitive management, visualization, and analysis of geospatial, hydrological, and economic data to help stakeholders in the decision-making process regarding hydrological hazard preparedness and response. Major contributions of the presented DST include involving the community in environmental decision making by reducing the technical complexity required for analysis, increasing community awareness for the environmental and socio-economic consequences of hydrological hazards, and allowing stakeholders to discover and discuss potential trade-offs to hazardous scenarios considering the limitations in budget, regulations, and technicality. The paper describes the software design approaches and system architecture applied for a modular, secure, and scalable software as well as the framework's intuitive web-based user interfaces for real-time and collaborative data analysis and damage assessment. Finally, a case study was conducted to demonstrate the usability of DST in a formal setting and to measure user satisfaction with surveys.				Excluded	Excluded	new_screen			2						
308	Behave	Towards accountability driven development for machine learning systems	With rapid deployment of Machine Learning (ML) systems into diverse domains such as healthcare and autonomous driving, important questions regarding accountability in case of incidents resulting from ML errors remain largely unsolved. To improve accountability of ML systems, we introduce a framework called Accountability Driven Development (ADD). Our framework reuses Behaviour Driven Development (BDD) approach to describe testing scenarios and system behaviours in ML Systems’ development using natural language, guides and forces developers and intended users to actively record necessary accountability information in the design and implementation stages. In this paper, we illustrate how to transform accountability requirements to specific scenarios and provide syntax to describe them. The use of natural language allows non technical collaborators such as stakeholders and non ML domain experts deeply engaged in ML system development to provide more comprehensive evidence to support system’s accountability. This framework also attributes the responsibility to the whole project team including the intended users rather than putting all the accountability burden on ML engineers only. Moreover, this framework can be considered as a combination of both system test and acceptance test, thus making the development more efficient. We hope this work can attract more engineers to use our idea, which enables them to create more accountable ML systems. Copyright © 2021 for this paper by its authors.		Fung C.P., Pang W., Naja I., Markovic M., Edwards P.	CEUR Workshop Proceedings	With rapid deployment of Machine Learning (ML) systems into diverse domains such as healthcare and autonomous driving, important questions regarding accountability in case of incidents resulting from ML errors remain largely unsolved. To improve accountability of ML systems, we introduce a framework called Accountability Driven Development (ADD). Our framework reuses Behaviour Driven Development (BDD) approach to describe testing scenarios and system behaviours in ML Systems’ development using natural language, guides and forces developers and intended users to actively record necessary accountability information in the design and implementation stages. In this paper, we illustrate how to transform accountability requirements to specific scenarios and provide syntax to describe them. The use of natural language allows non technical collaborators such as stakeholders and non ML domain experts deeply engaged in ML system development to provide more comprehensive evidence to support system’s accountability. This framework also attributes the responsibility to the whole project team including the intended users rather than putting all the accountability burden on ML engineers only. Moreover, this framework can be considered as a combination of both system test and acceptance test, thus making the development more efficient. We hope this work can attract more engineers to use our idea, which enables them to create more accountable ML systems. Copyright © 2021 for this paper by its authors.				Included	Included	new_screen			2						
309	Behave	Automated Acceptance Test Refactoring	With the increasing popularity of agile software development and Test-Driven-Development, also maintenance of acceptance test has become an important issue. In this paper, we describe a concept and a tool for automated acceptance test maintenance using a refactoring approach. Acceptance tests are user tests which are used to determine if a system satisfies acceptance criteria and to enable a customer to determine whether or not to accept the system. In agile development acceptance test are also used as a mean for specification, i.e. acceptance tests are written in advance to the production code (called Behavior-Driven-Development - BDD). In an agile project this poses three major challenges with respect to maintenance of acceptance tests: new requirements may cause changes in the acceptance criteria, which require the system under test to be adapted; when the system under test undergoes a major restructuring, even the acceptance test might have to be adapted; with the increasing acceptance test suite in an agile project the tests themselves may undergo a major reorganization. Having a large acceptance test base, doing these refactorings manually is error prone and causes a lot of effort. In this paper we present a concept and tool for executing automated refactoring for Fit acceptance tests, which significantly reduces the effort for test maintenance and makes them much less error prone.	acceptance test; automation; eclipse; maintenance; plug-in; refactoring	Borg, Rodrick; Kropp, Martin	Proceedings of the 4th Workshop on Refactoring Tools	With the increasing popularity of agile software development and Test-Driven-Development, also maintenance of acceptance test has become an important issue. In this paper, we describe a concept and a tool for automated acceptance test maintenance using a refactoring approach. Acceptance tests are user tests which are used to determine if a system satisfies acceptance criteria and to enable a customer to determine whether or not to accept the system. In agile development acceptance test are also used as a mean for specification, i.e. acceptance tests are written in advance to the production code (called Behavior-Driven-Development - BDD). In an agile project this poses three major challenges with respect to maintenance of acceptance tests: new requirements may cause changes in the acceptance criteria, which require the system under test to be adapted; when the system under test undergoes a major restructuring, even the acceptance test might have to be adapted; with the increasing acceptance test suite in an agile project the tests themselves may undergo a major reorganization. Having a large acceptance test base, doing these refactorings manually is error prone and causes a lot of effort. In this paper we present a concept and tool for executing automated refactoring for Fit acceptance tests, which significantly reduces the effort for test maintenance and makes them much less error prone.				Excluded	Excluded	new_screen			2						
310	Behave	Automated acceptance test refactoring	With the increasing popularity of agile software development and Test-Driven-Development, also maintenance of acceptance test has become an important issue. In this paper, we describe a concept and a tool for automated acceptance test maintenance using a refactoring approach. Acceptance tests are user tests which are used to determine if a system satisfies acceptance criteria and to enable a customer to determine whether or not to accept the system. In agile development acceptance test are also used as a mean for specification, i.e. acceptance tests are written in advance to the production code (called Behavior-Driven-Development - BDD). In an agile project this poses three major challenges with respect to maintenance of acceptance tests: new requirements may cause changes in the acceptance criteria, which require the system under test to be adapted; when the system under test undergoes a major restructuring, even the acceptance test might have to be adapted; with the increasing acceptance test suite in an agile project the tests themselves may undergo a major reorganization. Having a large acceptance test base, doing these refactorings manually is error prone and causes a lot of effort. In this paper we present a concept and tool for executing automated refactoring for Fit acceptance tests, which significantly reduces the effort for test maintenance and makes them much less error prone. Copyright 2011 ACM.		Borg R., Kropp M.	WRT 2011 - Proceedings of the 4th Workshop on Refactoring Tools, co-located with ICSE 2011	With the increasing popularity of agile software development and Test-Driven-Development, also maintenance of acceptance test has become an important issue. In this paper, we describe a concept and a tool for automated acceptance test maintenance using a refactoring approach. Acceptance tests are user tests which are used to determine if a system satisfies acceptance criteria and to enable a customer to determine whether or not to accept the system. In agile development acceptance test are also used as a mean for specification, i.e. acceptance tests are written in advance to the production code (called Behavior-Driven-Development - BDD). In an agile project this poses three major challenges with respect to maintenance of acceptance tests: new requirements may cause changes in the acceptance criteria, which require the system under test to be adapted; when the system under test undergoes a major restructuring, even the acceptance test might have to be adapted; with the increasing acceptance test suite in an agile project the tests themselves may undergo a major reorganization. Having a large acceptance test base, doing these refactorings manually is error prone and causes a lot of effort. In this paper we present a concept and tool for executing automated refactoring for Fit acceptance tests, which significantly reduces the effort for test maintenance and makes them much less error prone. Copyright 2011 ACM.				Excluded	Excluded	new_screen			2						
311	Behave	Building Applications with Scala	Write modern, scalable, and reactive applications with the power of ScalaAbout This BookDelves into the intricacies of functional reactive programming with ScalaExplores frameworks like Akka, Play and Slick used to develop efficient applications A step by step guide with plenty of examples showing practical implementation of essential concepts Who This Book Is ForIf you are a Java or JVM developer who wants to use Scala to build reactive functional applications for the JVM platform, then this book is for you. Prior knowledge of Java or functional programing would help. No Scala knowledge is required. What You Will Learn Use Akka to create a chat service for your appEquip yourself with the techniques and tools to build reports and build database persistence with Scala and Slick Develop a customer-facing Rest API that makes use of Scala and SprayMake use of the Scala web development principles and scale up the architecture of your applicationGet familiar with the core principles and concepts of Functional Programming Use the Play framework to create models, controllers, and views Develop reactive backing frameworks by writing code with RxScala Discover what proper testing entails with Scala using behavior-driven development In DetailScala is known for incorporating both object-oriented and functional programming into a concise and extremely powerful package. However, creating an app in Scala can get a little tricky because of the complexity the language has. This book will help you dive straight into app development by creating a real, reactive, and functional application. We will provide you with practical examples and instructions using a hands-on approach that will give you a firm grounding in reactive functional principles. The book will take you through all the fundamentals of app development within Scala as you build an application piece by piece. We've made sure to incorporate everything you need from setting up to building reports and scaling architecture. This book also covers the most useful tools available in the Scala ecosystem, such as Slick, Play, and Akka, and a whole lot more. It will help you unlock the secrets of building your own up-to-date Scala application while maximizing performance and scalability. Style and approach This book takes a step-by-step approach to app development with Scala. It will place special emphasis on functional language. It will teach you the core benefits of Scala and the fundamentals of functional programming by developing a robust application.		Pacheco, Diego		Write modern, scalable, and reactive applications with the power of ScalaAbout This BookDelves into the intricacies of functional reactive programming with ScalaExplores frameworks like Akka, Play and Slick used to develop efficient applications A step by step guide with plenty of examples showing practical implementation of essential concepts Who This Book Is ForIf you are a Java or JVM developer who wants to use Scala to build reactive functional applications for the JVM platform, then this book is for you. Prior knowledge of Java or functional programing would help. No Scala knowledge is required. What You Will Learn Use Akka to create a chat service for your appEquip yourself with the techniques and tools to build reports and build database persistence with Scala and Slick Develop a customer-facing Rest API that makes use of Scala and SprayMake use of the Scala web development principles and scale up the architecture of your applicationGet familiar with the core principles and concepts of Functional Programming Use the Play framework to create models, controllers, and views Develop reactive backing frameworks by writing code with RxScala Discover what proper testing entails with Scala using behavior-driven development In DetailScala is known for incorporating both object-oriented and functional programming into a concise and extremely powerful package. However, creating an app in Scala can get a little tricky because of the complexity the language has. This book will help you dive straight into app development by creating a real, reactive, and functional application. We will provide you with practical examples and instructions using a hands-on approach that will give you a firm grounding in reactive functional principles. The book will take you through all the fundamentals of app development within Scala as you build an application piece by piece. We've made sure to incorporate everything you need from setting up to building reports and scaling architecture. This book also covers the most useful tools available in the Scala ecosystem, such as Slick, Play, and Akka, and a whole lot more. It will help you unlock the secrets of building your own up-to-date Scala application while maximizing performance and scalability. Style and approach This book takes a step-by-step approach to app development with Scala. It will place special emphasis on functional language. It will teach you the core benefits of Scala and the fundamentals of functional programming by developing a robust application.				Excluded	Excluded	new_screen			2						
312	Behave	Documentation by example	Writing documentation can be fun and rewarding, but keeping up with an ever-changing system can take a toll on that joy. The documentation tends to get either expensive (duplication-intense), outdated or non-existing. This demonstration will present an open source tool that addresses these shortcomings by extending the BDD[1] approach to provide rich and human readable documents automatically from a JUnit[2] test suite. You'll learn how to include snippets, run-time data and more in your documents, all this with minimal effort and intrusion. This approach is suitable both for APIs and GUIs, as will be shown. © 2009 Springer Berlin Heidelberg.		Brolund D.	Lecture Notes in Business Information Processing	Writing documentation can be fun and rewarding, but keeping up with an ever-changing system can take a toll on that joy. The documentation tends to get either expensive (duplication-intense), outdated or non-existing. This demonstration will present an open source tool that addresses these shortcomings by extending the BDD[1] approach to provide rich and human readable documents automatically from a JUnit[2] test suite. You'll learn how to include snippets, run-time data and more in your documents, all this with minimal effort and intrusion. This approach is suitable both for APIs and GUIs, as will be shown. © 2009 Springer Berlin Heidelberg.				Included	Included	new_screen			2						
313	Behave	Discovery: Explore Behaviour Using Examples (Volume 1)	Written by the creator of SpecFlow and the author of The Cucumber for Java Book, this book provides inside information on how to get the most out of the discovery phase of Behaviour Driven Development (BDD). This practical guide demonstrates good collaboration techniques, illustrated by concrete examples. This book is written for everyone involved in the specification and delivery of software (including product owners, business analysts, developers, and testers). The book starts by explaining the reasons BDD exists in the first place and describes techniques for getting the most out of collaboration between business and delivery team members. This is the first in the BDD Books series that will guide you through the entire development process, including specific technical practices needed to successfully drive development using collaboratively-authored specifications and living documentation.		Nagy, Gaspar; Rose, Seb		Written by the creator of SpecFlow and the author of The Cucumber for Java Book, this book provides inside information on how to get the most out of the discovery phase of Behaviour Driven Development (BDD). This practical guide demonstrates good collaboration techniques, illustrated by concrete examples. This book is written for everyone involved in the specification and delivery of software (including product owners, business analysts, developers, and testers). The book starts by explaining the reasons BDD exists in the first place and describes techniques for getting the most out of collaboration between business and delivery team members. This is the first in the BDD Books series that will guide you through the entire development process, including specific technical practices needed to successfully drive development using collaboratively-authored specifications and living documentation.				Excluded	Excluded	new_screen			2						
314	Behave	The RSpec Book: Behaviour Driven Development with Rspec, Cucumber, and Friends	"You'll get started right away with RSpec 2 and Cucumber by developing a simple game, using Cucumber to express high-level requirements in language your customer understands, and RSpec to express more granular requirements that focus on the behavior of individual objects in the system. You'll learn how to use test doubles (mocks and stubs) to control the environment and focus the RSpec examples on one object at a time, and how to customize RSpec to ""speak"" in the language of your domain. You'll develop Rails 3 applications and use companion tools such as Webrat and Selenium to express requirements for web applications both in memory and in the browser. And you'll learn to specify Rails views, controllers, and models, each in complete isolation from the other. Whether you're developing applications, frameworks, or the libraries that power them, The RSpec Book will help you write better code, better tests, and deliver better software to happier users."		Chelimsky, David; Astels, Dave; Helmkamp, Bryan; North, Dan; Dennis, Zach; Hellesoy, Aslak		"You'll get started right away with RSpec 2 and Cucumber by developing a simple game, using Cucumber to express high-level requirements in language your customer understands, and RSpec to express more granular requirements that focus on the behavior of individual objects in the system. You'll learn how to use test doubles (mocks and stubs) to control the environment and focus the RSpec examples on one object at a time, and how to customize RSpec to ""speak"" in the language of your domain. You'll develop Rails 3 applications and use companion tools such as Webrat and Selenium to express requirements for web applications both in memory and in the browser. And you'll learn to specify Rails views, controllers, and models, each in complete isolation from the other. Whether you're developing applications, frameworks, or the libraries that power them, The RSpec Book will help you write better code, better tests, and deliver better software to happier users."				Excluded	Excluded	new_screen			2						
315	Behave	The Cucumber Book: Behaviour-Driven Development for Testers and Developers	Your customers want rock-solid, bug-free software that does exactly what they expect it to do. Yet they can't always articulate their ideas clearly enough for you to turn them into code. The Cucumber Book dives straight into the core of the problem: communication between people. Cucumber saves the day; it's a testing, communication, and requirements tool - all rolled into one. We'll show you how to express your customers' wild ideas as a set of clear, executable specifications that everyone on the team can read. You'll learn how to feed those examples into Cucumber and let it guide your development. You'll build just the right code to keep your customers happy, and not a line more. The first part of the book teaches you how to use the core features of Cucumber. You'll learn how to use Cucumber's Gherkin DSL to describe– in plain language - the behavior your customers want from the system. You'll learn how to write Ruby code that interprets those plain language specifications and checks them against your application. In Part 2, you'll consolidate the knowledge you just gained with a worked example. Although it was born in the Ruby community, you can use Cucumber to test almost any system, from a simple shell script or a Perl script, to enterprise PHP or a Java web application. In Part 3, you'll find a selection of recipes for some of the most common situations you'll encounter using Cucumber in the wild. You'll learn how to test Ajax-heavy web applications with Capybara and Selenium, REST web services, Ruby on Rails applications, command-line applications, legacy applications and lots more! Written by the creator of Cucumber and one of its most experienced users and contributors, The Cucumber Book is an authoritative guide that will give you and your team all the knowledge you need to start using Cucumber with confidence. What You Need: Windows, Mac OS X (with XCode) or Linux Ruby 1.9.2 and upwards		Wynne, Matt; Hellesoy, Aslak		Your customers want rock-solid, bug-free software that does exactly what they expect it to do. Yet they can't always articulate their ideas clearly enough for you to turn them into code. The Cucumber Book dives straight into the core of the problem: communication between people. Cucumber saves the day; it's a testing, communication, and requirements tool - all rolled into one. We'll show you how to express your customers' wild ideas as a set of clear, executable specifications that everyone on the team can read. You'll learn how to feed those examples into Cucumber and let it guide your development. You'll build just the right code to keep your customers happy, and not a line more. The first part of the book teaches you how to use the core features of Cucumber. You'll learn how to use Cucumber's Gherkin DSL to describe– in plain language - the behavior your customers want from the system. You'll learn how to write Ruby code that interprets those plain language specifications and checks them against your application. In Part 2, you'll consolidate the knowledge you just gained with a worked example. Although it was born in the Ruby community, you can use Cucumber to test almost any system, from a simple shell script or a Perl script, to enterprise PHP or a Java web application. In Part 3, you'll find a selection of recipes for some of the most common situations you'll encounter using Cucumber in the wild. You'll learn how to test Ajax-heavy web applications with Capybara and Selenium, REST web services, Ruby on Rails applications, command-line applications, legacy applications and lots more! Written by the creator of Cucumber and one of its most experienced users and contributors, The Cucumber Book is an authoritative guide that will give you and your team all the knowledge you need to start using Cucumber with confidence. What You Need: Windows, Mac OS X (with XCode) or Linux Ruby 1.9.2 and upwards				Excluded	Excluded	new_screen			2						
316	Behave	A Basic Spring Boot Application	We could start writing code directly, but that, even while being pragmatic, would be far from being a real case. Instead, we'll define a product that we want to build, and we'll split it into small chunks. This requirements-oriented approach is used throughout the book to make it more practical. In real life, you'll always have these business requirements.	specific testing technologies/languages	Macero Garc{\'i}a, Mois{\'e}s	Learn Microservices with Spring Boot	https://doi.org/10.1007/978-1-4842-6131-6_3		25--74	"@Inbook{MaceroGarcia2020,
    author = ""Macero Garc{\'i}a, Mois{\'e}s"",
    title = ""A Basic Spring Boot Application"",
    bookTitle = ""Learn Microservices with Spring Boot: A Practical Approach to RESTful Services Using an Event-Driven Architecture, Cloud-Native Patterns, and Containerization"",
    year = ""2020"",
    publisher = ""Apress"",
    address = ""Berkeley, CA"",
    pages = ""25--74"",
    abstract = ""We could start writing code directly, but that, even while being pragmatic, would be far from being a real case. Instead, we'll define a product that we want to build, and we'll split it into small chunks. This requirements-oriented approach is used throughout the book to make it more practical. In real life, you'll always have these business requirements."",
    isbn = ""978-1-4842-6131-6"",
    doi = ""10.1007/978-1-4842-6131-6\_3"",
    url = ""https://doi.org/10.1007/978-1-4842-6131-6\_3""
}"	Excluded	Excluded	new_screen			2	Springer Science and Business Media LLC		A Basic Spring Boot Application	http://link.springer.com/chapter/10.1007/978-1-4842-6131-6_3	Apress	nan; Keywords; References
317	Behave	A Beginner's Guide to Scala, Object Orientation and Functional Programming		specific testing technologies/languages	Dr. John Hunt						Excluded	Excluded	new_screen			2						
318	Behave	A Circumstantial Methodological Analysis of Recent Studies on NLP-driven Test Automation Approaches	From manual testing to test automation, test generation is advancing. With the emergence of new challenges—and legacy challenges already persisting—there is a great need of turning test creation activity into a way that is more responsive and effortless. Natural language processing, with its applicability in different domains, is swiftly adopted by researchers in software testing discipline to perform automation of such activities. Attempts like this will bring in prominent paradigm shifts in the conventional and mundane non-automated frameworks of test cases creation (software development activity) from requirement specifications. To explore, as how natural language processing could be employed to assist software testing, this paper presents a detailed article with methodological investigation of some recent research studies. The detailed knowledge will help the practitioners to get insights of how natural language processing (NLP) is being carried out in testing domain and what specific role does each term associated with it will play.	NLP in testing	Atulya Gupta&; Rajendra Prasad Mahapatra	Intelligent Systems	https://doi.org/10.1007/978-981-33-6081-5_14		pp 155–167		Excluded	Excluded	new_screen			2	SpringerLink		A Circumstantial Methodological Analysis of Recent Studies on NLP-driven Test Automation Approaches	http://link.springer.com/chapter/10.1007/978-981-33-6081-5_14	Springer, Singapore	nan; Keywords; References; Year; Bibtex
319	Behave	A distributable event-oriented architecture for activity recognition in smart homes	http://link.springer.com/article/10.1007/s40860-020-00125-y		Cédric DemongivertKévin BouchardSébastien GabouryBruno BouchardMaxime LussierMaxime ParenteauCatherine LalibertéMélanie CoutureNathalie BierSylvain Giroux		http://link.springer.com/article/10.1007/s40860-020-00125-y				Excluded	Excluded	new_screen			2						
320	Behave	A domain-specific language to design false data injection tests for air traffic control systems	http://link.springer.com/article/10.1007/s10009-021-00604-4		Alexandre VernotteAymeric CretinBruno LegeardFabien Peureux		http://link.springer.com/article/10.1007/s10009-021-00604-4				Excluded	Excluded	new_screen			2						
321	Behave	A Dynamic System Model Using Agile Method Techniques Applied to Geomatics	In this paper we propose the use of a model that represents a territory across a dynamic system. As part of the process in the definition of the model we used techniques adaptive software engineering, particularly construction tools associated with agile methods. The dynamic system modeling serves to simulate territorial scenarios and analyze their characteristics using geographical information systems. The approach is to design user stories as artifacts that can be used for example by decision makers, urban planners or researchers to more easily observe and read territorial scenarios that can be to present in the evolution of land-use changes in a geographical area of interest. This represents an important advantage because it reduces reading complexity and facilitates analysis because combining agile methods with a simulation model provide a macroscopic and simplified view of a scenario of nature complex.	Dynamic systems; Geomatics; GIS; Agile methods	René Rodríguez Zamora,; Álvaro Peraza Garzón&; Iliana Amabely Silva Hernández	International Congress of Telematics and Computing	https://doi.org/10.1007/978-3-030-33229-7_7		pp 71–82		Excluded	Excluded	new_screen			2	SpringerLink		A Dynamic System Model Using Agile Method Techniques Applied to Geomatics	http://link.springer.com/chapter/10.1007/978-3-030-33229-7_7	Springer, Cham	nan; References; Year; Bibtex
322	Behave	A Four-Leaf Clover Shape Methodology for Prosumer Service Developments	Software development in software development organizations is a complex process and may require knowledge management techniques. If the development is oriented to the creation of a prosumer platform for managing ambient intelligence scenarios, the development could be even more complex. In this paper we present a prosumer model based on our experiences developing prosumer platforms for ambient intelligence scenarios. The model we proposed is composed of a set of six roles (users, service consumers, prosumers, advanced prosumers, platform developers and domain experts), a lifecycle for the prosumer services with eight different states and a methodology where four of the mentioned roles cooperate to develop a service provisioning platform and to propose new add-ons to improve the platform functionality in order to create services in a concrete ambient intelligence scenario.		Diego Martín,; Ramon Alcarria,; Alvaro Sánchez-Picot,; Tomás Robles&; Diego Sánchez de Rivera	International Conference on Ubiquitous Computing and Ambient Intelligence	https://doi.org/10.1007/978-3-319-13102-3_78		pp 488–495		Excluded	Excluded	new_screen			2	SpringerLink		A Four-Leaf Clover Shape Methodology for Prosumer Service Developments	http://link.springer.com/chapter/10.1007/978-3-319-13102-3_78	Springer, Cham	nan; Keywords; References; Year; Bibtex
323	Behave	A Lightweight Semi-automated Acceptance Test-Driven Development Approach for Web Applications	Applying Acceptance Test Driven Development (ATDD) in the context of web applications is a difficult task due to the intricateness of existing tools/frameworks and, more in general, of the proposed approaches. In this work, we present a simple approach for developing web applications in ATDD mode, based on the usage of Screen Mockups and Selenium IDE.	Test Suite; User Story; Agile Development; Test Script; Real Industrial Case	Diego Clerissi,; Maurizio Leotta,; Gianna Reggio&; Filippo Ricca	International Conference on Web Engineering	https://doi.org/10.1007/978-3-319-38791-8_55		pp 593–597		Excluded	Excluded	new_screen			2	SpringerLink		A Lightweight Semi-automated Acceptance Test-Driven Development Approach for Web Applications	http://link.springer.com/chapter/10.1007/978-3-319-38791-8_55	Springer, Cham	nan; References; Year; Bibtex
324	Behave	A Literature Review on Story Test Driven Development	This paper presents a literature review on story-test driven development. Our findings suggest that there are many lessons learned papers that provide anecdotal evidence about the benefits and issues related to the story test driven development. We categorized these findings into seven themes: cost, time, people, code design, testing tools, what to test and test automation. We analyzed research papers on story test driven development to find out how many of these anecdotal findings were critically examined by researchers and analyzed the gaps in between. The analysis can be used by researchers as a ground for further empirical investigation.	Story Test Driven Development; Executable Acceptance Test Driven Development; Requirements; Systematic Review; Testing; Empirical software engineering; Agile software development	Shelly Park&; Frank Maurer	International Conference on Agile Software Development	https://doi.org/10.1007/978-3-642-13054-0_20		pp 208–213		Excluded	Excluded	new_screen			2	SpringerLink		A Literature Review on Story Test Driven Development	http://link.springer.com/chapter/10.1007/978-3-642-13054-0_20	Springer, Berlin, Heidelberg	nan; References; Year; Bibtex
325	Behave	A New Ontology-Based Approach for Construction of Domain Model	Domain model is one of the most important artefacts in software engineering. It can be built with the use of domain ontologies. The objective of the authors’ research is to elaborate an effective approach to domain model construction based on knowledge extraction from existing ontologies. A significant element of the approach is knowledge extraction algorithm. In this paper, a modified, more flexible version of the extraction algorithm is presented. A comparison of the new algorithm with the old one is conducted based on a case study. Both algorithms produce similar results regarding quality measures. In contrast to the old algorithm, the new is parameterized and therefore can be applied in an incremental way what is a valuable feature.	Ontology; Knowledge acquisition; Conceptual modeling	Bogumiła Hnatkowska,; Zbigniew Huzar,; Lech Tuzinkiewicz&; Iwona Dubielewicz	Asian Conference on Intelligent Information and Database Systems	https://doi.org/10.1007/978-3-319-54472-4_8		pp 75–85		Excluded	Excluded	new_screen			2	SpringerLink		A New Ontology-Based Approach for Construction of Domain Model	http://link.springer.com/chapter/10.1007/978-3-319-54472-4_8	Springer, Cham	nan; References; Year; Bibtex
326	Behave	A scalable Cloud-based system for data-intensive spatial analysis	http://link.springer.com/article/10.1007/s10009-015-0398-6		R. O. SinnottW. Voorsluys		http://link.springer.com/article/10.1007/s10009-015-0398-6				Excluded	Excluded	new_screen			2						
327	Behave	A Survey on Agile Practices and Challenges of a Global Software Development Team	The Agile Manifesto describes that the most efficient and effective method of conveying information to and within a development team is through face-to-face conversation. However that is not always possible when teams are working in a Global Software Development (GSD) environment. Based on this scenario, this study presents an exploratory data analysis using survey results to explore agile practices and challenges of a global software development team that uses Scaled Agile Framework (SAFe), which is designed for the need of larger organizations. The goal of this study is to understand the team’s level of knowledge in some agile practices and which types of communication are usually prioritized. As in GSD environments team members are geographically spread across multiple regions and time zones, we aim to identify challenges this environment can present. As a result of this exploratory analysis, it has been identified that communication is one of main challenges in GSD environment and that phone calls are considered to be the most efficient type of communication. Additionally, we have also identified that professionals have different levels of confidence in Agile practices and concluded that knowledge transfers among the professionals could help those team members that are not confident in some agile practices to increase their overall confidence and knowledge.	Agile methodologies; Survey; Global Software Development; SAFe	Tatiane LautertORCID:orcid.org/---,; Adolfo Gustavo Serra Seca NetoORCID:orcid.org/---&; Nádia P. KozievitchORCID:orcid.org/---	Brazilian Workshop on Agile Methods	https://doi.org/10.1007/978-3-030-36701-5_11		pp 128–143		Excluded	Excluded	new_screen			2	SpringerLink		A Survey on Agile Practices and Challenges of a Global Software Development Team	http://link.springer.com/chapter/10.1007/978-3-030-36701-5_11	Springer, Cham	nan; References; Year; Bibtex
328	Behave	A Systematic Approach to Automatically Derive Test Cases from Use Cases Specified in Restricted Natural Languages	In many domains, such as avionics, oil and gas, and maritime, a common practice is to derive and execute test cases manually from requirements, where both requirements and test cases are specified in natural language (NL) by domain experts. The manual execution of test cases is largely dependent on the domain experts who wrote the test cases. The process of manual writing of requirements and test cases introduces ambiguity in their description and, in addition, test cases may not be effective since they may not be derived by systematically applying coverage criteria. In this paper, we report on a systematic approach to support automatic derivation of manually executable test cases from use cases. Both use cases and test cases are specified in restricted NLs along with carefully-defined templates implemented in a tool. We evaluate our approach with four case studies (in total having 30 use cases and 579 steps from flows of events), two of which are industrial case studies from the oil/gas and avionics domains. Results show that our tool was able to correctly process all the case studies and systematically (by following carefully-defined structure coverage criteria) generate 30 TCSs and 389 test cases. Moreover, our approach allows defining different test coverage criteria on requirements other than the one already implemented in our tool.		Man Zhang,; Tao Yue,; Shaukat Ali,; Huihui Zhang&; Ji Wu	International Conference on System Analysis and Modeling	https://doi.org/10.1007/978-3-319-11743-0_10		pp 142–157		Excluded	Excluded	new_screen			2	SpringerLink		A Systematic Approach to Automatically Derive Test Cases from Use Cases Specified in Restricted Natural Languages	http://link.springer.com/chapter/10.1007/978-3-319-11743-0_10	Springer, Cham	nan; Keywords; References; Year; Bibtex
329	Behave	A Taxonomy on Continuous Integration and Deployment Tools and Frameworks	Software development has become a critical activity in modern companies. Competitive advantage and customer satisfaction depend strongly on the efficient delivery of new software capabilities. This requires the application of agile methodologies and the use of tools and frameworks which allow a fast and reliable integration and evolution of software systems. Currently, there exist several tools which are used for different purposes all along the software development process. Therefore, it is important for researchers on software engineering and developers to have a wide overview and understanding of the capabilities and limitations of current technology. This paper presents an insightful study of the state of the art on continuous integration and deployment tools. It depicts a taxonomy of current approaches based on their usability during the software development process. Furthermore, it discusses the current challenges and propose a set of study opportunities which could lead further research in this field.		Patricia Ortegon Cano,; Ayrton Mondragon Mejia,; Silvana De Gyves Avila,; Gloria Eva Zagal Dominguez,; Ismael Solis Moreno&; Arianne Navarro Lepe	International Conference on Software Process Improvement	https://doi.org/10.1007/978-3-030-63329-5_22		pp 323–336		Excluded	Excluded	new_screen			2	SpringerLink		A Taxonomy on Continuous Integration and Deployment Tools and Frameworks	http://link.springer.com/chapter/10.1007/978-3-030-63329-5_22	Springer, Cham	nan; Keywords; References; Year; Bibtex
330	Behave	A Test Specification Language for Information Systems Based on Data Entities, Use Cases and State Machines	Testing is one of the most important activities to ensure the quality of a software system. This paper proposes and discusses the TSL (Test Specification Language) that adopts a model-based testing approach for both human-readable and computer-executable specifications of test cases. TSL is strongly inspired on the grammar, nomenclature and writing style as defined by the RSLingo RSL, which is a rigorous requirements specification language. Both RSL and TSL are controlled natural languages that share common concepts such as data entities, use cases and state machines. However, by applying black-box functional testing design techniques, TSL includes and supports four complementary testing strategies, namely: domain analysis testing; use case tests; state machine testing; and acceptance criteria. This paper focuses on the first three testing strategies of TSL. Finally, a simple but effective case study illustrates the overall approach and supports the discussion.	Test Specification Language (TSL); Test case specification; Model based Testing (MBT); Test case generation	Alberto Rodrigues da Silva,; Ana C. R. Paiva,&; Valter E. R. da Silva	International Conference on Model-Driven Engineering and Software Development	https://doi.org/10.1007/978-3-030-11030-7_20		pp 455–474		Excluded	Excluded	new_screen			2	SpringerLink		A Test Specification Language for Information Systems Based on Data Entities, Use Cases and State Machines	http://link.springer.com/chapter/10.1007/978-3-030-11030-7_20	Springer, Cham	nan; References; Year; Bibtex
331	Behave	A Textual Domain Specific Language for User Interface Modelling	User interface development is one of the hardest parts of the software application development. It could be made more efficient by introducing model-driven development approaches and user interface modelling. This paper introduces a textual domain specific language and a corresponding meta-model for describing user interaction using abstract UI patterns that can be transformed into more platform specific UI patterns during application generation. The language also follows use case description format and provides possibilities to add free-form documenting context to the formal constructs used in the language, making the models described in the language suitable both for model driven engineering and requirements elicitation.	User interface modelling; Model driven development; Textual domain specific languages; Domain specific languages; User interface patterns	Mart Karu	Emerging Trends in Computing, Informatics, Systems Sciences, and Engineering	https://doi.org/10.1007/978-1-4614-3558-7_84		pp 985–996		Excluded	Excluded	new_screen			2	SpringerLink		A Textual Domain Specific Language for User Interface Modelling	http://link.springer.com/chapter/10.1007/978-1-4614-3558-7_84	Springer, New York, NY	nan; References; Year; Bibtex
332	Behave	A Very Brief History of Test-Driven Development	My intention in writing this chapter is not to copy and paste clichés from blogs (the following excerpt aside) or pretend I was part of the historic events (like the agile manifesto or Extreme Programming activities) that led to the creation of test-driven development as a methodology – trust me, I’m not that old.	General books on testing	Juntao Qiu	Test-Driven Development with React	https://doi.org/10.1007/978-1-4842-6972-5_1		pp 1–13		Excluded	Excluded	new_screen			2	SpringerLink		A Very Brief History of Test-Driven Development	http://link.springer.com/chapter/10.1007/978-1-4842-6972-5_1	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
333	Behave	Lean-agile acceptance test-driven development:better software through collaboration by Ken Pugh	No abstract available.		Gary Downs	ACM SIGSOFT Software Engineering Notes	https://doi.org/10.1145/1988997.1989006				Excluded	Excluded	new_screen			2	ACM		Acceptance Test Driven Development	http://link.springer.com/chapter/10.1007/978-1-4842-3832-5_16	Association for Computing Machinery	nan; Keywords; References; Pages; Year; Bibtex
334	Behave	Acceptance tests for validating ARIA requirements in widgets	http://link.springer.com/article/10.1007/s10209-015-0437-9		Willian Massami WatanabeRenata P. M. FortesAna Luiza Dias		http://link.springer.com/article/10.1007/s10209-015-0437-9				Excluded	Excluded	new_screen			2						
335	Behave	Adopting Agile Software Development Combined with User-Centered Design and Lean Startup: A Systematic Literature Review on Maturity Models	The use of Agile in the software development industry in the past two decades revealed that it is lackluster in some aspects, such as in guaranteeing user involvement and assuring that the right software is being built. There are reports that combining Agile with Lean Startup and User-Centered Design (UCD) helps in overcoming these shortcomings while also yielding several other benefits. However, there is not much documentation on how to use this “combined approach” and adapting existing organizations to use it is a challenge in of itself, in which the use of an instrument to guide or assess such transformations is typically pivotal to their success. As such, in this paper we seek to identify maturity models that assess the use of Agile, Lean Startup, and UCD. We conducted a systematic literature review of maturity models for these three methods published between 2001 and 2020. We characterized the maturity models and determined how they see maturity, how they are applied, and how they were evaluated. As an extended version of a previous paper, we augmented our analysis criteria and further classified the models in how they interpret maturity and what strategy they suggest when undergoing an improvement process, in addition to providing new insight on various aspects of the models. We found 35 maturity models, of which 23 were for Agile, 5 for Lean thinking, 5 for UCD, and 2 for Agile and UCD combined. No models for the combination of the three methods were found (nor for Lean Startup), as expected due to the novelty of the approach. Existing models mostly focus on practice adoption and acquiring continuous improvement capabilities, and are typically developed with a specific context in mind. We also note a lack of proper evaluation procedures being conducted on the majority of models, which could be due to the lack of well-established maturity model development methods and guidelines.	Systematic literature review; Maturity model; Agile software development; Lean startup; User-Centered Design	Maximilian Zorzetti,; Cassiano Moralles,; Larissa Salerno,; Eliana Pereira,; Sabrina Marczak&; Ricardo Bastos	International Conference on Enterprise Information Systems	https://doi.org/10.1007/978-3-030-75418-1_24		pp 517–541		Excluded	Excluded	new_screen			2	SpringerLink		Adopting Agile Software Development Combined with User-Centered Design and Lean Startup: A Systematic Literature Review on Maturity Models	http://link.springer.com/chapter/10.1007/978-3-030-75418-1_24	Springer, Cham	nan; References; Year; Bibtex
336	Behave	Advanced Guide to Python 3 Programming	http://link.springer.com/book/10.1007/978-3-030-25943-3	Concurrent Python; Games in Python; Databases in Python; Reactive Programming; Python Graphics and Graphical User Interfaces; Graphics; Games; Databases; Logging; Concurrency; Advanced Language Concepts; Networking and Data Science	John Hunt		http://link.springer.com/book/10.1007/978-3-030-25943-3				Excluded	Excluded	new_screen			2	SpringerLink		Advanced Guide to Python 3 Programming	http://link.springer.com/book/10.1007/978-3-030-25943-3	Springer Link	nan; Venue; Abstract; References; Pages; Year; Bibtex; DOI
337	Behave	Advances in infrastructures and tools for multiagent systems	http://link.springer.com/article/10.1007/s10796-014-9493-6		Juan M. AlberolaVicent BottiJose M. Such		http://link.springer.com/article/10.1007/s10796-014-9493-6				Excluded	Excluded	new_screen			2						
338	Behave	Agile Android	As a developer, you want to get better at Android development, have fewer bugs, make a better product, or simply make the customer happy. Whether you're developing for the web, mobile, or even the desktop, it pays to adopt an Agile approach to your development and testing.		Godfrey Nolan,; Onur Cinar&; David Truxall	Android Best Practices	https://doi.org/10.1007/978-1-4302-5858-2_4		pp 75–92		Excluded	Excluded	new_screen			2	SpringerLink		Agile Android	http://link.springer.com/chapter/10.1007/978-1-4302-5858-2_4	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
339	Behave	Agile Practices in Azure DevOps and TFS	This chapter focuses on more technical aspects of Agile practices. They might not be linked directly to project management or product management, but they are great ways to enhance the quality of your coding efforts. In Chapter3, you were given a brief overview of eXtreme Programming, or XP, as it is called. As you may remember, Scrum, for example, does not say how you should work using the Scrum framework. XP is much more practice oriented; it gives you hands-on advice on how you should work.		Joachim Rossberg	Agile Project Management with Azure DevOps	https://doi.org/10.1007/978-1-4842-4483-8_6		pp 197–228		Excluded	Excluded	new_screen			2	SpringerLink		Agile Practices in Azure DevOps and TFS	http://link.springer.com/chapter/10.1007/978-1-4842-4483-8_6	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
340	Behave	Agile Practices, Collaboration and Experience	Agile Software Development has been around for more than fifteen years and is now widespread. How does experience effect the application of agile methods in organizations and what are the implications on the individual and organizational culture? This paper presents in-depth analysis of the Swiss Agile Study 2014. Switzerland offers an illustrative microcosm of software development, with a range of industry domains and sizes, and well-educated and internationally aware professionals. The study included more than a hundred professionals and managers, contacted through professional and industry associations. The topics addressed included experience with Agile development, motivations for adopting it, barriers perceived, specific practices used, and specific benefits realized. Analysis of the data identified important trends and differences. Agile experience seems to be an important factor, which affects many aspects of practice and workplace culture. More troubling is that it appears stress and overwork may be common among Agile professionals. All these findings illustrate important differences between Agile processes as prescribed, and as actually practiced.	Agile; Software process; Collaboration; Organizational culture; Software practices	Martin Kropp,; Andreas Meier&; Robert Biddle	International Conference on Product-Focused Software Process Improvement	https://doi.org/10.1007/978-3-319-49094-6_28		pp 416–431		Excluded	Excluded	new_screen			2	SpringerLink		Agile Practices, Collaboration and Experience	https://link.springer.com/chapter/10.1007/978-3-319-49094-6_28	Springer, Cham	nan; References; Year; Bibtex
341	Behave	Agile Test Automation			Manfred BaumgartnerMartin KlonkChristian MastnakHelmut PichlerRichard SeidlSiegfried Tanczos						Excluded	Excluded	new_screen			2						
342	Behave	An Empirical Study of Agile Testing in A Distributed Software Development Project	The software engineering industry has witnessed an increasing number of innovative methods and practices in the last decade at different levels, ranging from development processes to software projects and from testing to verification software products. Extensive studies have been conducted empirically to investigate and discuss the impact of using agile principles in the testing process on distributed teams across geographical boundaries. This empirical study has a similar focus, using a real case study in a distributed domain and applying agile testing to a selected team, compares their outcome with another three teams to determine the impact of involving a client in a testing process to overcome distributed development challenges. The findings indicate a highly positive impact on team productivity when using agile tests as compared with other groups using central distributed team testing. All teams met a 90% testing requirement. However, the group applying agile testing verified more than 99% of all requests entered into the testing process, a notable difference supporting the productivity of any development project.	Agile Development; Case study; Distributed Software Development (DSD); Empirical study; Global Software Development (GSD); Software Testing	Abdulrahman M. Qahtani	ICGDA '20: Proceedings of the 2020 3rd International Conference on Geoinformatics and Data Analysis	https://doi.org/10.1145/3397056.3397085		110-114		Excluded	Excluded	new_screen			2	ACM		Agile Testing	http://link.springer.com/book/10.1007/978-3-030-73209-7	Association for Computing Machinery	nan; References; Year; Bibtex
343	Behave	An Agile Approach to Requirement Specification	This experience report is about how one project in Norway made an agile approach to specifying software requirements for a new intranet. Rather than spending months on trying to detail all requirements and aspects of the solution, the team spent a few weeks specifying a prioritized list of high-level requirements. Further details will emerge by face-to-face communication through the iterations of the project quickly turning in to valuable working software for the customer.	Project Plan; Requirement Specification; User Story; Content Management System; Student Welfare	Tom J. Bang	International Conference on Extreme Programming and Agile Processes in Software Engineering	https://doi.org/10.1007/978-3-540-73101-6_35		pp 193–197		Excluded	Excluded	new_screen			2	SpringerLink		An Agile Approach to Requirement Specification	http://link.springer.com/chapter/10.1007/978-3-540-73101-6_35	Springer, Berlin, Heidelberg	nan; References; Year; Bibtex
344	Behave	An architecture governance approach for Agile development by tailoring the Spotify model	http://link.springer.com/article/10.1007/s00146-021-01240-x		Abdallah SalamehJulian M. Bass		http://link.springer.com/article/10.1007/s00146-021-01240-x				Excluded	Excluded	new_screen			2						
345	Behave	An Automated Approach for Acceptance Web Test Case Modeling and Executing	This paper proposes an approach for modeling and executing acceptance web test cases and describes a suite of tools to support it. The main objective is to assist the use ofAcceptance Test-Driven Development(ATDD) in web applications by providing mechanisms to support customer-developer communication and by helping test case creation. Initially, the set of web pages and relations (links) associated with a user story is modeled. Functional test possibilities involving these relations are automatically summarized in a graph, being each path of the graph a user story testing scenario. Once a testing scenario is accepted by the customer, a testing script is automatically created. A web testing framework then executes the script, triggering the ATDD process.	testing automation; web testing; acceptance web test-driven development; agile methods	Felipe M. Besson,; Delano M. Beder&; Marcos L. Chaim	International Conference on Agile Software Development	https://doi.org/10.1007/978-3-642-13054-0_12		pp 160–165		Excluded	Excluded	new_screen			2	SpringerLink		An Automated Approach for Acceptance Web Test Case Modeling and Executing	http://link.springer.com/chapter/10.1007/978-3-642-13054-0_12	Springer, Berlin, Heidelberg	nan; References; Year; Bibtex
346	Behave	An autonomous performance testing framework using self-adaptive fuzzy reinforcement learning	http://link.springer.com/article/10.1007/s11219-020-09532-z		Mahshid Helali MoghadamMehrdad SaadatmandMarkus BorgMarkus BohlinBjörn Lisper		http://link.springer.com/article/10.1007/s11219-020-09532-z				Excluded	Excluded	new_screen			2						
347	Behave	An Empirical Study on the Adoption of Agile Software Development in Public Organizations	The government has been adopting agile software development in order to improve the results of their IT projects. However, there is a lack of structured information about its adoption in this context. Since the public sector have undergone a significant process of modernization to improve the quality of public service, the goal of this study is to report from an empirical study, provide information that may enhance the understanding of the implications of adopting agile software development within public organizations, proposing a set of recommendations for its adoption.	Empirical software engineering; Agile software development; Agile methodologies; Agile methods; Public organizations; Public sector; Government	Isaque Vacari&; Rafael Prikladnicki	Brazilian Workshop on Agile Methods	https://doi.org/10.1007/978-3-319-55907-0_1		pp 3–15		Excluded	Excluded	new_screen			2	SpringerLink		An Empirical Study on the Adoption of Agile Software Development in Public Organizations	https://link.springer.com/chapter/10.1007/978-3-319-55907-0_1	Springer, Cham	nan; References; Year; Bibtex
348	Behave	An Exploratory Study on Applying a Scrum Development Process for Safety-Critical Systems	Background:Agile techniques recently have received attention from the developers of safety-critical systems. However, a lack of empirical knowledge of performing safety assurance techniques, especially safety analysis in a real agile project hampers further steps.Aims:In this article, we aim at (1) understanding and optimizing the S-Scrum development process, a Scrum extension with the integration of a systems theory based safety analysis technique, STPA (System-Theoretic Process Analysis), for safety-critical systems; (2) validating the Optimized S-Scrum development process further.Method:We conducted a two-stage exploratory case study in a student project at the University of Stuttgart, Germany.Results:The results in stage 1 showed that S-Scrum helps to ensure safety of each release but is less agile than the normal Scrum. We explored six challenges on: priority management; communication; time pressure on determining safety requirements; safety planning; time to perform upfront planning; and safety requirements’ acceptance criteria. During stage 2, the safety and agility have been improved after the optimizations, including an internal and an external safety expert; pre-planning meeting; regular safety meeting; an agile safety plan; and improved safety epics and safety stories. We have also gained valuable suggestions from industry, but the generalization problem due to the specific context is still unsolved.	Agile software development; Safety-critical systems; Case study	Yang Wang,; Jasmin Ramadani&; Stefan Wagner	International Conference on Product-Focused Software Process Improvement	https://doi.org/10.1007/978-3-319-69926-4_23		pp 324–340		Excluded	Excluded	new_screen			2	SpringerLink		An Exploratory Study on Applying a Scrum Development Process for Safety-Critical Systems	http://link.springer.com/chapter/10.1007/978-3-319-69926-4_23	Springer, Cham	nan; References; Year; Bibtex
349	Behave	An Overview of Requirements Evolution	Changing requirements are widely regarded as one of the most significant risks for software systems development. However, in today’s business landscape, these changing requirements also represent opportunities to exploit new and evolving business conditions. In consonance with other agile methods, we advocate requirements engineering techniques that embrace and accommodate requirements change. This agile approach to requirements must nonetheless be systematic and incorporate some degree of planning, especially with respect to accommodating quality attributes such as safety and security. This chapter examines the nature of requirements evolution, and the two main problems that it entails. The first is to correctly understand what is changing in the requirements, that is, the elicitation problem. The other is to act on that new information using models and other representations of the requirements, influencing the architecture and implementation of the software system. This chapter first motivates the importance of considering changing requirements in evolving software systems. It then surveys historical and existing approaches to requirements evolution with respect to the elicitation and taking action problems. Finally, the chapter describes a framework for supporting requirements evolution, defining the Requirements Evolution Problem as finding new specifications to satisfy changed requirements and domain assumptions. To motivate this, we discuss a real-life case study of the payment card industry.		Neil Ernst,; Alexander Borgida,; Ivan J. Jureta&; John Mylopoulos	Evolving Software Systems	https://doi.org/10.1007/978-3-642-45398-4_1		pp 3–32		Excluded	Excluded	new_screen			2	SpringerLink		An Overview of Requirements Evolution	http://link.springer.com/chapter/10.1007/978-3-642-45398-4_1	Springer, Berlin, Heidelberg	nan; Keywords; References; Year; Bibtex
350	Behave	AngularJS in the wild: a survey with 460 developers	To implement modern web applications, a new family of JavaScript frameworks has emerged, using the MVC pattern. Among these frameworks, the most popular one is ANGULARJS, which is supported by Google. In spite of its popularity, there is not a clear knowledge on how ANGULARJS design and features affect the development experience of Web applications. Therefore, this paper reports the results of a survey about ANGULARJS, including answers from 460 developers. Our contributions include the identification of the most appreciated features of ANGULARJS (e.g., custom interface components, dependency injection, and two-way data binding) and the most problematic aspects of the framework (e.g., performance and implementation of directives).	AngularJS; JavaScript; MVC frameworks	Miguel Ramos; Marco Tulio Valente; Ricardo Terra; Gustavo Santos	PLATEAU 2016: Proceedings of the 7th International Workshop on Evaluation and Usability of Programming Languages and Tools	https://doi.org/10.1145/3001878.3001881		9-16		Excluded	Excluded	new_screen			2	ACM		AngularJS	http://link.springer.com/chapter/10.1007/978-1-4842-2044-3_5	Association for Computing Machinery	nan; References; Year; Bibtex
351	Behave	Apogee: Application Ontology Generation with Size Optimization	To obtain runnable knowledge – convertible into executable software – from the highest abstraction level of an application, one should start with a neat set of application ontologies. But the latter are not readily available in the literature. One needs to generate dedicated and smaller application ontologies from larger generic domain ontologies. The main problem to be solved is to optimize the size of the generated application ontologies as a trade-off between two opposing tendencies: to enlarge the selected domain ontology segments to include most relationships between relevant concepts, while reducing the same segments to exclude irrelevant terms. This work describes a chain of algorithms and a series of heuristic rules to reach the proposed solution. Finally, case studies are used to actually illustrate the whole approach.		Iaakov Exman&; Danil Iskusnov	International Joint Conference on Knowledge Discovery, Knowledge Engineering, and Knowledge Management	https://doi.org/10.1007/978-3-319-25840-9_29		pp 477–492		Excluded	Excluded	new_screen			2	SpringerLink		Apogee: Application Ontology Generation with Size Optimization	http://link.springer.com/chapter/10.1007/978-3-319-25840-9_29	Springer, Cham	nan; Keywords; References; Year; Bibtex
352	Behave	The Appendix in Parkinson's Disease: From Vestigial Remnant to Vital Organ?	http://link.springer.com/chapter/10.1007/978-1-4842-2526-4_10		Sumanta Boral		https://doi.org/doi:10.3233/JPD-191703				Excluded	Excluded	new_screen			2	Pub Med Central		Appendix	http://link.springer.com/chapter/10.1007/978-1-4842-2526-4_10		nan; Venue; Authors; Abstract; Keywords; References; Pages; Year; Bibtex; Publisher
353	Behave	Applying TDD and BDD Techniques	If you have been for a few years, chances are that you have been brought on to add new features to an existing app with a large code base that has been built over a few years and has been worked on by dozens of developers, most of whom have moved on to other projects.		Abhishek Mishra	iOS Code Testing	https://doi.org/10.1007/978-1-4842-2689-6_12		pp 351–405		Excluded	Excluded	new_screen			2	SpringerLink		Applying TDD and BDD Techniques	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_12	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
354	Behave	Applying TDD to Collection View Controllers	This chapter will examine the process of building a collection view controller-based iOS app using TDD techniques. The app will have a single view controller that presents a list of pictures and will be built using the MVVM application architecture. Figure 6-1 depicts the user interface of the finished application.	Collection View Controller; ViewModel; Path Index; Test Menu Item; Import Foundation Class	Abhishek Mishra	iOS Code Testing	https://doi.org/10.1007/978-1-4842-2689-6_6		pp 161–209		Excluded	Excluded	new_screen			2	SpringerLink		Applying TDD to Collection View Controllers	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_6	Apress, Berkeley, CA	nan; References; Year; Bibtex
355	Behave	Applying TDD to the Model	This chapter will examine the process of building the model layer of an app using TDD techniques. Since this chapter focuses on the model layer, you will not be building a user interface or any presentation logic.		Abhishek Mishra	iOS Code Testing	https://doi.org/10.1007/978-1-4842-2689-6_4		pp 61–99		Excluded	Excluded	new_screen			2	SpringerLink		Applying TDD to the Model	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_4	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
356	Behave	Applying TDD to View Controllers			Abhishek Mishra						Excluded	Excluded	new_screen			2						
357	Behave	Approaches to Business Analysis in Scrum at StepStone—Case Study	Wide adoption of Agile has significantly impacted the sphere ofbusiness analysis. Although need forbusiness analysisis widely accepted, it is often unclear how it should be applied. Opinions about the role of a BA (Business Analyst) in Agile teams vary greatly—from negation of its existence to acceptance of a BA as a team member, working side by side with programmers. At StepStone, since our switch to Scrum in 2014, we have experimented with several models of team organization, with or without dedicated BAs. In this paper, the two most prominent cases will be presented: when the BA was a full-time member of the development team, and when the BA’s role was distributed between other team members—developers and the Product Owner. Advantages, disadvantages and the transition process will be discussed. In addition, techniques will be proposed which may help in development of necessary analytical skills and transforming team organization - based on our experience.		Piotr Forowicz	Data-Centric Business and Applications	https://doi.org/10.1007/978-3-030-34706-2_11		pp 211–223		Excluded	Excluded	new_screen			2	SpringerLink		Approaches to Business Analysis in Scrum at StepStone—Case Study	http://link.springer.com/chapter/10.1007/978-3-030-34706-2_11	Springer, Cham	nan; Keywords; References; Year; Bibtex
358	Behave	Augmented System Verification Using Automated Testing	A verification process is an evaluation of whether or not a product satisfies its requirements, which typically includes a visual verification activity. This is sometimes referred to as acceptance testing. Minimal or no human interaction is the construct of fully automated testing, which is often not sufficient for verification process/user acceptance testing. An approach for writing automated testing is described here, which augments the human verification process while still leveraging the benefits of test automation.	Human-systems integration; Systems engineering; Agile testing; Automated testing	Amir Schur&; Mike Williams	International Conference on Applied Human Factors and Ergonomics	https://doi.org/10.1007/978-3-319-60366-7_7		pp 64–70		Included	Included	new_screen			2	SpringerLink		Augmented System Verification Using Automated Testing	http://link.springer.com/chapter/10.1007/978-3-319-60366-7_7	Springer, Cham	nan; References; Year; Bibtex
359	Behave	AutoJet: Web Application Automation Tool	The test automation tools available in the present market is limited in various features, e.g., reporting, debugging, logging, usability, and portability, resulting in need of integration of these features to achieve automation objectives, e.g., positive ROI, stability, and efficiency. In this paper, we propose an innovative tool that proves as a panacea for many of test automation challenges discovered in worldwide surveys. In order to provide these challenging features in Web automation testing domain, an attempt has been made to create a tool called AutoJet. It is a Web automation testing tool that aims to provide a great extent of usability to both automation as well as manual testers. Using AutoJet, paradoxically a manual tester can automate test scenarios smoothly and profitably. Our study shows that it is possible for a manual tester to automate test scenarios effectively with reduced time span as it eliminates the efforts spent by the testers to understand existing test harness or to create a new one.	Page object model; Selenium WebDriver; Test automation; Web automation tool; Web automation testing	Sheetika Kapoor&; Kalpna Sagar	Towards Extensible and Adaptable Methods in Computing	https://doi.org/10.1007/978-981-13-2348-5_3		pp 27–42		Excluded	Excluded	new_screen			2	SpringerLink		AutoJet: Web Application Automation Tool	http://link.springer.com/chapter/10.1007/978-981-13-2348-5_3	Springer, Singapore	nan; References; Year; Bibtex
360	Behave	Automated Acceptance Tests as Software Requirements: An Experiment to Compare the Applicability ofFit TablesandGherkin Language	It is estimated that 85% of the defects in the developed software are originated from ambiguous, incomplete and wishful thinking software requirements. Natural language is often used to write software requirements specifications as well as user requirements. However, natural language specifications can be confusing and hard to understand. Some agile methodologists consider that acceptance tests are more precise and accurate sources of information about the customer’s needs than descriptions in natural language. Several studies have addressed the use of acceptance tests as software requirements specification. Therefore, none of the previous studies has performed experiments to compare the applicability of different acceptance testing techniques in order to support an organization in the selection of one technique over another. This paper addresses this problem reporting an experiment conducted with undergraduate students in Computer Science. This experiment compares the applicability of two acceptance testing techniques (Fit tables and Gherkin language) as software requirements specification. This research tries to answer three questions: (a) Which technique is the easiest to learn in order to specify acceptance test scenarios? (b) Which technique requires less effort to specify acceptance tests? (c) Which technique is the best one to communicate software requirements? The results show that there is no sufficient evidence to affirm that one technique is easier to specify test scenarios or better to communicate software requirements. Whereas, the comparison of effort in terms of time to specify acceptance testing shows that the mean time to specify test scenarios using Gherkin language is lower than Fit tables.	Acceptance testing; Software requirements; Fit tables; Gherkin language; FitNesse; Cucumber; TDD; ATDD; BDD	Ernani César dos Santos&; Patrícia Vilain	International Conference on Agile Software Development	https://doi.org/10.1007/978-3-319-91602-6_7		pp 104–119		Included	Included	new_screen			2	SpringerLink		Automated Acceptance Tests as Software Requirements: An Experiment to Compare the Applicability of Fit Tables and Gherkin Language	http://link.springer.com/chapter/10.1007/978-3-319-91602-6_7	Springer, Cham	nan; References; Year; Bibtex
361	Behave	From logistics process models to automated integration testing:proof-of-concept using open-source simulation software	This paper explores the practical integration of simulation methods into software development processes. An automated integration testing approach is presented, which enables continuous virtual commissioning. For this purpose, an analysis of the current state of knowledge and the standards of software development is presented. This is followed by a case study on logistics order management, referring to a typical B2B application in the retail logistics sector. The proof-of-concept shows how the usage of a simulation model for automated integration testing and its inclusion into continuous-integration can help to ensure software quality, particularly for process-centered logistics applications. The implemented setup proves the feasibility of the approach, using standard open-source development tools, and a Python-based open-source simulation library.		Paul Reichardt; Wladimir Hofmann; Tobias Reggelin; Sebastian Lang	WSC '21: Proceedings of the Winter Simulation Conference	https://doi.org/10.5555/3522802.3522901		1-11		Excluded	Excluded	new_screen			2	ACM		Automated Integration Testing	http://link.springer.com/chapter/10.1007/978-1-4302-2944-5_11	IEEE Press	nan; Keywords; References; Year; Bibtex
362	Behave	Automated Testing of Networked Systems Reliability	The reliability of a network is a crucial requirement for systems such as IoT, client-server, or cloud-based solutions. Unfortunately, real networks cannot be assumed to be fault-free, especially when considering various hardware problems, performance issues, or malicious attacks. Testing networked systems should therefore include evaluating fault tolerance under various network conditions. The paper presents a doctoral research project on automated verification of networked systems using fault-attack injection using a derived model of network communication.	Networked systems; fault/attack injection; network model; testing	Michal Rozsival	ISSTA 2024: Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis	https://doi.org/10.1145/3650212.3685559		1920-1922		Excluded	Excluded	new_screen			2	ACM		Automated Testing	http://link.springer.com/chapter/10.1007/978-1-4302-6790-4_9	Association for Computing Machinery	nan; References; Year; Bibtex
363	Behave	Automating Expert-Defined Tests: A Suitable Approach for the Medical Device Industry?			David ConnollyFergal Mc CafferyFrank Keenan						Excluded	Excluded	new_screen			2						
364	Behave	Basic concepts of physically-based rendering	This tutorial will cover the basics of physically-based rendering such as reflection models (BRDF), volume scattering (phase functions), optical phenomena (dispersion and polarization). It will also cover image formation via basic camera models. A brief summary of popular algorithms will be covered including radiosity, path tracing, photon tracing, and Metropolis Light Transport. The course will end with a more detailed description of adjoint photon tracing so that attendees can later implement their own physically-based renderer.		Peter Shirley	SA '13: SIGGRAPH Asia 2013 Courses	https://doi.org/10.1145/2542266.2542269		1-11		Excluded	Excluded	new_screen			2	ACM		Basic Concepts	https://link.springer.com/chapter/10.1007/978-1-4842-6131-6_2	Association for Computing Machinery	nan; Keywords; References; Year; Bibtex
365	Behave	A Behavior-driven Development and Reinforcement Learning approach for videogame automated testing	Video game development has undergone a significant transformation in the last decade, with modern games becoming increasingly complex and sophisticated. Testing these games for quality assurance is challenging and time-consuming, often relying on manual testers. In this paper, we introduce an automated testing approach that combines Behavior-Driven Development (BDD) with Reinforcement Learning (RL) to streamline the testing process. We present a framework that uses natural language-based test cases to describe game behaviors and expected outcomes, combined with RL, to test games automatically. We validated our approach through tests on four distinct Python-based games. We analyzed the impact of game complexity on training duration and discussed the challenges of defining optimal reward functions. Our framework provides a structured approach to address RL complexities, simplifying the process of creating test scenarios. Combining BDD and RL offers a promising solution to test complex modern video games more efficiently and ensure higher game quality upon release.	videogame; testing; reinforcement learning; behavior-driven development; software quality; software engineering	Vincent Mastain; Fabio Petrillo	GAS '24: Proceedings of the ACM/IEEE 8th International Workshop on Games and Software Engineering	https://doi.org/10.1145/3643658.3643919		1-8		Excluded	Excluded	new_screen			2	ACM		Behavior-Driven Development	http://link.springer.com/chapter/10.1007/978-1-4842-6972-5_10	Association for Computing Machinery	nan; References; Year; Bibtex
366	Behave	Behaviour-Driven Development			Prof. Dr. Stephan Kleuker						Excluded	Excluded	new_screen			2						
367	Behave	Best Practices for OutSystems Development and Its Influence on Test Automation	Low-code development platforms are designed to accelerate software development with a minimum of hand coding. They have allowed professionals with distinct backgrounds to become software developers. This brings more professionals to IT areas, reskilling some of them from different areas of knowledge but, at the same time, it has also brought to the software development area many professionals without a strong background in this area. Although testing should be performed in all applications, regardless of the programming language or the platform used, this reinforces the need for testing low-code developed applications. In this work, we study the test automation process on the OutSystems low-code development platform. The focus is on Unit, Integration/API and System/End-to-End testing levels. Examples illustrate that the implementation of best practices during the development process can have a significant influence on the test automation process. However, it is important to know whether the workload associated with the implementation of the best practices can undermine the benefits of using a low-code platform and it is important to consider that not all test automation tools have the same behavior.		Joana Salgueiro,; Fernando Ribeiro,&; José Metrôlho,	World Conference on Information Systems and Technologies	https://doi.org/10.1007/978-3-030-72654-6_9		pp 85–95		Excluded	Excluded	new_screen			2	SpringerLink		Best Practices for OutSystems Development and Its Influence on Test Automation	http://link.springer.com/chapter/10.1007/978-3-030-72654-6_9	Springer, Cham	nan; Keywords; References; Year; Bibtex
368	Behave	Blockchain-Based Distributed Marketplace	Developments in Blockchain technology have enabled the creation of smart contracts; i.e., self-executing code that is stored and executed on the Blockchain. This has led to the creation of distributed, decentralised applications, along with frameworks for developing and deploying them easily. This paper describes a proof-of-concept system that implements a distributed online marketplace using the Ethereum framework, where buyers and sellers can engage in e-commerce transactions without the need of a large central entity coordinating the process. The performance of the system was measured in terms of cost of use through the concept of ‘gas usage’. It was determined that such costs are significantly less than that of Amazon and eBay for high volume users. The findings generally support the ability to use Ethereum to create a distributed on-chain market, however, there are still areas that require further research and development.	Blockchain; Smart contract; Ethereum; E-commerce; Distributed systems	Oliver R. Kabi&; Virginia N. L. Franqueira	International Conference on Business Information Systems	https://doi.org/10.1007/978-3-030-04849-5_17		pp 197–210		Excluded	Excluded	new_screen			2	SpringerLink		Blockchain-Based Distributed Marketplace	http://link.springer.com/chapter/10.1007/978-3-030-04849-5_17	Springer, Cham	nan; References; Year; Bibtex
369	Behave	BPMN-Based Model-Driven Testing of Service-Based Processes	Executable Business Processes realized in WS-BPEL and BPMN2 are used more and more for automating digitalized core processes in organizations. Due to their critical nature for the organization, these processes need to be developed with high quality standards. Existing literature concentrates on testing such processes, but do not offer integration into the development lifecycle and validation with other stakeholders. Our approach is based on Test Models that allow both the easier definition of automated test cases as well as discussion with non-technical stakeholders and, thus, can be used for business process validation and process modeling support. We define a meta-model for the BPMN-based Test Models that has been validated in a case study in an industrial project.	BPMN; Model-driven testing; Business process; Service composition; Process validation	Daniel Lübke,&; Tammo van Lessen	International Workshop on Business Process Modeling, Development and Support	https://doi.org/10.1007/978-3-319-59466-8_8		pp 119–133		Excluded	Excluded	new_screen			2	SpringerLink		BPMN-Based Model-Driven Testing of Service-Based Processes	http://link.springer.com/chapter/10.1007/978-3-319-59466-8_8	Springer, Cham	nan; References; Year; Bibtex
370	Behave	Bridging Enterprise and Software Engineering Through an User-Centered Design Perspective	The development of Web-based Information Systems is crucial in the quest to maintain and develop the enterprise competiveness. However, capturing requirements from Business Processes (BP) is still an issue, as existing methods mostly focus, or on human aspects and the user interface, or on business concerns as rules and workflow coordination, and therefore do not specify all the Software Architectural components which are relevant for software development. We present the Goals Approach, which analyzes BPs and User Tasks and details them in the process of methodically designing and structuring the User Interface, the Business Logic and the Database of the Information System given a Model-View-Controller (MVC) architectural pattern. In this paper we focus on how to obtain the Goals business model of requirements based on the DEMO method. The approach can be used for in-house software development, and the method is straightforward fitting Small and Medium Enterprises agility needs.	Web-based applications; Enterprise engineering; Software engineering; User-Centered Design; Software architecture	Pedro Valente,,; Thiago Silva,; Marco Winckler&; Nuno Nunes	International Conference on Web Information Systems Engineering	https://doi.org/10.1007/978-3-319-48743-4_28		pp 349–357		Excluded	Excluded	new_screen			2	SpringerLink		Bridging Enterprise and Software Engineering Through an User-Centered Design Perspective	http://link.springer.com/chapter/10.1007/978-3-319-48743-4_28	Springer, Cham	nan; References; Year; Bibtex
371	Behave	Building Software the Correct Way	Programmers learn very quickly that writing software is hard and error prone. Time and again software projects fail because teams are unable to cope with software complexity. As a result, the project fails to meet the deadline, costs much more than expected, and doesn’t deliver the intended business value.		Shekhar Gulati&; Rahul Sharma	Java Unit Testing with JUnit 5	https://doi.org/10.1007/978-1-4842-3015-2_1		pp 1–23		Excluded	Excluded	new_screen			2	SpringerLink		Building Software the Correct Way	http://link.springer.com/chapter/10.1007/978-1-4842-3015-2_1	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
372	Behave	Transferring transactional business processes to FaaS	Function-as-a-Service (FaaS) is a modern cloud service model that has gained significant attention from the research and industry communities in recent years for its many benefits such as dynamic scaling, cost efficiency, faster programming, flexibility to microservices and containers technology. However, the building and deployment of serverless applications come with many challenges that need to be tackled, like workflow design complexity and migration of other applications. When transactions between different parties are involved, the workflow becomes knotty and the communication between participants and all properties of transactions have to be properly resolved. Transactions have widely been discussed in Business processes, so same practices might be adopted by serverless workflows. In this work we provide guidelines and mapping mechanisms for transforming transactional Business Process Modeling Notation 2.0 (BPMN2) applications to a serverless platform. We shed light on the current inability of function orchestrators to express workflow definitions, and deal with various architectural dilemmas that stem from the dissimilar nature of stateful BPMN vs. stateless serverless applications. We overcome the unbalanced capabilities between well-established BPMN notations and function orchestration definitions and illustrate how to exploit and combine cloud native services that comes with FaaS to create serverless applications.	BPMN2; FaaS; OpenWhisk; function orchestration; serverless workflow; transactions	Kostas Meladakis; Chrysostomos Zeginis; Kostas Magoutis; Dimitris Plexousakis	WoSC '22: Proceedings of the Eighth International Workshop on Serverless Computing	https://doi.org/10.1145/3565382.3565882		25-30		Excluded	Excluded	new_screen			2	ACM		Business Processes	http://link.springer.com/chapter/10.1007/978-1-4842-3832-5_5	Association for Computing Machinery	nan; References; Year; Bibtex
373	Behave	Cassandra on Docker, Apache Spark, and the Cassandra Cluster Manager			Sam R. Alapati						Excluded	Excluded	new_screen			2						
374	Behave	Challenges of CE	Despite a long pedigree and many positive reports on its use and benefits, concurrent engineering (CE) and its associated research (sub)domains still experience significant development. In this final chapter, a socio-technical framework is applied to classify and analyze challenges identified as part of the foundations, methods and applications discussed in this book. Existing properties and means of CE are abstracted. Subsequently, the main trends and developments in CE research and practice are discussed, followed by expectations for the future. Findings and trends have been identified for strategic issues visible in product requirements and product portfolios, stakeholders including companies involved, multiple functions and disciplines, current and future technologies that are expected to solve at least some of the existing problems, knowledge and skills as brought by people and teams, and structures necessary for making collaboration work, while dealing also with the still very difficult cultural differences. As the chapter shows, CE as a concept is very much alive, requiring even more advanced tools, techniques and methods to contribute to less waste in resources and efforts world-wide and improve quality.		Wim J. C. Verhagen,; Josip Stjepandić&; Nel Wognum	Concurrent Engineering in the 21st Century	https://doi.org/10.1007/978-3-319-13776-6_28		pp 807–833		Excluded	Excluded	new_screen			2	SpringerLink		Challenges of CE	http://link.springer.com/chapter/10.1007/978-3-319-13776-6_28	Springer, Cham	nan; Keywords; References; Year; Bibtex
375	Behave	Chapter 10 - Development			Lundahl, David						Excluded	Excluded	new_screen			2						
376	Behave	Chasing Mutants	This chapter describes mutation testing, how it has developed, the types of tools associated with it, the benefits to a quality assurance process, and the associated challenges with scaling it as a test design technique and as a consumer of resources.	Software testing; Software quality; Test automation; Mutation testing	Adam Leon Smith	The Future of Software Quality Assurance	https://doi.org/10.1007/978-3-030-29509-7_12		pp 147–159		Excluded	Excluded	new_screen			2	SpringerLink		Chasing Mutants	http://link.springer.com/chapter/10.1007/978-3-030-29509-7_12	Springer, Cham	nan; References; Year; Bibtex
377	Behave	Clean C++20	http://link.springer.com/book/10.1007/978-1-4842-5949-8		Stephan Roth		http://link.springer.com/book/10.1007/978-1-4842-5949-8				Excluded	Excluded	new_screen			2						
378	Behave	Cloud and Services Testing Applied in Manufacturing			F. AlvesC. CoutinhoR. Peña-OrtizX. XuA. NietoJ. AholaL. SaariA. Katasonov						Excluded	Excluded	new_screen			2						
379	Behave	Algorithm for iris code organization and searching for iris recognition system	Iris recognition has become one of the prominent biometrics features in human identification system. In addition to light intensity, focusing and capture distance problems, percent of IRIS visibility are also one of the major problems. This can cause failure in most common method, Hamming Distance (HD), used for matching the templates. This paper proposes the iris code organization and searching algorithm suggesting the improvement in template matching process. The algorithm also suggests template selection to avoid comparison with all existing IRIS codes resulting in faster searching speed. For the IRIS that has accumulated the cataract, HD methods shows major failure results. The proposed algorithm shows better performance over conventional HD method of template matching and IRIS code selection for template matching.	iris code database; iris code searching; iris codes organization; iris comparison	P. M. Agarkar; S. N. Talbar	ICWET '10: Proceedings of the International Conference and Workshop on Emerging Trends in Technology	https://doi.org/10.1145/1741906.1742029		544-547		Excluded	Excluded	new_screen			2	ACM		Code Organization	http://link.springer.com/chapter/10.1007/978-1-4842-3249-1_2	Association for Computing Machinery	nan; References; Year; Bibtex
380	Behave	Comparison of national clinical practice guidelines and recommendations on vaccination of adult patients with autoimmune rheumatic diseases	http://link.springer.com/article/10.1007/s00296-013-2907-9		Despoina PapadopoulouNikolaos V. Sipsas		http://link.springer.com/article/10.1007/s00296-013-2907-9				Excluded	Excluded	new_screen			2						
381	Behave	Completeness-Driven Development	Due to the steadily increasing complexity, the design of embedded systems faces serious challenges. To meet these challenges additional abstraction levels have been added to the conventional design flow resulting inElectronic System Level(ESL) design. Besides abstraction, the focus in ESL during the development of a system moves from design to verification, i.e. checking whether or not the system works as intended becomes more and more important. However, at each abstraction level only the validity of certain properties is checked. Completeness, i.e. checking whether or not the entire behavior of the design has been verified, is usually not continuously checked. As a result, bugs may be found very late causing expensive iterations across several abstraction levels. This delays the finalization of the embedded system significantly. In this work, we present the concept ofCompleteness-Driven Development(CDD). Based on suitable completeness measures, CDD ensures that the next step in the design process can only be entered if completeness at the current abstraction level has been achieved. This leads to an early detection of bugs and accelerates the whole design process. The application of CDD is illustrated by means of an example.	Abstraction Level; Acceptance Test; Transaction Level Modeling; Arithmetic Logic Unit; Test Drive Development	Rolf Drechsler,,; Melanie Diepenbeck,; Daniel Große,; Ulrich Kühne,; Hoang M. Le,; Julia Seiter,; Mathias Soeken,&; Robert Wille	International Conference on Graph Transformation	https://doi.org/10.1007/978-3-642-33654-6_3		pp 38–50		Excluded	Excluded	new_screen			2	SpringerLink		Completeness-Driven Development	http://link.springer.com/chapter/10.1007/978-3-642-33654-6_3	Springer, Berlin, Heidelberg	nan; References; Year; Bibtex
382	Behave	Component architecture of model-based testing environment	http://link.springer.com/article/10.1134/S036176881005004X		V. V. Kuliamin		http://link.springer.com/article/10.1134/S036176881005004X				Excluded	Excluded	new_screen			2						
383	Behave	Conceptual Design and Controller Testing	As you saw in Chapter 5, unit testing doesn’t have to involve exhaustively covering every single line of code, or even every single method, with tests. There’s a law of diminishing returns—and increasing difficulty—as you push the code coverage percentile ever higher. By taking a step back and looking at the design on a broader scale, it’s possible to pick out the key areas of code that act as input/output junctures, and focus the tests on those areas.	Conceptual Design; Acceptance Criterion; Boundary Object; Unit Test; Test Scenario	Matt Stephens&; Doug Rosenberg	Design Driven Testing	https://doi.org/10.1007/978-1-4302-2944-5_6		pp 137–162		Excluded	Excluded	new_screen			2	SpringerLink		Conceptual Design and Controller Testing	http://link.springer.com/chapter/10.1007/978-1-4302-2944-5_6	Apress	nan; References; Year; Bibtex
384	Behave	Contents				Procedia Computer Science					Excluded	Excluded	new_screen			2						
385	Behave	Continuous Architecting with Microservices and DevOps: A Systematic Mapping Study	Context: Several companies are migrating their information systems into the Cloud. Microservices and DevOps are two of the most common adopted technologies. However, there is still a lack of understanding how to adopt a microservice-based architectural style and which tools and technique to use in a continuous architecting pipeline.Objective: We aim at characterizing the different microservice architectural style principles and patterns in order to map existing tools and techniques adopted in the context of DevOps.Methodology: We conducted a Systematic Mapping Study identifying the goal and the research questions, the bibliographic sources, the search strings, and the selection criteria to retrieve the most relevant papers.Results: We identified several agreed microservice architectural principles and patterns widely adopted and reported in 23 case studies, together with a summary of the advantages, disadvantages, and lessons learned for each pattern from the case studies. Finally, we mapped the existing microservices-specific techniques in order to understand how to continuously deliver value in a DevOps pipeline. We depicted the current research, reporting gaps and trends.Conclusion: Different patterns emerge for different migration, orchestration, storage and deployment settings. The results also show the lack of empirical work on microservices-specific techniques, especially for the release phase in DevOps.	Cloud-native; Microservice; DevOps; Migration; Orchestration	Davide TaibiORCID:orcid.org/---,; Valentina LenarduzziORCID:orcid.org/---&; Claus PahlORCID:orcid.org/---X	International Conference on Cloud Computing and Services Science	https://doi.org/10.1007/978-3-030-29193-8_7		pp 126–151		Excluded	Excluded	new_screen			2	SpringerLink		Continuous Architecting with Microservices and DevOps: A Systematic Mapping Study	http://link.springer.com/chapter/10.1007/978-3-030-29193-8_7	Springer, Cham	nan; References; Year; Bibtex
386	Behave	An IDE Plugin for Gamified Continuous Integration	Interruptions and context switches resulting from meetings, urgent tasks, emails, and queries from colleagues contribute to productivity losses in developers' daily routines. This is particularly challenging for tasks like software testing, which are already perceived as less enjoyable, prompting developers to seek distractions. To mitigate this, applying gamification to testing activities can enhance motivation for test writing. One such gamification tool is Gamekins, which integrates challenges, quests, achievements, and leaderboards into the Jenkins CI (continuous integration) platform. However, as Gamekins is typically accessed through a browser, it introduces a context switch. This paper presents anIntelliJ plugindesigned to seamlessly integrate Gamekins' gamification elements into the IDE, aiming to minimize context switches and boost developer motivation for test writing.	gamification; IDE; IntelliJ; software testing; continuous integration	Philipp Straubinger; Gordon Fraser	IDE '24: Proceedings of the 1st ACM/IEEE Workshop on Integrated Development Environments	https://doi.org/10.1145/3643796.3648462		91-94		Excluded	Excluded	new_screen			2	ACM		Continuous Integration	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_9	Association for Computing Machinery	nan; References; Year; Bibtex
387	Behave	Controllers and Actions	Each time a request comes in to your ASP.NET MVC application, it’s dealt with by a controller. The controller is the boss: it can do anything it likes to service that request. It can issue any set of commands to the underlying model tier or database, and it can choose to render any view back to the visitor. It’s a .NET class into which you can add any logic needed to handle the request.	Action Method; Unit Test; Context Object; Virtual Property; Public Class	Steven Sanderson	Pro ASP.NET MVC 2 Framework	https://doi.org/10.1007/978-1-4302-2887-5_9		pp 283–324		Excluded	Excluded	new_screen			2	SpringerLink		Controllers and Actions	https://link.springer.com/chapter/10.1007/978-1-4302-2887-5_9	Apress	nan; References; Year; Bibtex
388	Behave	Creating Automation Frameworks Using Appium	In this chapter, you will learn how to do the following	Automatic Framework; Behavior-driven Development (BDD); TestNG; Continuous Integration Tools; Maven Project	Shankar Garg	Appium Recipes	https://doi.org/10.1007/978-1-4842-2418-2_5		pp 101–127		Excluded	Excluded	new_screen			2	SpringerLink		Creating Automation Frameworks Using Appium	http://link.springer.com/chapter/10.1007/978-1-4842-2418-2_5	Apress, Berkeley, CA	nan; References; Year; Bibtex
389	Behave	Cross-species protein sequence and gene structure prediction with fine-tuned Webscipio 2.0 and Scipio	http://link.springer.com/article/10.1186/1756-0500-4-265		Klas HatjeOliver KellerBjörn HammesfahrHolger PillmannStephan WaackMartin Kollmar		http://link.springer.com/article/10.1186/1756-0500-4-265				Excluded	Excluded	new_screen			2						
390	Behave	Data-Driven Usability Test Scenario Creation	In this paper, we present a data-driven approach to enable the creation of evidence-based usability test scenarios. By utilising product usage data to create usability test scenarios, we aim to improve the reliability of the test results and to provide better insights into product usability. The approach consists of four elements: the collection of product usage data, the transformation of these data into logs of user activities, the creation of models of user behaviour, and the guided creation of usability test scenarios based on the models. We discuss the challenges that can be encountered when applying this approach based on our experiences with two case studies in product development. We have created a prototype scenario planning tool and performed a preliminary evaluation of the tool with usability engineers working at Philips Healthcare. The evaluation shows that tool-supported evidence-based usability test creation would be valuable in their daily work.	User-centered design; Usability testing; Data-driven design; Process mining	Maikel L. van Eck,; Else Markslag,; Natalia Sidorova,; Angelique Brosens-Kessels&; Wil M. P. van der Aalst,	International Conference on Human-Centred Software Engineering	https://doi.org/10.1007/978-3-030-05909-5_6		pp 88–108		Excluded	Excluded	new_screen			2	SpringerLink		Data-Driven Usability Test Scenario Creation	http://link.springer.com/chapter/10.1007/978-3-030-05909-5_6	Springer, Cham	nan; References; Year; Bibtex
391	Behave	Design and deployment considerations for high performance MIMO testbeds	MIMO (Multiple Input Multiple Output) enabled systems are characterized by higher reliability and transmission rates, as compared to conventional SISO (Single Input Single Output) systems. However, unless administered properly, the MIMO technologymay notfacilitate very high throughputs on point-to-point wireless links. Therefore, it becomes imperative for the network architect to design such networks in ways that fully exploit the inherent properties of MIMO. In this paper, we first conduct an extensive experimental study, using a powerful hardware platform, in order to understand the behavior of MIMO links in different topological scenarios. Our experiments involve scenarios with MIMO links in isolation, as well as in competition with other MIMO and SISO links. Second, we perform measurements with different commercial platforms towards assessing the ability of each platform to efficiently support the MIMO technology. Based on our experimental observations we deduce that the CPU processing speed of the underlying hardware platform is an important factor that can hide the performance benefits of a MIMO enabled tranceiver. We comment on the applicability of the different hardware choices that we test; furthermore, we suggest the most appropriate choice for building a MIMO testbed, taking into account the cost, the extend-ability and the re-usability of the selected platform. Finally, having adopted this choice in our testbed design, we provide a description of our testbed architecture.	IEEE 802.11n; MIMO communications; testbed deployment; topology	Konstantinos Pelechrinis; Ioannis Broustis; Theodoros Salonidis; Srikanth V. Krishnamurthy; Prasant Mohapatra	WICON '08: Proceedings of the 4th Annual International Conference on Wireless Internet	https://doi.org/10.5555/1554126.1554192		1-9		Excluded	Excluded	new_screen			2	ACM		Deployment Considerations	http://link.springer.com/chapter/10.1007/978-1-4842-0160-2_10	ICST (Institute for Computer Sciences, Social-Informatics and Telecommunications Engineering)	nan; References; Year; Bibtex
392	Behave	Description and Analysis of Design Decisions: An Ontological Approach	A success software development process requires a good design stage. During the design, a set of decisions is made in order to improve the productivity, reduce costs for reimplementation and obtain reliable systems, in special for critical domains, such as bank management systems or systems for aeronautics. Nevertheless, it is not easy to find documentation about design decisions or tools which support this process. To address this issue, this article describes a solution based on ontologies to describe design decisions. In order to identify the main elements a systematic literature review was carried out. This review also helped to identify some of the most common design decisions. These elements were used to develop the ontology which allows answering the problem raised. This ontology could be a useful tool for architects and designers during the design stage of a system.	Ontology; Design decision; Software	Yordani Cruz Segura,; Nemury Silega Martínez,; Ailía Parra Fernández&; Oiner Gómez Baryolo	International Conference on Technologies and Innovation	https://doi.org/10.1007/978-3-030-00940-3_13		pp 174–185		Excluded	Excluded	new_screen			2	SpringerLink		Description and Analysis of Design Decisions: An Ontological Approach	http://link.springer.com/chapter/10.1007/978-3-030-00940-3_13	Springer, Cham	nan; References; Year; Bibtex
393	Behave	Promoting active aging through assistive product design innovation: a preference-based integrated design framework	http://link.springer.com/chapter/10.1007/978-1-4842-4303-9_3		Shailesh Kumar ShivakumarSourabhh Sethii		https://doi.org/doi:10.3389/fpubh.2023.1203830				Excluded	Excluded	new_screen			2	Pub Med Central		Design	http://link.springer.com/chapter/10.1007/978-1-4842-4303-9_3		nan; Venue; Authors; Abstract; Keywords; References; Pages; Year; Bibtex; Publisher
394	Behave	Design for the Decentralized World: Democratization of Blockchain-Based Software Design			Vladislav GladyshevQiong Wu						Excluded	Excluded	new_screen			2						
395	Behave	Fanning the Flames of Passion: A Develop Mindset Predicts Strategy-Use Intentions to Cultivate Passion	https://link.springer.com/chapter/10.1007/978-1-4842-1067-3_6		Tathagat Varma		https://doi.org/doi:10.3389/fpsyg.2021.634903				Excluded	Excluded	new_screen			2	Pub Med Central		Develop	https://link.springer.com/chapter/10.1007/978-1-4842-1067-3_6		nan; Venue; Authors; Abstract; Keywords; References; Pages; Year; Bibtex; Publisher
396	Behave	Developing a Spiral Curriculum for Teaching Agile at the National Software Academy	The National Software Academy (NSA) was established at Cardiff University in October 2016 as a centre of excellence for Applied Software Engineering. We work in partnership with Welsh Government and industry leaders to address the national shortage of software engineering graduates with the skills, knowledge, and hands-on experience required to be immediately effective as commercial software engineers. We run an innovative, industry-focused B.Sc. which uses agile methods to facilitate our project-based learning (PjBL) approach. The projects are provided by our network of industrial partners and are used across multiple modules as a basis for assessment across the disciplines. Although the degree course has yet to produce any graduates, a significant proportion already hold conditional job offers. A conversion M.Sc. in Applied Software Engineering for STEM graduates has also been developed, and will benefit from lessons learned as we continue to inspect and adapt the undergraduate degree programme. This chapter outlines how a spiral curriculum has been developed for teaching agile that progressively introduces complexity whilst building on previous learning.	Spiral learning; Agile project management; Project-based learning; Industrial collaboration; Applied software engineering	James Osborne,; Wendy Ivins&; Carl Jones	Agile and Lean Concepts for Teaching and Learning	https://doi.org/10.1007/978-981-13-2751-3_15		pp 303–323		Excluded	Excluded	new_screen			2	SpringerLink		Developing a Spiral Curriculum for Teaching Agile at the National Software Academy	https://link.springer.com/chapter/10.1007/978-981-13-2751-3_15	Springer, Singapore	nan; References; Year; Bibtex
397	Behave	Directed Multi-target Search Based Unit Tests Generation	Software testing costs are reduced by employing test automation. One of the automation activities is tests generation. The goal of tests generation is to generate tests with large code coverage with the efficient faults detection ability. Search-based tests generation methods are analysed and their experimental comparison is provided in this paper.The novel search-based unit tests generation approach directed by multiple search targets to generate unit tests is presented. Introduced method allows generating test data and oracles using static code analysis and code instrumentation. Oracles are created as assertions based on system state after tests execution phase, thus making tests suitable for regression testing.The method was implemented as an experimental tool. It was evaluated and compared against other search-based tests generation tools/methods by using code coverage and mutation score metrics. The experimental evaluation was performed on 124 classes from 3 open source libraries.	Unit tests generation; Unit testing; Search based software testing	Greta Rudžionienė,; Šarūnas Packevičius&; Eduardas Bareiša	International Conference on Information and Software Technologies	https://doi.org/10.1007/978-3-030-30275-7_8		pp 90–109		Excluded	Excluded	new_screen			2	SpringerLink		Directed Multi-target Search Based Unit Tests Generation	http://link.springer.com/chapter/10.1007/978-3-030-30275-7_8	Springer, Cham	nan; References; Year; Bibtex
398	Behave	Documentation, Error Handling, Debugging, and Testing	In this chapter, we’re going to look at the finer details of developing reliable programs: documentation, error handling, debugging, and testing. These tasks aren’t what most people think of as “development,” but are as important to the overall process as general coding tasks. Without documenting, debugging, and testing your code, it’s unlikely that anyone but you could work on the code with much success, and you run the risk of releasing faulty scripts and applications.		Carleton DiLeo&; Peter Cooper	Beginning Ruby 3	https://doi.org/10.1007/978-1-4842-6324-2_8		pp 215–246		Excluded	Excluded	new_screen			2	SpringerLink		Documentation, Error Handling, Debugging, and Testing	http://link.springer.com/chapter/10.1007/978-1-4842-6324-2_8	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
399	Behave	Documenting, Testing, and Verifying	At this point you know many of the features and intricacies of the Haskell language and many of its libraries. This chapter won’t teach you any more about the language but rather will focus on some tools that help you in the process of coding libraries and applications. These tools support good engineering practices within Haskell.		Alejandro Serrano Mena	Practical Haskell	https://doi.org/10.1007/978-1-4842-4480-7_15		pp 525–546		Excluded	Excluded	new_screen			2	SpringerLink		Documenting, Testing, and Verifying	http://link.springer.com/chapter/10.1007/978-1-4842-4480-7_15	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
400	Behave	Domain Modeling Based on Requirements Specification and Ontology	Domain model plays an important role in software development. Typically, it is a primary input to elaboration of a system model which in turn is translated into source code and related database schemas. Effective development of domain model is a part of requirement engineering during which domain experts are employed to identify domain entities and relationships among them. We claim that this task can be supported by the use of domain ontologies from which interesting knowledge can be extracted. The starting point to knowledge extraction is an existing requirements specification. In this paper, we investigate how the form of requirements specification influences the quality of extracted model. Some measures allowing to assess the quality are introduced. A case study has shown that in the most cases the simplified version of a requirements specification is enough to obtain a satisfactory domain model, however if the domain is very complex, the extended version of requirements specification could be necessary.	Ontology; Requirements specification; Domain modeling; Knowledge extraction	Iwona Dubielewicz,; Bogumiła Hnatkowska,; Zbigniew Huzar&; Lech Tuzinkiewicz	Software Engineering: Challenges and Solutions	https://doi.org/10.1007/978-3-319-43606-7_3		pp 31–45		Excluded	Excluded	new_screen			2	SpringerLink		Domain Modeling Based on Requirements Specification and Ontology	http://link.springer.com/chapter/10.1007/978-3-319-43606-7_3	Springer, Cham	nan; References; Year; Bibtex
401	Behave	Domain V: Adaptive Planning			Sumanta Boral						Excluded	Excluded	new_screen			2						
402	Behave	Domain VI: Problem Detection and Resolution	Agile teams are self-organized. At the beginning of every iteration, they collectively commit to deliver a certain scope within the timebox based on their capacity. However, even with the best of intentions, surprises do crop up in projects. A characteristics of self-organization involves dealing with problems, identifying them proactively, and responding appropriately by taking either preventive or corrective actions. In the two main sections of this chapter we look at two dimensions of problems – first, which are uncertain and called risks. The other one is about the methods that Agile teams use to assure quality of their incremental deliverables.	Exploratory Testing; User Story; Continuous Integration; Pair Programming; Product Owner	Sumanta Boral	Ace the PMI-ACP® exam	https://doi.org/10.1007/978-1-4842-2526-4_7		pp 263–300		Excluded	Excluded	new_screen			2	SpringerLink		Domain VI: Problem Detection and Resolution	http://link.springer.com/chapter/10.1007/978-1-4842-2526-4_7	Apress, Berkeley, CA	nan; References; Year; Bibtex
403	Behave	Editorial to the theme section on model-based testing			Mike PapadakisShaukat AliGilles Perrouin						Excluded	Excluded	new_screen			2						
404	Behave	Automated and effective testing of web services for XML injection attacks	XML is extensively used in web services for integration and data exchange. Its popularity and wide adoption make it an attractive target for attackers and a number of XML-based attack types have been reported recently. This raises the need for cost-effective, automated testing of web services to detect XML-related vulnerabilities, which is the focus of this paper. We discuss a taxonomy of the types of XML injection attacks and use it to derive four different ways to mutate XML messages, turning them into attacks (tests) automatically. Further, we consider domain constraints and attack grammars, and use a constraint solver to generate XML messages that are both malicious and valid, thus making it more difficult for any protection mechanism to recognise them. As a result, such messages have a better chance to detect vulnerabilities. Our evaluation on an industrial case study has shown that a large proportion (78.86%) of the attacks generated using our approach could circumvent the first layer of security protection, an XML gateway (firewall), a result that is much better than what a state-of-the-art tool based on fuzz testing could achieve.	XML injection; constraint solving; security testing	Sadeeq Jan; Cu D. Nguyen; Lionel C. Briand	ISSTA 2016: Proceedings of the 25th International Symposium on Software Testing and Analysis	https://doi.org/10.1145/2931037.2931042		12-23		Excluded	Excluded	new_screen			2	ACM		Effective Testing	https://link.springer.com/chapter/10.1007/978-1-4842-0268-5_7	Association for Computing Machinery	nan; References; Year; Bibtex
405	Behave	Efficient and Flexible Test Automation in Production Systems Engineering			Dietmar WinklerKristof MeixnerPetr Novak	Keyword -- Behavior Driven Test					Included	Included	new_screen			2						
406	Behave	Engineering Multi-agent Systems with Statecharts	http://link.springer.com/article/10.1007/s42979-021-00706-5		Nikolaos I. Spanoudakis		http://link.springer.com/article/10.1007/s42979-021-00706-5				Excluded	Excluded	new_screen			2						
407	Behave	Enterprise Information Systems			Prof. Dr. Joaquim FilipeMichał ŚmiałekAlexander BrodskySlimane Hammoudi						Excluded	Excluded	new_screen			2						
408	Behave	ESPRESSO: Robust discovery and quantification of transcript isoforms from error-prone long-read RNA-seq data	http://link.springer.com/chapter/10.1007/978-1-4842-9701-8_5		Godfrey Nolan		https://doi.org/doi:10.1126/sciadv.abq5072				Excluded	Excluded	new_screen			2	Pub Med Central		Espresso	http://link.springer.com/chapter/10.1007/978-1-4842-9701-8_5		nan; Venue; Authors; Abstract; Keywords; References; Pages; Year; Bibtex; Publisher
409	Behave	Every Product Owner Needs Four Things	I sincerely believe there are better Product Owners and not-so-good Product Owners. There are some organizations (teams, companies, enterprises) which offer a better environment for product ownership, and equally there are those which are downright hostile to product ownership.		Allan Kelly	The Art of Agile Product Ownership	https://doi.org/10.1007/978-1-4842-5168-3_5		pp 39–43		Excluded	Excluded	new_screen			2	SpringerLink		Every Product Owner Needs Four Things	http://link.springer.com/chapter/10.1007/978-1-4842-5168-3_5	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
410	Behave	Example-driven modeling: on effects of using examples on structural model comprehension, what makes them useful, and how to create them	http://link.springer.com/article/10.1007/s10270-017-0652-3		Dina ZayanAtrisha SarkarMichał AntkiewiczRita Suzana Pitangueira MacielKrzysztof Czarnecki		http://link.springer.com/article/10.1007/s10270-017-0652-3				Excluded	Excluded	new_screen			2						
411	Behave	Extending, Unit Testing, and Packaging	In the first nine chapters of this book we have analyzed various features of Ext JS 4. You learned how to use the UI controls, work with data components, create custom themes, and build applications that follow the MVC architecture. In this chapter you’ll find out about some miscellaneous features in Ext JS 4. For example, you’ll see how to extend the UI controls by creating custom components. I’ll discuss various options involved in creating custom components and plugins. You’ll also learn how to write unit tests in JavaScript to test our Ext JS 4 application. Finally you’ll learn how to create an Ext JS 4 application from scratch, package it, and deploy it to the web server.	Create Custom Components; Plug-in Time; Sencha; Jasmine; onRender	Prabhu Sunderaraman	Practical Ext JS 4	https://doi.org/10.1007/978-1-4302-6074-5_10		pp 185–205		Excluded	Excluded	new_screen			2	SpringerLink		Extending, Unit Testing, and Packaging	https://link.springer.com/chapter/10.1007/978-1-4302-6074-5_10	Apress, Berkeley, CA	nan; References; Year; Bibtex
412	Behave	The proposition of Process flow model for Scrum and eXtreme Programming	To carry out a quality project, the company collaborators need to rely on an efficient management methodology. It is the key to organize the project in a structured and streamlined manner, it helps the team to be more structured. The traditional methods are usually used on projects based on very precise ideas with very detailed specifications and planning which anticipated all possible risks. Nevertheless, these do not allow any kind of interaction with the customer, who will receive the project once it is finished. For that reason, solutions like eXtreme Programming and Scrum have been proposed by project management experts respecting the interaction with the customer, ability to change, and so on. These methods share the same values and principles, but each one has its own singularities. In this paper, we will present the process flow model of the Scrum and XP methods. For this process flow model, we used the BPMN models.	Agile methodologies; BPMN; Process flow model; Scrum; XP; eXtreme Programming	Soukaina Merzouk; Abdessamad Cherkaoui; Abdelaziz Marzak; Nawal Sael; Fatima-Zahra Guerss	NISS '21: Proceedings of the 4th International Conference on Networking, Information Systems & Security	https://doi.org/10.1145/3454127.3457627		1-6		Excluded	Excluded	new_screen			2	ACM		eXtreme Programming	http://link.springer.com/chapter/10.1007/978-1-4302-3534-7_3	Association for Computing Machinery	nan; References; Year; Bibtex
413	Behave	Flipping the Run/Build Ratio: The Business Case for Software Craftsmanship	We introduce the five business advantages of encouraging software craftsmanship among developers. We offer a tour of a sampling of craftsmanship practices and provide a glimpse into the worldview and intention of the software craftsman.	Package Implementation; Enterprise Architecture; Automate Test; Data Migration; User Story	Daryl Kulak&; Hong Li	The Journey to Enterprise Agility	https://doi.org/10.1007/978-3-319-54087-0_9		pp 137–151		Excluded	Excluded	new_screen			2	SpringerLink		Flipping the Run/Build Ratio: The Business Case for Software Craftsmanship	http://link.springer.com/chapter/10.1007/978-3-319-54087-0_9	Springer, Cham	nan; References; Year; Bibtex
414	Behave	Formal Specification Level	The steadily increasing complexity of the design of embedded systems led to the development of both an elaborated design flow that includes various abstraction levels and corresponding methods for synthesis and verification. However, until today the initial system specification is provided in natural language which is manually translated into a formal implementation e.g. at theElectronic System Level(ESL) by means of SystemC in a time-consuming and error-prone process.In this chapter, we envision a design flow which incorporates aFormal Specification Level(FSL) aiming at bridging the gap between the informal textbook specification and the formal ESL implementation. Modeling languages such as UML or SysML are envisaged for this purpose. Recent accomplishments towards this envisioned design flow, namely the automatic derivation of formal models from natural language descriptions, verification of formal models in the absence of an implementation, and code generation techniques, are briefly reviewed.		Rolf Drechsler,,; Mathias Soeken,&; Robert Wille,	Models, Methods, and Tools for Complex Chip Design	https://doi.org/10.1007/978-3-319-01418-0_3		pp 37–52		Excluded	Excluded	new_screen			2	SpringerLink		Formal Specification Level	http://link.springer.com/chapter/10.1007/978-3-319-01418-0_3	Springer, Cham	nan; Keywords; References; Year; Bibtex
415	Behave	Formal Testing from Natural Language in an Industrial Context	We present some results on developing formal testing strategies and tools for mobile applications, in the context of a partnership with Motorola, a Lenovo company. Actually, the overall scope is much larger, encompassing image processing, optimisation algorithms, sentiment analysis, energy-aware software design, and other research areas.	Natural Language; Sentiment Analysis; Test Case Generation; Natural Language Description; Manual Execution	Augusto Sampaio&; Filipe Arruda	Brazilian Symposium on Formal Methods	https://doi.org/10.1007/978-3-319-49815-7_2		pp 21–38		Excluded	Excluded	new_screen			2	SpringerLink		Formal Testing from Natural Language in an Industrial Context	http://link.springer.com/chapter/10.1007/978-3-319-49815-7_2	Springer, Cham	nan; References; Year; Bibtex
416	Behave	FRAGGLE: A FRamework for AGile Gamification of Learning Experiences			Alberto MoraPanagiotis ZahariasCarina GonzálezJoan Arnedo-Moreno	Framework inspired by BDD					Excluded	Excluded	new_screen			2						
417	Behave	Fragment-based spreadsheet debugging	http://link.springer.com/article/10.1007/s10515-018-0250-9		Dietmar JannachThomas SchmitzBirgit HoferKonstantin SchekotihinPatrick KochFranz Wotawa		http://link.springer.com/article/10.1007/s10515-018-0250-9				Excluded	Excluded	new_screen			2						
418	Behave	Framework Options and Design Pattern	In the last chapter, you saw waits and timeouts. Protractor can be used with different types of frameworks. Choosing a framework depends on a lot of different factors. Protractor’s flexibility allows it to be implemented using any of the frameworks on the market. This chapter looks at the following, including frameworks that are compatible with Protractor.		Shashank Shukla	The Protractor Handbook	https://doi.org/10.1007/978-1-4842-7289-3_9		pp 167–179		Excluded	Excluded	new_screen			2	SpringerLink		Framework Options and Design Pattern	http://link.springer.com/chapter/10.1007/978-1-4842-7289-3_9	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
419	Behave	From COBOL to Business Rules—Extracting Business Rules from Legacy Code	The reverse engineering project described in this paper is aimed at documenting a 6.4 million lines of code COBOL/IMS/DB2 system for world-wide car leasing. The ultimate goal is to re-implement that system. The system was originally developed in the 1980s with less than 3 million code lines and has since evolved to its current size. It survived the year 2000 date change and the Euro conversion as well as several major company reorganizations to preserve the continuity of the leasing service. Finally, after 30 years of service it is planned to retire the system. However, the first two attempts to replace it, one by automatically converting it and the other by replacing it with a standard package ended in failure. It is now planned to rewrite the system based on a specification derived from the current code base. That specification includes among other documents a documentation of the processing rules. The extracted rules are intended to act as guide to those writing the new code.		Harry M. Sneed&; Chris Verhoef	Integrating Research and Practice in Software Engineering	https://doi.org/10.1007/978-3-030-26574-8_14		pp 187–208		Excluded	Excluded	new_screen			2	SpringerLink		From COBOL to Business Rules—Extracting Business Rules from Legacy Code	http://link.springer.com/chapter/10.1007/978-3-030-26574-8_14	Springer, Cham	nan; Keywords; References; Year; Bibtex
420	Behave	From Requirements to Automated Acceptance Tests with the RSL Language	Software testing can promote software quality. However, this activity is often performed at the end of projects where failures are most difficult to correct. Combining requirements specification activities with test design at an early stage of the software development process can be beneficial. One way to do this is to use a more structured requirements specification language. This allow to reduce typical problems such as ambiguity, inconsistency, and incorrectness in requirements and may allow the automatic generation of (parts of) acceptance test cases reducing the test design effort. In this paper we discuss an approach that promotes the practice of requirements specification combined with testing specification. This is a model-based approach that promotes the alignment between requirements and tests, namely, test cases and also low-level automated test scripts. To show the applicability of this approach, we integrate two complementary languages: (i) the ITLingo RSL (Requirements Specification Language) that is specially designed to support both requirements and tests rigorously and consistently specified; and (ii) the Robot language, which is a low-level keyword-based language for specifying test scripts. This approach includes model-to-model transformation processes, namely a transformation process from requirements (defined in RSL) into test cases (defined in RSL), and a second transformation process from test cases (in RSL) into test scripts (defined according the Robot framework). This approach was applied in a fictitious online store that illustrates the various phases of the proposal.	Requirements Specification Language (RSL); Test case specification; Model-based Testing (MBT); Test case generation; Test case execution	Ana C. R. Paiva,,; Daniel Maciel&; Alberto Rodrigues da Silva	International Conference on Evaluation of Novel Approaches to Software Engineering	https://doi.org/10.1007/978-3-030-40223-5_3		pp 39–57		Excluded	Excluded	new_screen			2	SpringerLink		From Requirements to Automated Acceptance Tests with the RSL Language	http://link.springer.com/chapter/10.1007/978-3-030-40223-5_3	Springer, Cham	nan; References; Year; Bibtex
421	Behave	From Requirements to Verifiable Executable Models Using Rebeca			Marjan SirjaniLuciana ProvenzanoSara Abbaspour AsadollahMahshid Helali Moghadam						Excluded	Excluded	new_screen			2						
422	Behave	Fusing Modeling and Programming into Language-Oriented Programming	Modeling in general is of course different from programming (think: climate models). However, when we consider the role of models in the context of “model-driven”, i.e., when they are used to automatically construct software, it is much less clear that modeling is different from programming. In this paper, I argue that the two are conceptually indistinguishable, even though in practice they traditionally emphasize different aspects of the (conceptually indistinguishable) common approach. The paper discusses and illustrates language-oriented programming, the approach to {modeling|programming} we have successfully used over the last 7 years to build a range of innovative systems in domains such as insurance, healthcare, tax, engineering and consumer electronics. It relies on domain-specific languages, modular language extension, mixed notations, and in particular, the Jetbrains MPS language workbench.	Domain-specific languages; Language modularity; Function programming; Language engineering; Meta programming	Markus Voelter	International Symposium on Leveraging Applications of Formal Methods	https://doi.org/10.1007/978-3-030-03418-4_19		pp 309–339		Excluded	Excluded	new_screen			2	SpringerLink		Fusing Modeling and Programming into Language-Oriented Programming	http://link.springer.com/chapter/10.1007/978-3-030-03418-4_19	Springer, Cham	nan; References; Year; Bibtex
423	Behave	Gamification: a systematic review of design frameworks	http://link.springer.com/article/10.1007/s12528-017-9150-4		Alberto MoraDaniel RieraCarina GonzálezJoan Arnedo-Moreno		http://link.springer.com/article/10.1007/s12528-017-9150-4				Excluded	Excluded	new_screen			2						
424	Behave	Getting Coaching That Really Helps	We examine the current state of Agile coaching, which relies on the flawed shu-ha-ri model. As an alternative, we look back to the International Institute of Rural Reconstruction and James Yen’s work with poor Chinese villagers for a less patronizing, more effective coaching worldview. We also show how the various certification programs in the Agile world tend to reinforce mechanical knowledge and behavior.	Enterprise Architecture; Training Class; User Story; Agile Practice; Product Owner	Daryl Kulak&; Hong Li	The Journey to Enterprise Agility	https://doi.org/10.1007/978-3-319-54087-0_13		pp 197–209		Excluded	Excluded	new_screen			2	SpringerLink		Getting Coaching That Really Helps	http://link.springer.com/chapter/10.1007/978-3-319-54087-0_13	Springer, Cham	nan; References; Year; Bibtex
425	Behave	Getting Started	http://link.springer.com/chapter/10.1007/978-1-4842-7289-3_1		Shashank Shukla		http://link.springer.com/chapter/10.1007/978-1-4842-7289-3_1				Excluded	Excluded	new_screen			2	Pub Med Central		Getting Started	http://link.springer.com/chapter/10.1007/978-1-4842-7289-3_1		nan; Venue; Authors; Abstract; Keywords; References; Pages; Year; Bibtex; DOI; Publisher
426	Behave	Getting Started with Selenium and Visual Studio			Chaminda ChandrasekaraPushpa Herath						Excluded	Excluded	new_screen			2						
427	Behave	Getting Started with Test-Driven Development	This chapter introduces the basic concepts of Test-Driven Development in Swift with XCTest by implementing the leap year evaluation algorithm. You'll learn how to practice the Red, green, refactor cycle, about the Test List, Fake It, and Wishful Coding patterns, and how the compiler fits in the TDD workflow.		Gio Lodi	Test-Driven Development in Swift	https://doi.org/10.1007/978-1-4842-7002-8_3		pp 27–42		Excluded	Excluded	new_screen			2	SpringerLink		Getting Started with Test-Driven Development	http://link.springer.com/chapter/10.1007/978-1-4842-7002-8_3	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
428	Behave	Groovy Awesomeness	This short chapter introduces various useful frameworks within the Groovy ecosystem. Some of these will be described more fully in later chapters.	Cloud Computing; Maintenance Mode; Static Code Analysis; Java Project; Instal Programming	Adam L. Davis	Learning Groovy	https://doi.org/10.1007/978-1-4842-2117-4_11		pp 61–64		Excluded	Excluded	new_screen			2	SpringerLink		Groovy Awesomeness	http://link.springer.com/chapter/10.1007/978-1-4842-2117-4_11	Apress, Berkeley, CA	nan; References; Year; Bibtex
429	Behave	Hamcrest vs AssertJ: An Empirical Assessment of Tester Productivity	Context. Extensive unit testing is worth its costs in terms of the higher quality of the final product and reduced development expenses, though it may consume more than fifty percent of the overall project budget. Thus, even a tiny percentage of saving can significantly decrease the costs. Since recently competing assertion libraries emerged, we need empirical evidence to gauge them in terms of developer productivity, allowing SQA Managers and Testers to select the best.Objective. The aim of this work is comparing two assertion frameworks having a different approach (matchers vs. fluent assertions) w.r.t. tester productivity.Method. We conducted a controlled experiment involving 41 Bachelor students. AssertJ is compared with Hamcrest, in a test development scenario with the Java language. We analysed the number of correct assertions developed in a tight time frame and used this measure as a proxy for tester productivity.Results. The results show that adopting AssertJ improves the overall tester’s productivity significantly during the development of assertions.Conclusions. Testers and SQA managers selecting assertion frameworks for their organizations should consider as first choice AssertJ, since our study shows that it increases the productivity of testers during development more than Hamcrest.	Hamcrest; AssertJ; Empirical study	Maurizio LeottaORCID:orcid.org/---,; Maura CerioliORCID:orcid.org/---,; Dario Olianas&; Filippo RiccaORCID:orcid.org/---	International Conference on the Quality of Information and Communications Technology	https://doi.org/10.1007/978-3-030-29238-6_12		pp 161–176		Excluded	Excluded	new_screen			2	SpringerLink		Hamcrest vs AssertJ: An Empirical Assessment of Tester Productivity	http://link.springer.com/chapter/10.1007/978-3-030-29238-6_12	Springer, Cham	nan; References; Year; Bibtex
430	Behave	How Do Software Architects Specify and Validate Quality Requirements?			Andrea CaraccioloMircea Filip LunguOscar Nierstrasz						Excluded	Excluded	new_screen			2						
431	Behave	ICITPM: Integrity Validation of Software in Iterative Continuous Integration Through the Use of Trusted Platform Module (TPM)	Software development has passed from being rigid and not very flexible, to be automated with constant changes. This happens due to the creation of continuous integration and delivery environments. Nevertheless, developers often rely on such environments due to the large number of amenities they offer. They focus on authentication only, without taking into consideration other aspects of security such as the integrity of the source code and of the compiled binaries. The source code of a software project must not be maliciously modified. Notwithstanding, there is no safe method to verify that its integrity has not been violated. Trusted computing technology, in particular, the Trusted Platform Module (TPM) can be used to implement that secure method.	CI/CD pipeline; Code integrity; Trusted computing; TPM	Antonio Muñoz,; Aristeidis Farao,; Jordy Ryan Casas Correia&; Christos Xenakis	European Symposium on Research in Computer Security	https://doi.org/10.1007/978-3-030-66504-3_9		pp 147–165		Excluded	Excluded	new_screen			2	SpringerLink		ICITPM: Integrity Validation of Software in Iterative Continuous Integration Through the Use of Trusted Platform Module (TPM)	https://link.springer.com/chapter/10.1007/978-3-030-66504-3_9	Springer, Cham	nan; References; Year; Bibtex
432	Behave	Implement Tests in Our Daily Work Routine	We discussed many types of tests – unit, integration, performance, UI, and snapshot tests. But if you ask me what the most challenging task in writing tests is, I would say actually writing them.		Avi Tsadok	Pro iOS Testing	https://doi.org/10.1007/978-1-4842-6382-2_10		pp 261–283		Excluded	Excluded	new_screen			2	SpringerLink		Implement Tests in Our Daily Work Routine	https://link.springer.com/chapter/10.1007/978-1-4842-6382-2_10	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
433	Behave	In the right order of brush strokes: a sketch of a software philosophy retrospective	http://link.springer.com/article/10.1186/2193-1801-3-186		Evgeny Pyshkin		http://link.springer.com/article/10.1186/2193-1801-3-186				Excluded	Excluded	new_screen			2						
434	Behave	Incident Management Adaption	Whenever somebody refers to IT service management or ITIL, the first process that comes up on the table for discussion is the incident management process. No matter how far away one might be from the service management area, they always seem to be quite familiar with the process and its relevance. It is a highly popular process that finds its rightful place in every single organization. Since this process makes or breaks an organization’s service delivery, service providers often give plenty of weight to the process, and as a result, the incident management process is perhaps the most mature of all the ITIL processes.		Abhinav Krishna Kaiser	Reinventing ITIL® in the Age of DevOps	https://doi.org/10.1007/978-1-4842-3976-6_7		pp 163–199		Excluded	Excluded	new_screen			2	SpringerLink		Incident Management Adaption	http://link.springer.com/chapter/10.1007/978-1-4842-3976-6_7	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
435	Behave	Index									Excluded	Excluded	new_screen			2						
436	Behave	Industry practices and challenges for the evolvability assurance of microservices	https://link.springer.com/article/10.1007/s10664-021-09999-9		Justus BognerJonas FritzschStefan WagnerAlfred Zimmermann		https://link.springer.com/article/10.1007/s10664-021-09999-9				Excluded	Excluded	new_screen			2						
437	Behave	InstAL: An Institutional Action Language	InstALdenotes both a declarative domain-specific language for the specification of collections of interacting normative systems and a framework for a set of associated tools. The computational model is realized by translating the specification language toAnsProlog(Baral 2003), a logic programming language under the answer set semantics (ASP) (Gelfond and Lifschitz 1991), and is underpinned by a set-theoretic formal model and a formalized translation process.	AnsProlog; Answer Set; Declarative Domain-specific Languages; Tendency Scenario; Clingo	Julian Padget,; Emad ElDeen Elakehal,; Tingting Li&; Marina De Vos	Social Coordination Frameworks for Social Technical Systems	https://doi.org/10.1007/978-3-319-33570-4_6		pp 101–124		Excluded	Excluded	new_screen			2	SpringerLink		InstAL: An Institutional Action Language	http://link.springer.com/chapter/10.1007/978-3-319-33570-4_6	Springer, Cham	nan; References; Year; Bibtex
438	Behave	Installing Quick	If you have been for a few years, chances are that you have been brought on to add new features to an existing app with a large code base that has been built over a few years and has been worked on by dozens of developers, most of whom have moved on to other projects.		Abhishek Mishra	iOS Code Testing	https://doi.org/10.1007/978-1-4842-2689-6_11		pp 329–349		Excluded	Excluded	new_screen			2	SpringerLink		Installing Quick	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_11	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
439	Behave	Integrating Quality Tooling into the Chef Development Life Cycle	The Chef ecosystem is fortunate to have many tools available to it to help in the quest for quality. This chapter introduces some of the tools that are publicly available to help. Eventually we will be using these tools as part of a Continuous Delivery pipeline, and it is important to get an understanding of how each tool can be executed individually.	Acceptance Test; Configuration File; Text Editor; Special Symbol; Code Coverage	Stuart Preston	Using Chef with Microsoft Azure	https://doi.org/10.1007/978-1-4842-1476-3_6		pp 131–162		Excluded	Excluded	new_screen			2	SpringerLink		Integrating Quality Tooling into the Chef Development Life Cycle	https://link.springer.com/chapter/10.1007/978-1-4842-1476-3_6	Apress, Berkeley, CA	nan; References; Year; Bibtex
440	Behave	Integration of Security Standards in DevOps Pipelines: An Industry Case Study	In the last decade, companies adopted DevOps as a fast path to deliver software products according to customer expectations, with well aligned teams and in continuous cycles. As a basic practice, DevOps relies on pipelines that simulate factory swim-lanes. The more automation in the pipeline, the shorter a lead time is supposed to be. However, applying DevOps is challenging, particularly for industrial control systems (ICS) that support critical infrastructures and that must obey to rigorous requirements from security regulations and standards. Current research on security compliant DevOps presents open gaps for this particular domain and in general for systematic application of security standards. In this paper, we present a systematic approach to integrate standard-based security activities into DevOps pipelines and highlight their automation potential. Our intention is to share our experiences and help practitioners to overcome the trade-off between adding security activities into the development process and keeping a short lead time. We conducted an evaluation of our approach at a large industrial company considering the IEC 62443-4-1 security standard that regulates ICS. The results strengthen our confidence in the usefulness of our approach and artefacts, and in that they can support practitioners to achieve security compliance while preserving agility including short lead times.	Secure software engineering; Security standards; Agile software engineering; DevOps pipeline; DevSecOps; Industrial control systems	Fabiola MoyónORCID:orcid.org/---,; Rafael Soares,; Maria Pinto-AlbuquerqueORCID:orcid.org/---,; Daniel MendezORCID:orcid.org/---,&; Kristian Beckers	International Conference on Product-Focused Software Process Improvement	https://doi.org/10.1007/978-3-030-64148-1_27		pp 434–452		Excluded	Excluded	new_screen			2	SpringerLink		Integration of Security Standards in DevOps Pipelines: An Industry Case Study	http://link.springer.com/chapter/10.1007/978-3-030-64148-1_27	Springer, Cham	nan; References; Year; Bibtex
441	Behave	Inter-organizational Co-development with Scrum: Experiences and Lessons Learned from a Distributed Corporate Development Environment	Distributed development within a single organization adds a lot of overhead to every software development process. When a second organization joins for co-development, complexity reaches the next level. This case study investigates an agile approach from a real world project involving two unaffiliated IT organizations that collaborate in a distributed development environment. Adaptations to the regular Scrum process are identified and evaluated over a six-month-long period of time. The evaluation involves a detailed problem root cause analysis and suggestions on what issues to act first. Key lessons learned include that team members of one Scrum team should not be distributed over several sites and that every site should have at least one Scrum master and one product owner.	distributed development; agile development; Scrum; software development process; subcontracting; virtual teams	Raoul Vallon,; Stefan Strobl,; Mario Bernhart&; Thomas Grechenig	International Conference on Agile Software Development	https://doi.org/10.1007/978-3-642-38314-4_11		pp 150–164		Excluded	Excluded	new_screen			2	SpringerLink		Inter-organizational Co-development with Scrum: Experiences and Lessons Learned from a Distributed Corporate Development Environment	http://link.springer.com/chapter/10.1007/978-3-642-38314-4_11	Springer, Berlin, Heidelberg	nan; References; Year; Bibtex
442	Behave	Language design and implementation using ruby and the interpreter pattern	In this paper, the S-expression Interpreter Framework (SIF) is presented as a tool for teaching language design and implementation. The SIF is based on the interpreter design pattern and is written in the Ruby programming language. Its core is quite small, but it can be easily extended by adding primitive procedures and special forms. The SIF can be used to demonstrate advanced language concepts (variable scopes, continuations, etc.) as well as different programming styles (functional, imperative, and object oriented).	s-expression;  ruby;  interpreter;  design patterns	Ortiz, Ariel	These keywords were added by machine and not by the authors. This process is experimental and the keywords may be updated as the learning algorithm improves.	https://doi.org/10.1145/1352135.1352155		48-52	"@inproceedings{10.1145/1352135.1352155,
    author = ""Ortiz, Ariel"",
    title = ""Language design and implementation using ruby and the interpreter pattern"",
    year = ""2008"",
    isbn = ""9781595937995"",
    publisher = ""Association for Computing Machinery"",
    address = ""New York, NY, USA"",
    url = ""https://doi.org/10.1145/1352135.1352155"",
    doi = ""10.1145/1352135.1352155"",
    abstract = ""In this paper, the S-expression Interpreter Framework (SIF) is presented as a tool for teaching language design and implementation. The SIF is based on the interpreter design pattern and is written in the Ruby programming language. Its core is quite small, but it can be easily extended by adding primitive procedures and special forms. The SIF can be used to demonstrate advanced language concepts (variable scopes, continuations, etc.) as well as different programming styles (functional, imperative, and object oriented)."",
    booktitle = ""Proceedings of the 39th SIGCSE Technical Symposium on Computer Science Education"",
    pages = ""48-52"",
    numpages = ""5"",
    keywords = ""s-expression, ruby, interpreter, design patterns"",
    location = ""Portland, OR, USA"",
    series = ""SIGCSE '08""
}

@article{10.1145/1352322.1352155,
    author = ""Ortiz, Ariel"",
    title = ""Language design and implementation using ruby and the interpreter pattern"",
    year = ""2008"",
    issue_date = ""March 2008"",
    publisher = ""Association for Computing Machinery"",
    address = ""New York, NY, USA"",
    volume = ""40"",
    number = ""1"",
    issn = ""0097-8418"",
    url = ""https://doi.org/10.1145/1352322.1352155"",
    doi = ""10.1145/1352322.1352155"",
    abstract = ""In this paper, the S-expression Interpreter Framework (SIF) is presented as a tool for teaching language design and implementation. The SIF is based on the interpreter design pattern and is written in the Ruby programming language. Its core is quite small, but it can be easily extended by adding primitive procedures and special forms. The SIF can be used to demonstrate advanced language concepts (variable scopes, continuations, etc.) as well as different programming styles (functional, imperative, and object oriented)."",
    journal = ""SIGCSE Bull."",
    month = ""mar"",
    pages = ""48-52"",
    numpages = ""5"",
    keywords = ""s-expression, ruby, interpreter, design patterns""
}"	Excluded	Excluded	new_screen			2	ScopusSignedIn		Interpreter Pattern	http://link.springer.com/chapter/10.1007/978-1-4842-2680-3_12	Association for Computing Machinery	nan; Venue; References
443	Behave	Interviews and Case Studies	A collection of interviews from various thought leaders in the DevOps community.		Dave Harrison&; Knox Lively	Achieving DevOps	https://doi.org/10.1007/978-1-4842-4388-6_9		pp 379–483		Excluded	Excluded	new_screen			2	SpringerLink		Interviews and Case Studies	http://link.springer.com/chapter/10.1007/978-1-4842-4388-6_9	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
444	Behave	Introducing a New Agile Development for Web Applications Using a Groupware as Example	The purpose of this paper is introduce a new agile methodology for Web development based on User Stories and that use some concepts of Scrum like Product Backlog and Sprint. The methodology is divided in three disciplines: Communication, Modeling and Construction; each one refining the User Stories, from requirements specification with the User and the use of the Navigation Model and Story Cards until the execution of these User Stories to guide the coding. Thus, the development team can use these User Stories as acceptance tests, which represent the User behavior when using the system. The code written to pass in those tests can generate, through reverse engineering, design for the team to evaluate how the Web application is being developed and evolved. In the end, the team has more guarantees that the Web application developed represents what the User wanted in the beginning.	Agile Process; User Story; Navigation Model; Web Development	Vinicius Pereira&; Antonio Francisco do Prado	International Conference on Integrated Computing Technology	https://doi.org/10.1007/978-3-642-22247-4_13		pp 144–160		Excluded	Excluded	new_screen			2	SpringerLink		Introducing a New Agile Development for Web Applications Using a Groupware as Example	http://link.springer.com/chapter/10.1007/978-3-642-22247-4_13	Springer, Berlin, Heidelberg	nan; References; Year; Bibtex
445	Behave	Introduction to Behavior-Driven Development	Behavior-Driven Development (BDD) is an approach to software development that was built with the aim of formalizing the best practices followed by Test-Driven Development practitioners. This chapter will introduce you to BDD concepts and techniques.		Abhishek Mishra	iOS Code Testing	https://doi.org/10.1007/978-1-4842-2689-6_10		pp 317–327		Excluded	Excluded	new_screen			2	SpringerLink		Introduction to Behavior-Driven Development	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_10	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
446	Behave	Introduction to Cucumber	Cucumber (Figure 6-1) is an awesome tool that allows you to develop your software using a Behavior-Driven Approach (BDA). It makes sure that business stakeholders transfer the software requirements to developers in an accurate and rigorous way so that the final software delivered fully satisfies those requirements. Also, the requirements are turned into executable specifications of the application developed, and they are executed on every new commit to make sure that no old features are broken when new ones are introduced. Cucumber is a great tool of collaboration, documentation, and test automation.		Panos Matsinopoulos	Practical Test Automation	https://doi.org/10.1007/978-1-4842-6141-5_6		pp 199–230		Excluded	Excluded	new_screen			2	SpringerLink		Introduction to Cucumber	http://link.springer.com/chapter/10.1007/978-1-4842-6141-5_6	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
447	Behave	Introduction to DevOps	New ways of working or new methodologies begin to unearth because of a problem---yes, it all starts with a problem. DevOps too had its own reasons. Businesses craved for fast turnarounds of their solutions. And often businesses found out in the midst of development that they didn’t have all the information they needed to make the right decisions. They wanted to recommend a few more changes to the requirements and still expected the delivery to happen on time. DevOps was born to solve this problem.		Abhinav Krishna Kaiser	Reinventing ITIL® in the Age of DevOps	https://doi.org/10.1007/978-1-4842-3976-6_1		pp 1–35		Excluded	Excluded	new_screen			2	SpringerLink		Introduction to DevOps	http://link.springer.com/chapter/10.1007/978-1-4842-3976-6_1	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
448	Behave	Introduction to RSpec	RSpec advertises as being the tool that makes TDD (Test-Driven Development) and BDD (Behavior-Driven Development) fun. This is an introduction to RSpec that will give you enough knowledge to write your first Ruby application and cover it with RSpec specifications – or, actually, since you are doing TDD, to first write the specifications and then implement the application. It is the foundation for the next chapters that deal with more advanced concepts of RSpec and testing in general.		Panos Matsinopoulos	Practical Test Automation	https://doi.org/10.1007/978-1-4842-6141-5_4		pp 109–157		Excluded	Excluded	new_screen			2	SpringerLink		Introduction to RSpec	http://link.springer.com/chapter/10.1007/978-1-4842-6141-5_4	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
449	Behave	Introduction to Security and Quality Improvement in Complex Cyber-Physical Systems Engineering	ProvidingComplex Cyber-Physical Systems(C-CPSs) more efficiently and faster is a goal that requires improvements in engineering process for producing high-quality, advanced engineering artifacts. Furthermore, information security must be a top priority when engineering C-CPSs as the engineering artifacts represent assets of high value.This chapter overviews the engineering process of C-CPSs, typically long-running technical systems, such as industrial manufacturing systems and continuous processing systems. This chapter also covers major areas of requirements that include: (a) processes with intensive generation of engineering artifacts; (b) challenges regarding dependencies and complexity of engineering artifacts, stemming from variants of a product and the associated production process for a family of products; (c) management of model and consistency rules for dependencies between model parts; (d) the internationalization of the engineering process with partners on different levels of trust; and (e) the security of the engineering processes, such as confidentiality of engineering plans, and the security of the systems to be engineered, such as security aspects in the design phase.For selected requirement areas, the chapter discusses several approaches for quality improvement from business informatics that addresses important classes of requirements, but introduces new complexity to the engineering process. Therefore, the chapter reviews information security improvement approaches for engineering processes, including the consideration of new security requirements stemming from risks introduced by advanced informatics solutions. Finally, the chapter provides an overview on the book parts and the contributions of the chapters to address advanced engineering process requirements.	Complex cyber-physical systems; Engineering process; Multidisciplinary engineering; AutomationML; Information security	Stefan Biffl,; Matthias Eckhart,,; Arndt Lüder&; Edgar Weippl	Security and Quality in Cyber-Physical Systems Engineering	https://doi.org/10.1007/978-3-030-25312-7_1		pp 1–29		Excluded	Excluded	new_screen			2	SpringerLink		Introduction to Security and Quality Improvement in Complex Cyber-Physical Systems Engineering	http://link.springer.com/chapter/10.1007/978-3-030-25312-7_1	Springer, Cham	nan; References; Year; Bibtex
450	Behave	Introduction to Test-Driven Development	Well over a billion apps have been developed for the iOS platform since its inception. Most of the early apps were rather simple and often developed by a single developer. Over the years, iOS apps have become increasingly complex pieces of software that often involve large, distributed teams of developers working in Agile environments with complex build and release pipelines.		Abhishek Mishra	iOS Code Testing	https://doi.org/10.1007/978-1-4842-2689-6_1		pp 1–11		Excluded	Excluded	new_screen			2	SpringerLink		Introduction to Test-Driven Development	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_1	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
451	Behave	Introduction to Testing with Rspec	Before we move into our main project for this book, we still have another very important topic to cover—testing.	Category Model; Controller Action; Test Code; Sample Category; User Story	John Hunt	Foundation Rails 2	https://doi.org/10.1007/978-1-4302-1040-5_10		pp 253–289		Excluded	Excluded	new_screen			2	SpringerLink		Introduction to Testing	http://link.springer.com/chapter/10.1007/978-1-4302-1040-5_10	Apress	nan; Authors; References; Year; Bibtex
452	Behave	Introduction to Testing with Rspec	http://link.springer.com/book/10.1007/978-1-4842-2689-6				http://link.springer.com/book/10.1007/978-1-4842-2689-6				Excluded	Excluded	new_screen			2						
453	Behave	iOS Code Testing	https://link.springer.com/book/10.1007/978-1-4842-2689-6		Abhishek Mishra		https://link.springer.com/book/10.1007/978-1-4842-2689-6				Excluded	Excluded	new_screen			2						
454	Behave	Iterative and Scenario-Based Requirements Specification in a System of Systems Context	[Context & Motivation] Due to the managerial, operational and evolutionary independence of constituent systems (CSs) in a System of Systems (SoS) context, top-down and linear requirements engineering (RE) approaches are insufficient. RE techniques for SoS must support iterating, changing, synchronizing, and communicating requirements across different abstraction and hierarchy levels as well as scopes of responsibility. [Question/Problem] We address the challenge of SoS requirements specification, where requirements can describe the SoS behavior, but also the behavior of CSs that are developed independently. [Principal Ideas] To support the requirements specification in an SoS environment, we propose a scenario-based and iterative specification technique. This allows requirements engineers to continuously model and jointly execute and test the system behavior for the SoS and the CS in order to detect contradictions in the requirement specifications at an early stage. [Contribution] In this paper, we describe an extension for the scenario-modeling language for Kotlin (SMLK) to continuously and formally model requirements on SoS and CS level. To support the iterative requirements specification and modeling we combine SMLK with agile development techniques. We demonstrate the applicability of our approach with the help of an example from the field of e-mobility.	System of systems engineering; Requirements analysis; Requirements specification; Scenario-based requirements modeling	Carsten WiecherORCID:orcid.org/---,; Joel GreenyerORCID:orcid.org/---,; Carsten WolffORCID:orcid.org/---,; Harald Anacker&; Roman Dumitrescu	International Working Conference on Requirements Engineering: Foundation for Software Quality	https://doi.org/10.1007/978-3-030-73128-1_12		pp 165–181		Included	Included	new_screen			2	SpringerLink		Iterative and Scenario-Based Requirements Specification in a System of Systems Context	http://link.springer.com/chapter/10.1007/978-3-030-73128-1_12	Springer, Cham	nan; References; Year; Bibtex
455	Behave	Generating fixtures for JavaScript unit testing	In today's web applications, JavaScript code interacts with the Document Object Model (DOM) at runtime. This runtime interaction between JavaScript and the DOM is error-prone and challenging to test. In order to unit test a JavaScript function that has read/write DOM operations, a DOM instance has to be provided as a test fixture. This DOM fixture needs to be in the exact structure expected by the function under test. Otherwise, the test case can terminate prematurely due to a null exception. Generating these fixtures is challenging due to the dynamic nature of JavaScript and the hierarchical structure of the DOM. We present an automated technique, based on dynamic symbolic execution, which generates test fixtures for unit testing JavaScript functions. Our approach is implemented in a tool called ConFix. Our empirical evaluation shows that ConFix can effectively generate tests that cover DOM-dependent paths. We also find that ConFix yields considerably higher coverage compared to an existing JavaScript input generation technique.	DOM;  JavaScript;  concolic execution;  dynamic symbolic execution;  test fixture;  test generation;  web applications	Fard, Amin Milani; Mesbah, Ali; Wohlstadter, Eric		https://doi.org/10.1109/ASE.2015.26		190-200	"@inproceedings{10.1109/ASE.2015.26,
    author = ""Fard, Amin Milani and Mesbah, Ali and Wohlstadter, Eric"",
    title = ""Generating fixtures for JavaScript unit testing"",
    year = ""2015"",
    isbn = ""9781509000241"",
    publisher = ""IEEE Press"",
    url = ""https://doi.org/10.1109/ASE.2015.26"",
    doi = ""10.1109/ASE.2015.26"",
    abstract = ""In today's web applications, JavaScript code interacts with the Document Object Model (DOM) at runtime. This runtime interaction between JavaScript and the DOM is error-prone and challenging to test. In order to unit test a JavaScript function that has read/write DOM operations, a DOM instance has to be provided as a test fixture. This DOM fixture needs to be in the exact structure expected by the function under test. Otherwise, the test case can terminate prematurely due to a null exception. Generating these fixtures is challenging due to the dynamic nature of JavaScript and the hierarchical structure of the DOM. We present an automated technique, based on dynamic symbolic execution, which generates test fixtures for unit testing JavaScript functions. Our approach is implemented in a tool called ConFix. Our empirical evaluation shows that ConFix can effectively generate tests that cover DOM-dependent paths. We also find that ConFix yields considerably higher coverage compared to an existing JavaScript input generation technique."",
    booktitle = ""Proceedings of the 30th IEEE/ACM International Conference on Automated Software Engineering"",
    pages = ""190-200"",
    numpages = ""11"",
    keywords = ""DOM, JavaScript, concolic execution, dynamic symbolic execution, test fixture, test generation, web applications"",
    location = ""Lincoln, Nebraska"",
    series = ""ASE '15""
}"	Excluded	Excluded	new_screen			2	ScopusSignedIn		JavaScript Unit Testing	https://link.springer.com/chapter/10.1007/978-1-4302-6674-7_10	IEEE Press	nan; Venue; References
456	Behave	KODEGEN: A Code Generation and Testing Tool Using Runnable Knowledge	KDE –Knowledge Driven Engineering– is a generalization of MDE – Model Driven Engineering – to a higher level of abstraction than the standard UML software models, aiming to be closer to the system designer concepts. But in order to reach an effective technology applicable in industry, one needs to implement it in a tool usingRunnable Knowledge, i.e. which can be run and tested. This work describes KODEGEN – a KDE tool for testing while generating code – whose input consists of system ontologies, ontology states and scenario files. Incidental concepts not part of the ontologies are replaced by mock objects. The implementation uses a modified Gherkin syntax. The tool is demonstrated in practice by generating the actual code for a few case-studies.		Iaakov Exman,; Anton Litovka&; Reuven Yagel	International Joint Conference on Knowledge Discovery, Knowledge Engineering, and Knowledge Management	https://doi.org/10.1007/978-3-662-46549-3_17		pp 260–275		Excluded	Excluded	new_screen			2	SpringerLink		KODEGEN: A Code Generation and Testing Tool Using Runnable Knowledge	http://link.springer.com/chapter/10.1007/978-3-662-46549-3_17	Springer, Berlin, Heidelberg	nan; Keywords; References; Year; Bibtex
457	Behave	Languages, Frameworks, Libraries, and Tools	Building hybrid mobile apps with Ionic requires mostly front-end skills, including HTML, JavaScript, and CSS. You should have basic knowledge of these programming languages before reading this book. This chapter doesn’t contain a basic introduction of these languages. You can find a lot of online resources if you do need to learn HTML, JavaScript, and CSS. Modern front-end development requires a lot more than just simple HTML, JavaScript, and CSS code. We need to deal with different languages, frameworks, libraries, and tools.	Angular App; UserService; TypeScript Compiler; TypeScript Code; Literal Template	Fu Cheng	Build Mobile Apps with Ionic 4 and Firebase	https://doi.org/10.1007/978-1-4842-3775-5_2		pp 29–66		Excluded	Excluded	new_screen			2	SpringerLink		Languages, Frameworks, Libraries, and Tools	http://link.springer.com/chapter/10.1007/978-1-4842-3775-5_2	Apress, Berkeley, CA	nan; References; Year; Bibtex
458	Behave	Lean R&D: An Agile Research and Development Approach for Digital Transformation			Marcos KalinowskiHélio LopesAlex Furtado TeixeiraGabriel da Silva CardosoAndré KuramotoBruno ItagybaSolon Tarso BatistaJuliana Alves PereiraThuener SilvaJorge Alam WarrakMarcelo da CostaMarinho FischerCristiane SalgadoBianca TeixeiraJacques ChuekeBruna Ferreira						Excluded	Excluded	new_screen			2						
459	Behave	Lean Software Development – What Exactly Are We Talking About?	http://link.springer.com/book/10.1007/978-3-030-76020-5		Oisín CawleyXiaofeng WangIta Richardson		http://link.springer.com/book/10.1007/978-3-030-76020-5				Excluded	Excluded	new_screen			2						
460	Behave	Logic, Computation and Rigorous Methods			Alexander RaschkeElvinia RiccobeneProf. Klaus-Dieter Schewe						Excluded	Excluded	new_screen			2						
461	Behave	Making It Better	As mentioned before, the term “Admin” in Salesforce is overloaded. It can refer to the traditional role of monitoring a production system to ensure it is stable and available to users, but it is just as likely to refer to a user who makes click-based changes to build or improve Salesforce. That latter role is better described as an “App Builder,” but that term hasn’t gotten much traction beyond being the name of a Salesforce certification. For example, the Admin Zone at Salesforce conferences or the Awesome Admin community online spends most of its energy explaining the click-based Builders and techniques for innovating on the platform without code.		Andrew Davis	Mastering Salesforce DevOps	https://doi.org/10.1007/978-1-4842-5473-8_12		pp 427–437		Excluded	Excluded	new_screen			2	SpringerLink		Making It Better	http://link.springer.com/chapter/10.1007/978-1-4842-5473-8_12	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
462	Behave	Marktsituation beim Softwaretest	Von den Hochschulen Bremen und Bremerhaven, der Technischen Hochschule Köln, der ANECON Software und Beratung GmbH, dem German Testing Board (GTB) und dem Swiss Testing Board wurden in den Jahren 2012 und 2016 anonyme Online-Umfragen zum Thema „Softwaretest in der Praxis“ durchgeführt. Damit sollte einerseits der aktuelle Stand von Qualität und Testaktivitäten in der Praxis, andererseits der Handlungsbedarf für Forschung, Ausbildung und Beratung im Testen analysiert werden.		Frank Witte	Testmanagement und Softwaretest	https://doi.org/10.1007/978-3-658-25087-4_6		pp 37–48		Excluded	Excluded	new_screen			2	SpringerLink		Measuring Test Case Similarity to Support Test Suite Understanding	http://link.springer.com/chapter/10.1007/978-3-658-25087-4_6	Springer Vieweg, Wiesbaden	nan; Keywords; References; Year; Bibtex
463	Behave	Measuring Test Case Similarity to Support Test Suite Understanding	In order to support test suite understanding, we investigate whether we can automatically derive relations between test cases. In particular, we search for trace-based similarities between (high-level) end-to-end tests on the one hand and fine grained unit tests on the other. Our approach uses the shared word count metric to determine similarity. We evaluate our approach in two case studies and show which relations between end-to-end and unit tests are found by our approach, and how this information can be used to support test suite understanding.	Conceptual Mapping; Test Suite; Unit Test; Execution Trace; Test Execution	Michaela Greiler,; Arie van Deursen&; Andy Zaidman	International Conference on Modelling Techniques and Tools for Computer Performance Evaluation	https://doi.org/10.1007/978-3-642-30561-0_8		pp 91–107		Excluded	Excluded	new_screen			2	SpringerLink		Meshing agile and plan-driven development in safety-critical software: a case study	http://link.springer.com/chapter/10.1007/978-3-642-30561-0_8	Springer, Berlin, Heidelberg	nan; References; Year; Bibtex
464	Behave	Microservices: The Evolution and Extinction of Web Services?	http://link.springer.com/article/10.1007/s10664-020-09804-z		Luciano BaresiMartin Garriga		http://link.springer.com/article/10.1007/s10664-020-09804-z				Excluded	Excluded	new_screen			2						
465	Behave	Microservices: Yesterday, Today, and Tomorrow	Microservices is an architectural style inspired by service-oriented computing that has recently started gaining popularity. Before presenting the current state of the art in the field, this chapter reviews the history of software architecture, the reasons that led to the diffusion of objects and services first, and microservices later. Finally, open problems and future challenges are introduced. This survey primarily addresses newcomers to the discipline, while offering an academic viewpoint on the topic. In addition, we investigate some practical issues and point out a few potential solutions.		Nicola Dragoni,; Saverio Giallorenzo,; Alberto Lluch Lafuente,; Manuel Mazzara,; Fabrizio Montesi,; Ruslan Mustafin&; Larisa Safina	Present and Ulterior Software Engineering	https://doi.org/10.1007/978-3-319-67425-4_12		pp 195–216		Excluded	Excluded	new_screen			2	SpringerLink		Microservices: Yesterday, Today, and Tomorrow	http://link.springer.com/chapter/10.1007/978-3-319-67425-4_12	Springer, Cham	nan; Keywords; References; Year; Bibtex
466	Behave	Migrating to Microservices			Alexis HenryYoussef Ridene						Excluded	Excluded	new_screen			2						
467	Behave	Layout and Image Recognition Driving Cross-Platform Automated Mobile Testing	The fragmentation problem has extended from Android to different platforms, such as iOS, mobile web, and even mini-programs within some applications (app), like WeChat1. In such a situation, recording and replaying test scripts is one of the most popular automated mobile app testing approaches. However, such approach encounters severe problems when crossing platforms. Different versions of the same app need to be developed to support different platforms relying on different platform supports. Therefore, mobile app developers need to develop and maintain test scripts for multiple platforms aimed at completely the same test requirements, greatly increasing testing costs. However, we discover that developers adopt highly similar user interface layouts for versions of the same app on different platforms. Such a phenomenon inspires us to replay test scripts from the perspective of similar UI layouts.In this paper, we propose an image-driven mobile app testing framework, utilizing Widget Feature Matching and Layout Characterization Matching to analyze app UIs. We use computer vision (CV) technologies to perform UI feature comparison and layout hierarchy extraction on mobile app screenshots to obtain UI structures containing rich contextual information of app widgets, including coordinates, relative relationship, etc. Based on acquired UI structures, we can form a platform-independent test script, and then locate the target widgets under test. Thus, the proposed framework non-intrusively replays test scripts according to a novel platform-independent test script model. We also design and implement a tool named LIRAT to devote the proposed framework into practice, based on which, we conduct an empirical study to evaluate the effectiveness and usability of the proposed testing framework. The results show that the overall replay accuracy reaches around 65.85\% on Android (8.74\% improvement over state-of-the-art approaches) and 35.26\% on iOS (35\% improvement over state-of-the-art approaches).	Record and Replay;  Mobile Testing;  Image Analysis;  Cross-Platform Testing	Yu, Shengcheng; Fang, Chunrong; Yun, Yexiao; Feng, Yang		https://doi.org/10.1109/ICSE43902.2021.00139		1561-1571	"@inproceedings{10.1109/ICSE43902.2021.00139,
    author = ""Yu, Shengcheng and Fang, Chunrong and Yun, Yexiao and Feng, Yang"",
    title = ""Layout and Image Recognition Driving Cross-Platform Automated Mobile Testing"",
    year = ""2021"",
    isbn = ""9781450390859"",
    publisher = ""IEEE Press"",
    url = ""https://doi.org/10.1109/ICSE43902.2021.00139"",
    doi = ""10.1109/ICSE43902.2021.00139"",
    abstract = ""The fragmentation problem has extended from Android to different platforms, such as iOS, mobile web, and even mini-programs within some applications (app), like WeChat1. In such a situation, recording and replaying test scripts is one of the most popular automated mobile app testing approaches. However, such approach encounters severe problems when crossing platforms. Different versions of the same app need to be developed to support different platforms relying on different platform supports. Therefore, mobile app developers need to develop and maintain test scripts for multiple platforms aimed at completely the same test requirements, greatly increasing testing costs. However, we discover that developers adopt highly similar user interface layouts for versions of the same app on different platforms. Such a phenomenon inspires us to replay test scripts from the perspective of similar UI layouts.In this paper, we propose an image-driven mobile app testing framework, utilizing Widget Feature Matching and Layout Characterization Matching to analyze app UIs. We use computer vision (CV) technologies to perform UI feature comparison and layout hierarchy extraction on mobile app screenshots to obtain UI structures containing rich contextual information of app widgets, including coordinates, relative relationship, etc. Based on acquired UI structures, we can form a platform-independent test script, and then locate the target widgets under test. Thus, the proposed framework non-intrusively replays test scripts according to a novel platform-independent test script model. We also design and implement a tool named LIRAT to devote the proposed framework into practice, based on which, we conduct an empirical study to evaluate the effectiveness and usability of the proposed testing framework. The results show that the overall replay accuracy reaches around 65.85\\% on Android (8.74\\% improvement over state-of-the-art approaches) and 35.26\\% on iOS (35\\% improvement over state-of-the-art approaches)."",
    booktitle = ""Proceedings of the 43rd International Conference on Software Engineering"",
    pages = ""1561-1571"",
    numpages = ""11"",
    keywords = ""Record and Replay, Mobile Testing, Image Analysis, Cross-Platform Testing"",
    location = ""Madrid, Spain"",
    series = ""ICSE '21""
}"	Excluded	Excluded	new_screen			2	ACM		Mobile Testing	http://link.springer.com/chapter/10.1007/978-1-4302-4039-6_13	IEEE Press	nan; Venue; References
468	Behave	Mock objects for testing java systems	http://link.springer.com/article/10.1007/s10664-018-9663-0		Davide SpadiniMaurício AnicheMagiel BruntinkAlberto Bacchelli		http://link.springer.com/article/10.1007/s10664-018-9663-0				Excluded	Excluded	new_screen			2						
469	Behave	Modeling and Analyzing Using ASMs: The Landing Gear System Case Study	The paper presents an Abstract State Machine (ASM) specification of the Landing Gear System case study, and shows how the ASMETA framework can be used to support the modeling and analysis (validation and verification) activities for developing a rigorous and correct model in terms of ASMs. We exploit the two fundamental concepts of the ASM method, i.e., the notion of ground model and the refinement principle, and we achieve model development and model analysis by the combined use of formal methods for specification and for verification.		Paolo Arcaini,; Angelo Gargantini&; Elvinia Riccobene	International Conference on Abstract State Machines, Alloy, B, TLA, VDM, and Z	https://doi.org/10.1007/978-3-319-07512-9_3		pp 36–51		Excluded	Excluded	new_screen			2	SpringerLink		Modeling and Analyzing Using ASMs: The Landing Gear System Case Study	http://link.springer.com/chapter/10.1007/978-3-319-07512-9_3	Springer, Cham	nan; Keywords; References; Year; Bibtex
470	Behave	Nachhaltige Unternehmensführung im Zeitalter der Digitalisierung – neue Corporate Governance	Die Herausforderung an eine nachhaltige Unternehmensführung im digitalen Zeitalter wird anhand vielfältiger Beispiele abgeleitet. Durch die Beschleunigung der Entscheidungsprozesse wächst die strategische Lücke, denn eine hoher Wahrnehmungsschwelle engt den unternehmerischen Handlungsspielraum stark ein. Ferner kann die Digitalisierung dazu führen, dass die Grenzen von Legitimität und Legalität verschwimmen, vielfältige Compliance-Verstöße sind ohne einen stabilen „moralische Kompass“ wahrscheinlicher, wie sie im Compliance on Board Index und dem Compliance-Radar bereits sichtbar werden. Zur nachhaltigen Unternehmensführung wird das Konzept von Transparenz, Fehlerkultur und Offenheit – kurz „Candorship“ – erläutert, welches in „lean-agilen“ Organisationsformen grundsätzlich umsetzbar scheint. Der Beitrag erläutert, wie dieses Candorship-Prinzip durch eine lean-agile Ausrichtung schnelles Lernen und Anpassungen durch dezentrale, operative Entscheidungskompetenz innerhalb eigenverantwortlicher agiler Teams einerseits, und ein dienenden Führungsverständnis auf Managementebene („Servant Leadership“) andererseits realisiert werden kann. Am Beispiel des weltweit führenden Ansatzes „Scaled Agile Frameworks“ (SAFe®), einem ganzheitlichen, offenen Rahmenwerk aus aufeinander abgestimmter Grundwerte, Prinzipien und Best Practices, wird das Potenzial konkretisiert: Dieser holistische Ansatz bietet bei konsequenter Umsetzung die notwendige Authentizität, Offenheit und Fehlerkultur, die Candorship ermöglicht. Die strategische Lücke kann so verringert und nachhaltige Handlungsoptionen erschlossen werden. Unter gleichzeitiger Stärkung des „moralischen Kompasses“ kann so nachhaltige Unternehmensführung im digitalen Zeitalter gesichert werden.		Stefan Vieweg	Integrierte nachhaltige Unternehmensführung	https://doi.org/10.1007/978-3-662-61168-5_10		pp 177–196		Excluded	Excluded	new_screen			2	SpringerLink		Modeling in Agile Software Development: Decomposing Use Cases Towards Logical Architecture Design	http://link.springer.com/chapter/10.1007/978-3-662-61168-5_10	Springer Gabler, Berlin, Heidelberg	nan; Keywords; References; Year; Bibtex
471	Behave	Modeling Software Requirements	http://link.springer.com/book/10.1007/978-3-662-56386-1		Themistoklis DiamantopoulosAndreas L. Symeonidis		http://link.springer.com/book/10.1007/978-3-662-56386-1				Excluded	Excluded	new_screen			2						
472	Behave	Node Modules	A typical MEAN application can often depend on up to hundreds of packages. These modules are often small and consist of both Node.js and Bower libraries. By combining libraries, you are able to create a mashup of small-shared building blocks and custom apps for the purpose of solving a larger problem.	Version Option; Command Line; Open Source Project; Node Module; Test Drive Development	Elad Elrom	Pro MEAN Stack Development	https://doi.org/10.1007/978-1-4842-2044-3_3		pp 51–73		Excluded	Excluded	new_screen			2	SpringerLink		NLP-Assisted Model Generation	http://link.springer.com/chapter/10.1007/978-1-4842-2044-3_3	Apress, Berkeley, CA	nan; References; Year; Bibtex
473	Behave	Normen, Standards, Practices	Die folgenden Unterkapitel geben einen kurzen Abriss einiger Normen, Standards und Practices, die in Bezug zum Sicherheits-, Kontinuitäts- und Risikomanagement stehen. Hierzu gehören die Standards und das IT-Grundschutz-Kompendium des BSI, die ISO/IEC-27000-Familie zur Informationssicherheit, die ISO/IEC 20000 sowie ITIL®und COBIT®. Der Abriss ermöglicht zum einen den überblicksartigen Vergleich des Vorgehensmodells und der Inhalte der Sicherheitspyramide mit Normen, Standards und Practices sowie zum anderen verschiedentlich die Herstellung von Bezügen von der Sicherheitspyramide auf Normen, Standards und Practices und das Aufzeigen von Entwicklungen.		Klaus-Rainer Müller	IT-Sicherheit mit System	https://doi.org/10.1007/978-3-658-22065-5_5		pp 90–196		Excluded	Excluded	new_screen			2	SpringerLink		Node Modules	http://link.springer.com/chapter/10.1007/978-3-658-22065-5_5	Springer Vieweg, Wiesbaden	nan; Keywords; References; Year; Bibtex
474	Behave	On the Understanding of BDD Scenarios’ Quality: Preliminary Practitioners’ Opinions	[Context & Motivation]In agile development, acceptance tests are written to express the details from the conversations between customers and developers. One of the formats to express those details is BDD (Behavior-Driven Development) scenarios, which use a ubiquitous language, one that business and technical people can understand, to build an executable specification that represents a system behavior.[Question/Problem]Problems caused by bad documentation are known to cause project failure and we believe those problems apply to documentation in the format of acceptance tests as well. Thus, in the long-term, we seek to understand what would be the definition of a good BDD scenario and the criteria to define it.[Principal idea/results]To achieve that, we previously identified known requirements’ quality attributes that would be suitable to evaluate BDD scenarios’ quality. Based on that list of attributes, we now aim to validate that list with practitioners, identify their interpretation of the listed attributes, and uncover general recommendations to write BDD scenarios.[Contribution]Preliminary results from our initial set of interviews revealed practitioners’ interpretations for consistent, testable, valuable, understandable, and unambiguous attributes and some recommendations to write good BDD scenarios, such as the use of declarative form of writing.	Documentation quality; Documentation evaluation; Behavior-Driven Development; Empirical study	Gabriel Oliveira&; Sabrina Marczak	International Working Conference on Requirements Engineering: Foundation for Software Quality	https://doi.org/10.1007/978-3-319-77243-1_18		pp 290–296		Excluded	Excluded	new_screen			2	SpringerLink		Normen, Standards, Practices	http://link.springer.com/chapter/10.1007/978-3-319-77243-1_18	Springer, Cham	nan; References; Year; Bibtex
475	Behave	Onstage Product Owner	Writing user stories, refine stories, administerting the backlog, prioritiser in chief, work with the team, 3 Amigos, testing, estimating - these are a few of the more visable things Product Owners do.		Allan Kelly	The Art of Agile Product Ownership	https://doi.org/10.1007/978-1-4842-5168-3_8		pp 57–61		Excluded	Excluded	new_screen			2	SpringerLink		Onstage Product Owner	http://link.springer.com/chapter/10.1007/978-1-4842-5168-3_8	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
476	Behave	Open Debates	Technology has fundamentally changed how we communicate with each other. New tools and platforms allow us to share our stories more vibrantly than ever before. In this chapter, we focus on a cornerstone of discourse: debates. We build a Jekyll-based debate platform that can leverage the full capabilities of GitHub to host open debates. We begin with an introduction to the debate platform and the rules of an Oxford-style debate. After that, we provide an in-depth overview of GitHub and all of its features, including some features of GitHub Pages that we have not yet had a chance to cover. We then create a prototype based on the rules to help us find a theme. When we have found a suitable theme and understood the requirements for this project, we can start editing the theme to obtain our final debate platform. Finally, we end this chapter with a discussion of how our platform can take advantage of the open standards and use them in conducting the debates.	Home Page; Current Debate; Project Site; Organization Site; Domain Name System	Vikram Dhillon	Creating Blogs with Jekyll	https://doi.org/10.1007/978-1-4842-1464-0_10		pp 163–193		Excluded	Excluded	new_screen			2	SpringerLink		Open Debates	http://link.springer.com/chapter/10.1007/978-1-4842-1464-0_10	Apress, Berkeley, CA	nan; References; Year; Bibtex
477	Behave	Organization of the Software Test in Agile Projects	This chapter examines multiple approaches, all of which have proven to be useful models in the respective project environment. Thus, the applicability of the traditional test process according to ISTQB in the agile context is considered and the Four Test Quadrants in Agile Testing are discussed. Another important topic for agile companies is scaling - therefore the approaches LeSS and SAFe are briefly presented. Additionally, case studies are outlined to illustrate what an agile test organization can look like.		Manfred Baumgartner,; Martin Klonk,; Christian Mastnak,; Helmut Pichler,; Richard Seidl&; Siegfried Tanczos	Agile Testing	https://doi.org/10.1007/978-3-030-73209-7_3		pp 37–77		Excluded	Excluded	new_screen			2	SpringerLink		Organization of the Software Test in Agile Projects	http://link.springer.com/chapter/10.1007/978-3-030-73209-7_3	Springer, Cham	nan; Keywords; References; Year; Bibtex
478	Behave	Patterns – Wie geht es weiter?	In diesem Kapitel möchten wir Ihnen einige andere Bereiche vorstellen, in denen Sie Wissen und Erfahrungen über Patterns veröffentlicht finden können. In diesem Sinne verstehen Sie es bitte als eine Art kommentierte Literaturliste, die Ihnen als Anregung dienen soll.		Karl EilebrechtnAff&; Gernot StarkenAff	Patterns kompakt	https://doi.org/10.1007/978-3-642-34718-4_11		pp 205–211		Excluded	Excluded	new_screen			2	SpringerLink		Patterns – Wie geht es weiter?	http://link.springer.com/chapter/10.1007/978-3-642-34718-4_11	Springer Vieweg, Berlin, Heidelberg	nan; Keywords; References; Year; Bibtex
479	Behave	People and Tools	As a consultant, most customers that call me to help them start working with test automation start with the questions: “Which tools are there?” and “which tools should I use”? If you’re in that situation yourself, then you’re probably asking this question too. The short answer to the first question is that there are a bazillion tools out there for test automation. Oh, and there’s Selenium, too, of course, so there are bazillion and one. And the short answer to the second question is the classical consultant’s answer: “It depends.”		Arnon Axelrod	Complete Guide to Test Automation	https://doi.org/10.1007/978-1-4842-3832-5_3		pp 31–61		Excluded	Excluded	new_screen			2	SpringerLink		People and Tools	http://link.springer.com/chapter/10.1007/978-1-4842-3832-5_3	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
480	Behave	Planning Your Work	Developers who are just starting out often believe that their job is to build what they’re told to build by their managers or clients. The more experienced a developer becomes, the more they realize that building the right thing is more important than building the thing right. Effectively planning your work before you do it increases your effectiveness, as it ensures you properly understand the problem you’re trying to solve.		Chris Northwood	The Full Stack Developer	https://doi.org/10.1007/978-1-4842-4152-3_2		pp 11–46		Excluded	Excluded	new_screen			2	SpringerLink		Planning Your Work	http://link.springer.com/chapter/10.1007/978-1-4842-4152-3_2	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
481	Behave	Polytrix: A Pacto-Powered Polyglot Test Matrix	We have created a polyglot test framework named Polytrix to compare, benchmark, and independently verify a suite of open-source OpenStack SDKs that each target a different programming language. The framework validates sample code from each SDK against a shared test scenario to validate that each SDK correctly implements a given scenario. It uses Pacto for integration contract testing between the SDKs and the OpenStack services, and generates test reports that help compare and document each SDK. It is designed so interactive training materials can be generated in future versions.	Public Cloud; Sample Code; Private Cloud; Literate Program; Test Code	Max Lincoln&; Fernando Alves	IFIP International Conference on Open Source Systems	https://doi.org/10.1007/978-3-642-55128-4_27		pp 191–194		Excluded	Excluded	new_screen			2	SpringerLink		Polytrix: A Pacto-Powered Polyglot Test Matrix	http://link.springer.com/chapter/10.1007/978-3-642-55128-4_27	Springer, Berlin, Heidelberg	nan; References; Year; Bibtex
482	Behave	Poor Foundations	What can be done early on to set your teams up for success? What kinds of things are worth investing time in and how much do you try to solve for not knowing exactly what is needed in the long run? Furthermore, how do you front load a project with all the foundational-type work (think continuous integration, frameworks, etc.) that will make the rest of the project go smoothly? Once you think you know what those things are, how do you convince management that this upfront cost will pay off in the long run? One thing is fairly certain: if you don’t invest in a solid foundation your Agile project will pay for it in the long run.		Tim Brizard	Broken Agile	https://doi.org/10.1007/978-1-4842-1745-0_4		pp 15–18		Excluded	Excluded	new_screen			2	SpringerLink		Poor Foundations	http://link.springer.com/chapter/10.1007/978-1-4842-1745-0_4	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
483	Behave	PowerShell-Skripte testen mit Pester	Je umfangreicher ein Skript wird, desto höher ist die Wahrscheinlichkeit, dass irgendetwas nicht so ausgeführt wird, wie es sich der Autor des Skriptes vorgestellt hat. Das gilt vor allem, wenn es mehrere Autoren gibt, die in zeitlich versetzten Abständen irgendwelche Änderungen vornehmen. An diesem Punkt muss eine wichtige Entscheidung getroffen werden. Soll das Skript wie bisher weiterentwickelt und gepflegt werden? Oder sollen Methoden eingeführt werden, wie sie auch in der Software-Entwicklung üblich sind? Das bedeutet vor allem zwei Dinge: Eine Versionsverwaltung und das Testen einzelner Funktionalitäten mit Hilfe eines dafür vorgesehenen Werkzeugs. Das Thema Versionsverwaltung ist in Kap.7an der Reihe, das Thema Testen mit Hilfe des Pester-Moduls wird in diesem Kapitel vorgestellt. Pester ist ein Modul, das bei Windows Server 2016 und Windows 10 von Anfang an dabei ist. Es enthält eine Reihe von Functions, mit deren Hilfe sich Skripte, DSC-Ressourcen, Server-Konfigurationen und alles das, was per Befehlszeile abfragbar ist, automatisiert testen lassen. Das Besondere an den Functions ist, dass ihre Namen so gewählt wurden, dass sie an ein in der Software-Entwicklung übliches Testverfahren orientieren.		Peter Monadjemi	Windows Server-Administration mit PowerShell 5.1	https://doi.org/10.1007/978-3-658-17666-2_6		pp 87–98		Excluded	Excluded	new_screen			2	SpringerLink		PowerShell-Skripte testen mit Pester	http://link.springer.com/chapter/10.1007/978-3-658-17666-2_6	Springer Vieweg, Wiesbaden	nan; Keywords; References; Year; Bibtex
484	Behave	Preparing the Project	In the early days of agile, agilists wanted to avoid all upfront work before the iterations of requirements, coding, and testing started: no architecture, no initial requirements, not even getting their development environment set up. (The emergent design fans still use this approach.) I think this is an overreaction to the waterfall method. The pendulum of popular development style swung from too-much-upfront work to no-upfront work. Fortunately, that pendulum is swinging back to some upfront work that some agilists call upfront learning.		Alan Cline	Agile Development in the Real World	https://doi.org/10.1007/978-1-4842-1679-8_4		pp 75–90		Excluded	Excluded	new_screen			2	SpringerLink		Preparing the Project	http://link.springer.com/chapter/10.1007/978-1-4842-1679-8_4	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
485	Behave	Reducing Barriers to Entry by Removing Prerequisites for a CS1 Introductory Programming Course	Introductory programming has evolved in many places to become a CS0 course, enabling students to get their feet wet with programming without completing significant math coursework. A scan of CS programs shows that a majority of CS1 programming courses that count towards an undergraduate CS degree continue to have a math or CS0 prerequisite. This experience report discusses the impact of removing the math prerequisite at an R2 university and a small liberal arts college. Having minimal prerequisites has beneficial effects in terms of diversifying the CS student body as well as enabling students to begin CS coursework early, often in the first semester, potentially impacting persistence, but also enabling students to decide, early, if CS is right for them. The high success rate of students of various backgrounds taking CS certificates and pursuing graduate school also shows that aggressive prerequisites in the past may have been functioning as barriers to entering CS programs. If we are serious about supporting diversity, we need to acknowledge the wide disparity in high school education nationwide and that prerequisites are perhaps functioning as a needless barrier. Where the CS0 course doesn't count towards a degree, or there isn't space for that requirement in the program, it is also worth considering whether the CS0 prerequisite is necessary.	Barrier Reduction;  Broadening Participation in Computing (BPC);  CS1;  Diversity;  Intro Programming	Das, Udayan; Fulton, Chris		https://doi.org/10.1145/3626253.3635492		1616-1617	"@inproceedings{10.1145/3626253.3635492,
    author = ""Das, Udayan and Fulton, Chris"",
    title = ""Reducing Barriers to Entry by Removing Prerequisites for a CS1 Introductory Programming Course"",
    year = ""2024"",
    isbn = ""9798400704246"",
    publisher = ""Association for Computing Machinery"",
    address = ""New York, NY, USA"",
    url = ""https://doi.org/10.1145/3626253.3635492"",
    doi = ""10.1145/3626253.3635492"",
    abstract = ""Introductory programming has evolved in many places to become a CS0 course, enabling students to get their feet wet with programming without completing significant math coursework. A scan of CS programs shows that a majority of CS1 programming courses that count towards an undergraduate CS degree continue to have a math or CS0 prerequisite. This experience report discusses the impact of removing the math prerequisite at an R2 university and a small liberal arts college. Having minimal prerequisites has beneficial effects in terms of diversifying the CS student body as well as enabling students to begin CS coursework early, often in the first semester, potentially impacting persistence, but also enabling students to decide, early, if CS is right for them. The high success rate of students of various backgrounds taking CS certificates and pursuing graduate school also shows that aggressive prerequisites in the past may have been functioning as barriers to entering CS programs. If we are serious about supporting diversity, we need to acknowledge the wide disparity in high school education nationwide and that prerequisites are perhaps functioning as a needless barrier. Where the CS0 course doesn't count towards a degree, or there isn't space for that requirement in the program, it is also worth considering whether the CS0 prerequisite is necessary."",
    booktitle = ""Proceedings of the 55th ACM Technical Symposium on Computer Science Education V. 2"",
    pages = ""1616-1617"",
    numpages = ""2"",
    keywords = ""Barrier Reduction, Broadening Participation in Computing (BPC), CS1, Diversity, Intro Programming"",
    location = ""Portland, OR, USA"",
    series = ""SIGCSE 2024""
}"	Excluded	Excluded	new_screen			2	ACM		Prerequisites	http://link.springer.com/chapter/10.1007/978-1-4302-2887-5_3	Association for Computing Machinery	nan; Venue; References
486	Behave	Prioritization of User Story Acceptance Tests in Agile Software Development Using Meta-Heuristic Techniques and Comparative Analysis	User stories that are the requirements engineering artifacts in agile software development must be accepted by the end user before being implemented. Acceptance testing is used to confirm the acceptance of user stories. User story acceptance tests are driven by user-defined acceptance criteria. The number of acceptance tests increases as the application size increases. One of the prominent reasons for adopting agile software development is quicker delivery of working software. In this paper, we attempt to prioritize acceptance tests in order to identify critical tests. Execution of critical acceptance tests is sufficient to satisfy the acceptance criteria for a user story and reduces the time to delivery of software. Prioritization of acceptance tests is realized by application of meta-heuristic techniques, i.e., genetic algorithm (GA), cuckoo search algorithm, and micro-GA algorithm. The information flow (IF) model is used as a basis of fitness function to ensure maximum coverage of user acceptance criteria. We demonstrate the applicability and effectiveness of the proposed approach with the help of a realistic example. A comparative analysis of the application of meta-heuristic techniques is performed to choose the best one.	Agile software development; Acceptance testing; Genetic algorithm; Cuckoo search; Micro-GA	Ritu Sibal,; Preeti Kaur&; Chayanika Sharma	Towards Extensible and Adaptable Methods in Computing	https://doi.org/10.1007/978-981-13-2348-5_4		pp 43–55		Excluded	Excluded	new_screen			2	SpringerLink		Prioritization of User Story Acceptance Tests in Agile Software Development Using Meta-Heuristic Techniques and Comparative Analysis	http://link.springer.com/chapter/10.1007/978-981-13-2348-5_4	Springer, Singapore	nan; References; Year; Bibtex
487	Behave	A tentative framework for connecting long-term business and product planning with iterative \&amp; incremental software product development	"For a company in the software product business, it is essential to understand how to connect business management and software development [17] and employ a solid, value-based approach in its decision-making. However, software engineering literature (SE) commonly addresses what should be done at the ""floor level"" and leaves the link to business and product management unaddressed [14]. Also, existing software development models mostly adhere to the viewpoint of individual development projects and thus fail to sufficiently address common product development concerns such as multi-project or project portfolio management [20]."		"V\""{a}h\""{a}niitty, Jarno"		https://doi.org/10.1145/1083091.1083097		1-4	"@inproceedings{10.1145/1083091.1083097,
    author = {V\""{a}h\""{a}niitty, Jarno},
    title = ""A tentative framework for connecting long-term business and product planning with iterative \\&amp; incremental software product development"",
    year = ""2005"",
    isbn = ""159593118X"",
    publisher = ""Association for Computing Machinery"",
    address = ""New York, NY, USA"",
    url = ""https://doi.org/10.1145/1083091.1083097"",
    doi = ""10.1145/1083091.1083097"",
    abstract = {For a company in the software product business, it is essential to understand how to connect business management and software development [17] and employ a solid, value-based approach in its decision-making. However, software engineering literature (SE) commonly addresses what should be done at the ""floor level"" and leaves the link to business and product management unaddressed [14]. Also, existing software development models mostly adhere to the viewpoint of individual development projects and thus fail to sufficiently address common product development concerns such as multi-project or project portfolio management [20].},
    booktitle = ""Proceedings of the Seventh International Workshop on Economics-Driven Software Engineering Research"",
    pages = ""1-4"",
    numpages = ""4"",
    location = ""St. Louis, Missouri"",
    series = ""EDSER '05""
}

@article{10.1145/1082983.1083097,
    author = {V\""{a}h\""{a}niitty, Jarno},
    title = ""A tentative framework for connecting long-term business and product planning with iterative \\&amp; incremental software product development"",
    year = ""2005"",
    issue_date = ""July 2005"",
    publisher = ""Association for Computing Machinery"",
    address = ""New York, NY, USA"",
    volume = ""30"",
    number = ""4"",
    issn = ""0163-5948"",
    url = ""https://doi.org/10.1145/1082983.1083097"",
    doi = ""10.1145/1082983.1083097"",
    abstract = {For a company in the software product business, it is essential to understand how to connect business management and software development [17] and employ a solid, value-based approach in its decision-making. However, software engineering literature (SE) commonly addresses what should be done at the ""floor level"" and leaves the link to business and product management unaddressed [14]. Also, existing software development models mostly adhere to the viewpoint of individual development projects and thus fail to sufficiently address common product development concerns such as multi-project or project portfolio management [20].},
    journal = ""SIGSOFT Softw. Eng. Notes"",
    month = ""may"",
    pages = ""1-4"",
    numpages = ""4""
}"	Excluded	Excluded	new_screen			2	ACM		Product Planning	http://link.springer.com/chapter/10.1007/978-3-642-55140-6_4	Association for Computing Machinery	nan; Venue; Keywords; References
488	Behave	Program comprehension of domain-specific and general-purpose languages: replication of a family of experiments using integrated development environments	Domain-specific languages (DSLs) allow developers to write code at a higher level of abstraction compared with general-purpose languages (GPLs). Developers often use DSLs to reduce the complexity of GPLs. Our previous study found that developers performed program comprehension tasks more accurately and efficiently with DSLs than with corresponding APIs in GPLs. This study replicates our previous study to validate and extend the results when developers use IDEs to perform program comprehension tasks. We performed a dependent replication of a family of experiments. We made two specific changes to the original study: (1) participants used IDEs to perform the program comprehension tasks, to address a threat to validity in the original experiment and (2) each participant performed program comprehension tasks on either DSLs or GPLs, not both as in the original experiment. The results of the replication are consistent with and expanded the results of the original study. Developers are significantly more effective and efficient in tool-based program comprehension when using a DSL than when using a corresponding API in a GPL. The results indicate that, where a DSL is available, developers will perform program comprehension better using the DSL than when using the corresponding API in a GPL. (c) 2018, Springer Science+Business Media, LLC, part of Springer Nature.	Problem oriented languages; Controlled experiment; Domain specific languages; General purpose languages; Program comprehension; Replication; Digital subscriber lines	Kosar, Tomaz; Gaberc, Saso; Carver, Jeffrey C.; Mernik, Marjan	Empirical Software Engineering	https://doi.org/10.1007/s10664-017-9593-2		2734 - 2763	"@ARTICLE{Kosar20182734,
    author = ""Kosar, Tomaz and Gaberc, Saso and Carver, Jeffrey C. and Mernik, Marjan"",
    title = ""Program comprehension of domain-specific and general-purpose languages: replication of a family of experiments using integrated development environments"",
    year = ""2018"",
    journal = ""Empirical Software Engineering"",
    volume = ""23"",
    number = ""5"",
    pages = ""2734 - 2763"",
    doi = ""10.1007/s10664-017-9593-2"",
    url = ""https://www.scopus.com/inward/record.uri?eid=2-s2.0-85041817185\&doi=10.1007\%2fs10664-017-9593-2\&partnerID=40\&md5=08584b57449331c4801a21d3a4bc386c"",
    affiliations = ""Faculty of Electrical Engineering and Computer Science, University of Maribor, Koroska cesta 46, Maribor, 2000, Slovenia; Department of Computer Science, University of Alabama, Tuscaloosa, AL, United States"",
    abstract = ""Domain-specific languages (DSLs) allow developers to write code at a higher level of abstraction compared with general-purpose languages (GPLs). Developers often use DSLs to reduce the complexity of GPLs. Our previous study found that developers performed program comprehension tasks more accurately and efficiently with DSLs than with corresponding APIs in GPLs. This study replicates our previous study to validate and extend the results when developers use IDEs to perform program comprehension tasks. We performed a dependent replication of a family of experiments. We made two specific changes to the original study: (1) participants used IDEs to perform the program comprehension tasks, to address a threat to validity in the original experiment and (2) each participant performed program comprehension tasks on either DSLs or GPLs, not both as in the original experiment. The results of the replication are consistent with and expanded the results of the original study. Developers are significantly more effective and efficient in tool-based program comprehension when using a DSL than when using a corresponding API in a GPL. The results indicate that, where a DSL is available, developers will perform program comprehension better using the DSL than when using the corresponding API in a GPL. (c) 2018, Springer Science+Business Media, LLC, part of Springer Nature."",
    author_keywords = ""Controlled experiment; Domain-specific languages; General-purpose languages; Program comprehension; Replication"",
    keywords = ""Problem oriented languages; Controlled experiment; Domain specific languages; General purpose languages; Program comprehension; Replication; Digital subscriber lines"",
    correspondence_address = ""T. Kosar; Faculty of Electrical Engineering and Computer Science, University of Maribor, Maribor, Koroska cesta 46, 2000, Slovenia; email: tomaz.kosar@um.si"",
    publisher = ""Springer New York LLC"",
    issn = ""13823256"",
    coden = ""ESENF"",
    language = ""English"",
    abbrev_source_title = ""Empir Software Eng"",
    type = ""Article"",
    publication_stage = ""Final"",
    source = ""Scopus"",
    note = ""Cited by: 28""
}"	Excluded	Excluded	new_screen			2	ScopusSignedIn		Program comprehension of domain-specific and general-purpose languages: replication of a family of experiments using integrated development environments	https://link.springer.com/article/10.1007/s10664-017-9593-2	Springer New York LLC	nan; References
489	Behave	PTCWA: Performance Testing of Cloud Based Web Applications	Testing in a cloud environment involves a range of tests to analyze various aspects of the system in various cloud adoption scenarios such as public, private, or hybrid. Performance testing is a key aspect of the cloud testing strategy and it evaluates the application/software for various issues such as speed, stability, and scalability under varying load conditions. The key issues that must be considered in a cloud set-up as a part of the performance testing strategy are collection of statistics on the load, conducting stress test, monitoring the memory, checking for elasticity and scalability. This paper focuses on testing the resource utilization in cloud infrastructure in general and memory utilization in particular. The memory utilization is evaluated in public and private cloud environment with simulation of 10 users to 10,000 users.	Performance testing; Public cloud; Private cloud; Memory and CPU utilization	M. S. Geetha Devasena,; R. Kingsy Grace,; S. Manju&; V. Krishna Kumar	New Trends in Computational Vision and Bio-inspired Computing	https://doi.org/10.1007/978-3-030-41862-5_32		pp 345–356		Excluded	Excluded	new_screen			2	SpringerLink		PTCWA: Performance Testing of Cloud Based Web Applications	http://link.springer.com/chapter/10.1007/978-3-030-41862-5_32	Springer, Cham	nan; References; Year; Bibtex
490	Behave	Public Administration for the Next Generation	Public Administration incorporates the development of statutes and regulations to bring order and control to aspects of society. In democratic societies this is accompanied by gathering opinion from the population on the span and degree of this control and on some of the details. This essay explores ways in which developments in digital technologies can facilitate this process, aid policymakers in ensuring consistency of regulations, and streamline the process between regulation and software in situations where this is relevant and helpful. It looks forward to what the coming generation of citizens might expect from their public administrators.		Peter Winstanley	Government 3.0 – Next Generation Government Technology Infrastructure and Services	https://doi.org/10.1007/978-3-319-63743-3_2		pp 27–36		Excluded	Excluded	new_screen			2	SpringerLink		Public Administration for the Next Generation	http://link.springer.com/chapter/10.1007/978-3-319-63743-3_2	Springer, Cham	nan; Keywords; References; Year; Bibtex
491	Behave	Putting ASP.NET MVC in Context			Adam Freeman						Excluded	Excluded	new_screen			2						
492	Behave	QTREDS: a Ruby on Rails-based platform for omics laboratories			Piergiorgio PallaGianfranco FrauLaura VargiuPatricia Rodriguez-Tomé						Excluded	Excluded	new_screen			2						
493	Behave	Quality and Testing			Andrew Davis						Excluded	Excluded	new_screen			2						
494	Behave	Reengineering and Reverse Engineering			Ervin Varga						Excluded	Excluded	new_screen			2						
495	Behave	Exploiting the progress of OO refactoring tools with Android code smells: RAndroid, a plugin for Android studio	"Mobile applications market is facing a stronger demand continuously, due to the growing popularity of mobile phones. A demand that forces developers to rush the implementation process and shorten the conception phase, leading to poor conception and implementation choices known as code smells. These smells have a negative effect on both device and application's performance, and must therefore be corrected to ensure the quality of mobile applications and the smoothness of their users' experience. This task requires the identification of the infected entities and their refactoring. Most existing refactoring approaches and techniques are focused on object-oriented applications' code smells while only a few of them are destined to Android specific code smells.In this paper, we present a tool, named RAndroid, that handles automatic refactoring for four different Android specific code smells, and gives recommendations on how to manually refactor a fifth one. RAndroid is built as an Android Studio plugin adapting the logic of the well-known oriented-object refactoring tool ""JDeodorant"" [13] as it's first layer. We evaluated RAndroid on 52 real-world open-source Android applications, developed by both experts and beginners, covering 194 code smell instances."	refactoring;  mobile application;  code smells;  Java;  Android	Gattal, Abderraouf; Hammache, Abir; Bousbia, Nabila; Henniche, Adel Nassim		https://doi.org/10.1145/3412841.3442129		1580-1583	"@inproceedings{10.1145/3412841.3442129,
    author = ""Gattal, Abderraouf and Hammache, Abir and Bousbia, Nabila and Henniche, Adel Nassim"",
    title = ""Exploiting the progress of OO refactoring tools with Android code smells: RAndroid, a plugin for Android studio"",
    year = ""2021"",
    isbn = ""9781450381048"",
    publisher = ""Association for Computing Machinery"",
    address = ""New York, NY, USA"",
    url = ""https://doi.org/10.1145/3412841.3442129"",
    doi = ""10.1145/3412841.3442129"",
    abstract = {Mobile applications market is facing a stronger demand continuously, due to the growing popularity of mobile phones. A demand that forces developers to rush the implementation process and shorten the conception phase, leading to poor conception and implementation choices known as code smells. These smells have a negative effect on both device and application's performance, and must therefore be corrected to ensure the quality of mobile applications and the smoothness of their users' experience. This task requires the identification of the infected entities and their refactoring. Most existing refactoring approaches and techniques are focused on object-oriented applications' code smells while only a few of them are destined to Android specific code smells.In this paper, we present a tool, named RAndroid, that handles automatic refactoring for four different Android specific code smells, and gives recommendations on how to manually refactor a fifth one. RAndroid is built as an Android Studio plugin adapting the logic of the well-known oriented-object refactoring tool ""JDeodorant"" [13] as it's first layer. We evaluated RAndroid on 52 real-world open-source Android applications, developed by both experts and beginners, covering 194 code smell instances.},
    booktitle = ""Proceedings of the 36th Annual ACM Symposium on Applied Computing"",
    pages = ""1580-1583"",
    numpages = ""4"",
    keywords = ""refactoring, mobile application, code smells, Java, Android"",
    location = ""Virtual Event, Republic of Korea"",
    series = ""SAC '21""
}"	Excluded	Excluded	new_screen			2	ACM		Refactoring Tools	http://link.springer.com/chapter/10.1007/978-1-4302-2728-1_6	Association for Computing Machinery	nan; Venue; References
496	Behave	Requirement Engineering as a Software Development Process	The paper introduces a novel requirements management tool, incorporating software development practices into requirements engineering. It is motivated by an expectation that using well-established techniques should provide benefits such as increase of requirements quality, better alignment of tooling to organization needs and support for Agile project management techniques. Our aim, therefore, is to provide an open architecture for various requirements engineering activities, as till now, many of existing requirements management tools do not follow the latest developments in software development practices. In this paper, we propose a mapping of various aspects of software development based on Continuous Integration to requirements engineering and describe a prototype requirements management tool built to validate the proposed concept.		Pawel Baszuro&; Jakub Swacha	Data-Centric Business and Applications	https://doi.org/10.1007/978-3-030-34706-2_2		pp 21–39		Excluded	Excluded	new_screen			2	SpringerLink		Requirement Engineering as a Software Development Process	http://link.springer.com/chapter/10.1007/978-3-030-34706-2_2	Springer, Cham	nan; Keywords; References; Year; Bibtex
497	Behave	Requirements Engineering and Semantic Web*	http://link.springer.com/article/10.1007/s10559-016-9808-3		L. P. Babenko		http://link.springer.com/article/10.1007/s10559-016-9808-3				Excluded	Excluded	new_screen			2						
498	Behave	Requirements Engineering for Cyber-Physical Systems	According to a widely shared view, manufacturing is currently un- dergoing its fourth industrial revolution, termed “Industrie 4.0” in the high-tech strategy of the German government. Smart Factories with vertically and hori- zontally integrated production systems are enabled through the realization of machines, storage systems and utilities as Cyber-Physical Systems (CPS), which are able to share information, act, and control each other autonomously. The development of CPS requires the collaboration of different disciplines, like mechanical engineering, electrical engineering and computer science. This cre- ates new challenges for Requirements Engineering (RE), which needs to estab- lish a common perception of the targeted CPS for the involved stakeholders. This paper will elaborate the specific challenges in RE for CPS based on a lit- erature review. Natural Language Processing (NLP) is used as an approach to automatically translate shared informal requirements specifications to formal domain specific models for the involved disciplines, to develop a comprehen- sive RE methodology for CPS.	Requirements Engineering; Industrie 4.0; Cyber-Physical Systems; Natural Language Processing; MSEE Integrated Project	Stefan Wiesner,; Christian Gorldt,; Mathias Soeken,,; Klaus-Dieter Thoben,&; Rolf Drechsler,	IFIP International Conference on Advances in Production Management Systems	https://doi.org/10.1007/978-3-662-44739-0_35		pp 281–288		Excluded	Excluded	new_screen			2	SpringerLink		Requirements Engineering for Cyber-Physical Systems	http://link.springer.com/chapter/10.1007/978-3-662-44739-0_35	Springer, Berlin, Heidelberg	nan; References; Year; Bibtex
499	Behave	Requirements Thread	Chapter 8gave an overview of the iteration process, tasks, and artifacts for the team as a whole. This chapter contains a detailed look at the work of a Business Analyst (BA). It shows how the BA uses inputs from other team members and produces outputs for them. This chapter compares use cases and user stories, and describes a guideline for how agile BAs may do their job. It should help other team members understand the BA on their team, and possibly allow novice BAs working in an agile team to perform the business analysis and requirements function better. If the team does not have a BA, then this chapter may help others complete the requirements-centric tasks normally performed by the BA.		Alan Cline	Agile Development in the Real World	https://doi.org/10.1007/978-1-4842-1679-8_9		pp 165–195		Excluded	Excluded	new_screen			2	SpringerLink		Requirements Thread	http://link.springer.com/chapter/10.1007/978-1-4842-1679-8_9	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
500	Behave	Resolving Interoperability in Concurrent Engineering	To face an increasingly competitive environment within a globalization context, and to focus on core high-added value business activities, enterprises have to establish partnerships with other companies specialized in complementary domains. Such an approach, primarily based on optimization of the value chain, is called virtualization of the Enterprise. Enterprises relying on virtualization, sub-contracting and outsourcing have to coordinate activities of all the partners, to integrate the results of their activities, to manage federated information coming from the different implied information systems and to re-package them as a product for the clients. The adopted organization, which is considering as well as the internal and external resources, is called “Extended Enterprise”. Nevertheless, in such complex emerging networked organizations, it is more and more challenging to be able to interchange, to share and to manage internal and external resources such as digital information, digital services and computer-enacted processes. In addition, digital artifacts produced by enterprise activities are more and more heterogeneous and complex. After characterizing expected interoperability for collaborative platform systems and highlighting interoperability issues and brakes not yet addressed, this chapter describes an innovative approach to build interoperability based on a Federated Framework of legacy eBusiness standards of a given ecosystem. It implies facing important issues related to semantic preservation along the lifecycle of the artifacts and infrastructures required to define and exploit an application. We present two use case studies that apply interoperability strategies.		Nicolas Figay,; Catarina Ferreira da Silva,; Parisa Ghodous&; Ricardo Jardim-Goncalves	Concurrent Engineering in the 21st Century	https://doi.org/10.1007/978-3-319-13776-6_6		pp 133–163		Excluded	Excluded	new_screen			2	SpringerLink		Resolving Interoperability in Concurrent Engineering	http://link.springer.com/chapter/10.1007/978-3-319-13776-6_6	Springer, Cham	nan; Keywords; References; Year; Bibtex
501	Behave	REST API	In this tutorial, we’ll build a RESTful API. In addition to Express.js, we’ll use MongoDB via the Mongoskin library. We’ll also use Mocha and SuperAgent to write functional tests.		Azat Mardan	Pro Express.js	https://doi.org/10.1007/978-1-4842-0037-7_21		pp 249–261		Excluded	Excluded	new_screen			2	SpringerLink		REST API	http://link.springer.com/chapter/10.1007/978-1-4842-0037-7_21	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
502	Behave	Rigorous development process of a safety-critical system: from ASM models to Java code	http://link.springer.com/article/10.1007/s10009-015-0394-x		Paolo ArcainiAngelo GargantiniElvinia Riccobene		http://link.springer.com/article/10.1007/s10009-015-0394-x				Excluded	Excluded	new_screen			2						
503	Behave	Robust Design of a Collaborative Platform for Model-Based System Engineering: Experience from an Industrial Deployment	Model-Based System Engineering is gaining momentum in the industry. In order to be successful, it requires adequate tooling support. In addition to functional requirements related to model edition, verification and transformation, key non-functional requirements need to be carefully addressed such as versioning, usability/team work, reliability, security, ease of integration. In this paper, we first give an overview of how we dealt with such requirements in the context of the development of a real world platform for a global telecom operator, with a focus on early steps of system modelling. We then present a more detailed design of the tooling architecture and a high availability protocol for accessing a mainstream model repository. The proposed protocol is modelled and verified using the Alloy language and model-checker.	Model-Based System Engineering; Tool support; Modelling; Industrial transfer; High availability; Alloy; Model-checking	Christophe PonsardORCID:orcid.org/---,; Robert Darimont&; Mounir Touzani	International Conference on Model and Data Engineering	https://doi.org/10.1007/978-3-030-32065-2_23		pp 333–347		Excluded	Excluded	new_screen			2	SpringerLink		Robust Design of a Collaborative Platform for Model-Based System Engineering: Experience from an Industrial Deployment	http://link.springer.com/chapter/10.1007/978-3-030-32065-2_23	Springer, Cham	nan; References; Year; Bibtex
504	Behave	ROM: An Approach to Self-consistency Verification of a Runnable Ontology Model	In the quest for the highest possible abstraction of software systems, Runnable Knowledge has been proposed for MDA. But in order to be useful in practice as a system design, it must be amenable to verification. This work precisely describes the necessary steps by which ROM – a Runnable Ontology Model tool – concurrently generates a running model and its respective test script from the designed Runnable Knowledge, allowing verification that the model is self-consistent. The novel implementation idea is to use ready-made mock object libraries to efficiently obtain the code for a running model. Detailed examples are provided to illustrate each of the ROM generation steps.	Runnable Knowledge; Ontology; Ontology States; Model Testing; Mock Objects; Self-consistency; Verification	Iaakov Exman&; Reuven Yagel	International Joint Conference on Knowledge Discovery, Knowledge Engineering, and Knowledge Management	https://doi.org/10.1007/978-3-642-54105-6_18		pp 271–283		Excluded	Excluded	new_screen			2	SpringerLink		ROM: An Approach to Self-consistency Verification of a Runnable Ontology Model	http://link.springer.com/chapter/10.1007/978-3-642-54105-6_18	Springer, Berlin, Heidelberg	nan; References; Year; Bibtex
505	Behave	SAFECode Whitepaper: Fundamental Practices for Secure Software Development 2nd Edition			Stacy Simpson						Excluded	Excluded	new_screen			2						
506	Behave	Scala Testing	This chapter examines the various facilities available within Scala to perform a range of tests.	Scale Tests; IntelliJ; Assert Class; Test-driven Development; Refactoring	John Hunt	A Beginner's Guide to Scala, Object Orientation and Functional Programming	https://doi.org/10.1007/978-3-319-75771-1_37		pp 415–429		Excluded	Excluded	new_screen			2	SpringerLink		Scala Testing	http://link.springer.com/chapter/10.1007/978-3-319-75771-1_37	Springer, Cham	nan; References; Year; Bibtex
507	Behave	Scaling Your Team			David Pollak						Excluded	Excluded	new_screen			2						
508	Behave	Scripting			Gennadiy Alpaev						Excluded	Excluded	new_screen			2						
509	Behave	Scrum Framework und Praxis	Das handlungsorientierte Framework Scrum, das bereits sehr breit in der Softwareentwicklung, aber auch in anderen Bereichen der fertigenden Industrie etabliert ist, eignet sich als guter Start, um den praktischen Einsatz agiler Arbeitsweise zu diskutieren. Ich gehe auf die wesentlichen Artefakte des Frameworks ein, um an diesem Beispiel die Frage des Warums für die drei Zielgruppen des Buches (Unternehmer, Kunden, Mitarbeiter) praktisch zu diskutieren. Das Kapitel greift Entwicklungen der Scrum Community auf und zeigt Weiterentwicklungen des Frameworks gegenüber seinem Erscheinen im Jahre 2001 auf und geht auf die Gründe und Überlegungen ein, die zu diesen Veränderungen geführt haben. Vom Verständnis des Team-Commitments über die Notwendigkeit der Schätzung bis zur praktischen Anwendbarkeit des Verfahrens in Verträgen werden die Artefakte der Methodik greifbar.		Janko Böhm	Erfolgsfaktor Agilität	https://doi.org/10.1007/978-3-658-25085-0_3		pp 35–74		Excluded	Excluded	new_screen			2	SpringerLink		Scrum Framework und Praxis	http://link.springer.com/chapter/10.1007/978-3-658-25085-0_3	Springer Vieweg, Wiesbaden	nan; Keywords; References; Year; Bibtex
510	Behave	Semi-automated Design Guidance Enhancer (SADGE): A Framework for Architectural Guidance Development			Mohsen AnvaariOlaf Zimmermann						Excluded	Excluded	new_screen			2						
511	Behave	Shorter Feedback Loops By Means of Continuous Deployment	Gathering early feedback on features is critical to many projects. Many Agile methodologies define feedback loops. Often, the feedback loop for completed features only closes after the iteration finishes. In this paper we will introduce a way of closing this feedback loop early, by means of continuous deployment. This also lowers the deployment effort for developers, increasing their happiness.		Arjan Claassen&; Laurens Boekhorst	International Conference on Agile Software Development	https://doi.org/10.1007/978-3-319-18612-2_24		pp 248–253		Excluded	Excluded	new_screen			2	SpringerLink		Shorter Feedback Loops By Means of Continuous Deployment	http://link.springer.com/chapter/10.1007/978-3-319-18612-2_24	Springer, Cham	nan; Keywords; References; Year; Bibtex
512	Behave	Software Processes in the Software Product Life Cycle	Apart from the different formats of software process descriptions and life cycle models as discussed in the previous chapter, there are many different types of such models. The basis for these models is formed by several fundamental life cycles, in particular sequential models such as the waterfall model or the V-shaped model, and iterative-incremental models such as the spiral model or Scrum. These fundamental life cycles can be varied in many forms, or extended by adding information leading to detailed process models such as the (Rational) Unified Process. The models can also include different sets of processes, where at one end of the spectrum, software processes support software development by structuring the different development-related activities. At the other end of the spectrum, software processes also provide a more comprehensive perspective, e.g. including operation and IT service management, or interfacing with organisational and administrative tasks. Depending on the purpose of the model, there are some very different types of process reference models available, including for example method-driven life cycle models, agile methodologies, process assessment models. In this chapter, we survey these different types of software processes and their role in the software life cycle. We provide a categorization of software processes, introduce the basic life cycle models, and present some selected reference models.		Ralf Kneuper	Software Processes and Life Cycle Models	https://doi.org/10.1007/978-3-319-98845-0_3		pp 69–157		Excluded	Excluded	new_screen			2	SpringerLink		Software Processes in the Software Product Life Cycle	http://link.springer.com/chapter/10.1007/978-3-319-98845-0_3	Springer, Cham	nan; Keywords; References; Year; Bibtex
513	Behave	Software Quality Assurance During Implementation: Results of a Survey in Software Houses from Germany, Austria and Switzerland	Context:Quality assurance performed during the implementation phase, e.g., by coding guidelines, static analysis or unit testing, is of high importance to ensure quality of software, but there is a lack of common knowledge and best practices on it.Objective:The goal of this paper is to investigate the state-of-practice of quality assurance during the implementation phase in software houses.Method:For this purpose, we conducted a survey in Germany, Austria, and Switzerland where 57 software houses participated. The questionnaire comprised questions regarding techniques, tools, and effort for software quality assurance during implementation as well as the perceived quality after implementation. The results were complemented by interviews and results from other surveys on software quality in general.Results:Results from the survey show that the most common software quality assurance techniques used during implementation are unit testing, code reviews and coding guidelines. Most tool support is used in the areas of bug tracking, version control and project management. Due to relationships between the used tool types, it seems that the introduction of one tool leads to the adoption of several others. Also quality assurance techniques and tools are correlated. Bug fixing takes a significant ratio of the overall project effort assigned to implementation. Furthermore, we found that the more developers a software company has, the more effort is spent on bug fixing. Finally, more than half of all companies rated the quality after implementation as rather good to good.Conclusion:For the most important quality assurance techniques and supporting tool types clear usage patterns can be seen and serve as a basis to provide guidelines on their application in practice.	Software quality assurance; Implementation; Software development; Software quality; Software houses; Survey	Michael Felderer&; Florian Auer	International Conference on Software Quality	https://doi.org/10.1007/978-3-319-49421-0_7		pp 87–102		Excluded	Excluded	new_screen			2	SpringerLink		Software Quality Assurance During Implementation: Results of a Survey in Software Houses from Germany, Austria and Switzerland	http://link.springer.com/chapter/10.1007/978-3-319-49421-0_7	Springer, Cham	nan; References; Year; Bibtex
514	Behave	Quantum Software Testing 101	Quantum software testing (QST) is an emerging research area within quantum software engineering (QSE) to ensure quantum software functional and non-functional correctness and dependability. Since quantum computers perform computations significantly differently than classical computing, testing quantum software running on these quantum computers also differs due to quantum computing's unique characteristics, e.g., entanglement and superposition. Due to the rising interest of the software engineering community in QSE, we will provide an introduction to QST. We will introduce quantum computing and its various principles, quantum software development as quantum circuits, and current QST literature, including a key set of techniques with examples. Finally, a set of future research challenges related to QST will be presented.	quantum computing;  quantum programs;  quantum software testing	Ali, Shaukat		https://doi.org/10.1145/3639478.3643059		426-427	"@inproceedings{10.1145/3639478.3643059,
    author = ""Ali, Shaukat"",
    title = ""Quantum Software Testing 101"",
    year = ""2024"",
    isbn = ""9798400705021"",
    publisher = ""Association for Computing Machinery"",
    address = ""New York, NY, USA"",
    url = ""https://doi.org/10.1145/3639478.3643059"",
    doi = ""10.1145/3639478.3643059"",
    abstract = ""Quantum software testing (QST) is an emerging research area within quantum software engineering (QSE) to ensure quantum software functional and non-functional correctness and dependability. Since quantum computers perform computations significantly differently than classical computing, testing quantum software running on these quantum computers also differs due to quantum computing's unique characteristics, e.g., entanglement and superposition. Due to the rising interest of the software engineering community in QSE, we will provide an introduction to QST. We will introduce quantum computing and its various principles, quantum software development as quantum circuits, and current QST literature, including a key set of techniques with examples. Finally, a set of future research challenges related to QST will be presented."",
    booktitle = ""Proceedings of the 2024 IEEE/ACM 46th International Conference on Software Engineering: Companion Proceedings"",
    pages = ""426-427"",
    numpages = ""2"",
    keywords = ""quantum computing, quantum programs, quantum software testing"",
    location = ""Lisbon, Portugal"",
    series = ""ICSE-Companion '24""
}"	Excluded	Excluded	new_screen			2	ACM		Software Testing	http://link.springer.com/chapter/10.1007/978-3-030-00262-6_4	Association for Computing Machinery	nan; Venue; References
515	Behave	Specification by Example for Educational Purposes	The Specification By Example (SBE) is a guideline for building the right software, a software that meets customer requirements. It is based on seven process patterns and enhances communication and collaboration and it usually is used in agile software development. The connection between education and agile software development sounds actually as an emergent topic. In this paper, we propose to structure a teaching approach in analogy to an agile software developement by transposing each process pattern of SBE to a corresponding one in the teaching domain. Moreover, we show that thanks to the emergence of a collective intelligence process, the students are more confident and more responsible. Such a course offers the opportunity to learn not only technical skills, but also some values in a new mindset.	specification by example;  agile teaching;  agile software development	Blasquez, Isabelle; Leblanc, Herv\'{e}		https://doi.org/10.1145/3059009.3059039		212-217	"@inproceedings{10.1145/3059009.3059039,
    author = ""Blasquez, Isabelle and Leblanc, Herv\'{e}"",
    title = ""Specification by Example for Educational Purposes"",
    year = ""2017"",
    isbn = ""9781450347044"",
    publisher = ""Association for Computing Machinery"",
    address = ""New York, NY, USA"",
    url = ""https://doi.org/10.1145/3059009.3059039"",
    doi = ""10.1145/3059009.3059039"",
    abstract = ""The Specification By Example (SBE) is a guideline for building the right software, a software that meets customer requirements. It is based on seven process patterns and enhances communication and collaboration and it usually is used in agile software development. The connection between education and agile software development sounds actually as an emergent topic. In this paper, we propose to structure a teaching approach in analogy to an agile software developement by transposing each process pattern of SBE to a corresponding one in the teaching domain. Moreover, we show that thanks to the emergence of a collective intelligence process, the students are more confident and more responsible. Such a course offers the opportunity to learn not only technical skills, but also some values in a new mindset."",
    booktitle = ""Proceedings of the 2017 ACM Conference on Innovation and Technology in Computer Science Education"",
    pages = ""212-217"",
    numpages = ""6"",
    keywords = ""specification by example, agile teaching, agile software development"",
    location = ""Bologna, Italy"",
    series = ""ITiCSE '17""
}"	Excluded	Excluded	new_screen			2	ACM		Specification by Example	http://link.springer.com/chapter/10.1007/978-3-030-00262-6_4	Association for Computing Machinery	nan; Venue; References
516	Behave	Specifications and testing aided by a variant of the cause-effect process	For many years the cause-effect process has played a role in testing [1, 2]. A simplified variation of the cause-effect process will be shown. This variation is not only effective for testing and carefully analyzing existing specifications, but is also useful for developing complete specifications. The cause-effect graph is claimed to be unnecessary.		Baxter, Anthony Q.; French, J. Austin		https://doi.org/10.1145/503720.503750		405-408	"@inproceedings{10.1145/503720.503750,
    author = ""Baxter, Anthony Q. and French, J. Austin"",
    title = ""Specifications and testing aided by a variant of the cause-effect process"",
    year = ""1992"",
    isbn = ""0897915062"",
    publisher = ""Association for Computing Machinery"",
    address = ""New York, NY, USA"",
    url = ""https://doi.org/10.1145/503720.503750"",
    doi = ""10.1145/503720.503750"",
    abstract = ""For many years the cause-effect process has played a role in testing [1, 2]. A simplified variation of the cause-effect process will be shown. This variation is not only effective for testing and carefully analyzing existing specifications, but is also useful for developing complete specifications. The cause-effect graph is claimed to be unnecessary."",
    booktitle = ""Proceedings of the 30th Annual ACM Southeast Regional Conference"",
    pages = ""405-408"",
    numpages = ""4"",
    location = ""Raleigh, North Carolina"",
    series = ""ACMSE '92""
}"	Excluded	Excluded	new_screen			2	ACM		Specifications and Testing	http://link.springer.com/chapter/10.1007/978-1-4842-1745-0_15	Association for Computing Machinery	nan; Venue; Keywords; References
517	Behave	SportsStore: A Real Application	You’ve heard about the benefits of the ASP.NET MVC platform, and you’ve learned some of the theory behind its design. Now it’s time to put the framework into action for real and see how those benefits work out in a realistic e-commerce application.	Real Application; Unit Test; Visual Studio; Public Class; Constructor Parameter	Steven Sanderson	Pro ASP.NET MVC 2 Framework	https://doi.org/10.1007/978-1-4302-2887-5_4		pp 91–134		Excluded	Excluded	new_screen			2	SpringerLink		SportsStore: A Real Application	http://link.springer.com/chapter/10.1007/978-1-4302-2887-5_4	Apress	nan; References; Year; Bibtex
518	Behave	SportsStore: Navigation and Shopping Cart	In Chapter 4, you set up the majority of the core infrastructure needed to build SportsStore. There’s already a basic product list backed by a SQL Server database. However, you’re still several steps away from dominating global online commerce. In this chapter, then, you’ll get deep into the ASP.NET MVC development process, adding catalog navigation, a shopping cart, and a checkout process. As you do, you’ll learn how to do the following:	Action Method; Unit Test; Partial View; Controller Class; Session Collection	Steven Sanderson	Pro ASP.NET MVC 2 Framework	https://doi.org/10.1007/978-1-4302-2887-5_5		pp 135–178		Excluded	Excluded	new_screen			2	SpringerLink		SportsStore: Navigation and Shopping Cart	http://link.springer.com/chapter/10.1007/978-1-4302-2887-5_5	Apress	nan; References; Year; Bibtex
519	Behave	Spotify Tailoring for Architectural Governance	Organisations usually tailor Agile methods to fit their needs best. Spotify has developed its own Agile culture to facilitate software development for hundreds of developers across multiple cities. The Spotify model has become influential among agile proponents and hence formed the basis of methods used in other organisations. We have identified a lack of research into agile architecture using the Spotify model.To exploreHow can architectural governance increase the autonomy of teams when using the Spotify model?, an intervention embedded case study was conducted in a multinational FinTech organisation, using the Spotify model. New processes were introduced by developing and evaluating an approach to Agile architectural governance. This approach incorporates a structural change and a change management process. We conducted 6 semi-structured open-ended interviews and direct observations of Agile practices. The collected data was analysed using Thematic Analysis and informed by some Grounded Theory techniques.The practitioners in our study report benefits of this evaluated approach. These benefits include transforming architectural based decision into decentralised based decision-making, strengthening the autonomy of squads through aligning architectural based decisions, sharing the architectural knowledge among the squads, and other benefits.We identify the characteristics and benefits of our evaluated approach to Agile architectural governance using the Spotify model. Also, we identify guidelines and challenges for those wishing to adopt this approach.	Spotify tailoring; Architecture governance; Autonomous teams; Large-scale; FinTech; Intervention embedded case study	Abdallah Salameh&; Julian M. Bass	International Conference on Agile Software Development	https://doi.org/10.1007/978-3-030-58858-8_24		pp 236–244		Excluded	Excluded	new_screen			2	SpringerLink		Spotify Tailoring for Architectural Governance	http://link.springer.com/chapter/10.1007/978-3-030-58858-8_24	Springer, Cham	nan; References; Year; Bibtex
520	Behave	Sprint 1: Starting a Game	It’s time to begin writing features for Kojack Games! With our initial backlog created and prioritized, our development infrastructure established, and our initial product backlog prioritized, we are ready to start coding features! In this chapter we’ll layout a plan on how to approach writing features using BDD and see it through to the code implementation. We’ll go through the practice of a sprint planning session, the way daily stands-up work, and how to manage the task board and burn-down charts.	Acceptance Criterion; Action Item; User Story; Feature File; Task Board	Jerrel Blankenship,; Matthew Bussa&; Scott Millett	Pro Agile .NET Development with Scrum	https://doi.org/10.1007/978-1-4302-3534-7_5		pp 87–133		Excluded	Excluded	new_screen			2	SpringerLink		Sprint 1: Starting a Game	http://link.springer.com/chapter/10.1007/978-1-4302-3534-7_5	Apress, Berkeley, CA	nan; References; Year; Bibtex
521	Behave	Subconscious Requirements: The Fright of Every Tester			Hans van Loenhoud						Excluded	Excluded	new_screen			2						
522	Behave	Success and Failure Factors for Adopting a Combined Approach: A Case Study of Two Software Development Teams	The combination of Agile, User-Centered Design and Lean Startup has emerged as a solution for teams that are struggling with lack of user involvement and delivering products that fulfill stakeholder needs. Adopting such a development approach involves several factors, some of which can assist or hinder the adoption process. Currently, the literature reports on studies on such factors, but only for agile-only methods. Motivated by this knowledge gap, our goal is to map the success and failure factors of a combined approach adoption. We conduct a case study with two software development teams from a large organization transitioning to the combined approach. We used semi-structured interviews and focus group sessions to collect data. Our findings show five success factors categories (e.g., team engagement, technical aspects) and one failure factor category (team autonomy at risk), along with several argumentation points suggested by the teams to argue against a company policy perceived to be a very impactful failure factor. This study contributes to academic literature by reporting on success and failure factors of a combined approach transformation, and could be used as a starting point in defining tools (e.g., maturity models) to aid organizations in transitioning to the combined approach.	Agile; User-centered design; Lean startup; Success factors; Failure factors; Agile transformation	Ingrid Signoretti,; Maximilian Zorzetti,; Larissa Salerno,; Cassiano Moralles,; Eliana Pereira,; Cássio Trindade,; Sabrina Marczak&; Ricardo Bastos	International Conference on Product-Focused Software Process Improvement	https://doi.org/10.1007/978-3-030-64148-1_8		pp 125–141		Excluded	Excluded	new_screen			2	SpringerLink		Success and Failure Factors for Adopting a Combined Approach: A Case Study of Two Software Development Teams	http://link.springer.com/chapter/10.1007/978-3-030-64148-1_8	Springer, Cham	nan; References; Year; Bibtex
523	Behave	Supporting Agile Software Development by Natural Language Processing	Agile software development puts more emphasis on working programs than on documentation. However, this may cause complications from the management perspective when an overview of the progress achieved within a project needs to be provided. In this paper, we outline the potential for applying natural language processing (NLP) in order to support agile development. We point out that using NLP, the artifacts created during agile software development activities can be traced back to the requirements expressed in user stories. This allows determining how far the project has progressed in terms of realized requirements.	Agile Software Development; Project Management; Machine Learning; Natural Language Processing	Barbara Plank,; Thomas Sauer&; Ina Schaefer	International Workshop on Eternal Systems	https://doi.org/10.1007/978-3-642-45260-4_7		pp 91–102		Excluded	Excluded	new_screen			2	SpringerLink		Supporting Agile Software Development by Natural Language Processing	http://link.springer.com/chapter/10.1007/978-3-642-45260-4_7	Springer, Berlin, Heidelberg	nan; References; Year; Bibtex
524	Behave	Taking It to 11			Jeffrey ScheafferAruna RavichandranAlex Martins						Excluded	Excluded	new_screen			2						
525	Behave	TDD and BDD for Node.js with Mocha	Test-driven development (TDD), as many of you might know, is one of the main, agile development techniques. The genius of TDD lies in increased quality of code, faster development resulting from greater programmer confidence, and improved bug detection (duh!).		Azat Mardan	Practical Node.js	https://doi.org/10.1007/978-1-4302-6596-2_3		pp 57–69		Excluded	Excluded	new_screen			2	SpringerLink		TDD and BDD for Node.js with Mocha	http://link.springer.com/chapter/10.1007/978-1-4302-6596-2_3	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
526	Behave	TDD as an API Design Technique			Ervin Varga						Excluded	Excluded	new_screen			2						
527	Behave	Temporal Random Testing for Spark Streaming	With the rise of Big Data technologies, distributed stream processing systems (SPS) have gained popularity in the last years. Among them, Spark Streaming stands out as a particularly attractive option with a growing adoption in the industry. In this work we explore the combination of temporal logic and property-based testing for testing Spark Streaming programs, by adding temporal logic operators to ScalaCheck generators and properties. This allows us to deal with the time component that complicates the testing of Spark Streaming programs and SPS in general. In particular we propose a discrete time linear temporal logic for finite words, that allows to associate a timeout to each temporal operator in order to increase the expressiveness of generators and properties. Finally, our prototype is presented with some examples.	Stream processing systems; Spark streaming; Property-based testing; Random testing; Linear temporal logic; Scala; Big data	Adrián Riesco&; Juan Rodríguez-Hortalá	International Conference on Integrated Formal Methods	https://doi.org/10.1007/978-3-319-33693-0_25		pp 393–408		Excluded	Excluded	new_screen			2	SpringerLink		Temporal Random Testing for Spark Streaming	http://link.springer.com/chapter/10.1007/978-3-319-33693-0_25	Springer, Cham	nan; References; Year; Bibtex
528	Behave	Test early, test often: a formative usability kit for writers	http://link.springer.com/chapter/10.1007/978-3-030-30701-1_6		Kaminsky, Sophie Kohn		https://doi.org/10.1145/147001.147007		47-55	"@inproceedings{10.1145/147001.147007,
    author = ""Kaminsky, Sophie Kohn"",
    title = ""Test early, test often: a formative usability kit for writers"",
    year = ""1992"",
    isbn = ""0897915321"",
    publisher = ""Association for Computing Machinery"",
    address = ""New York, NY, USA"",
    url = ""https://doi.org/10.1145/147001.147007"",
    doi = ""10.1145/147001.147007"",
    booktitle = ""Proceedings of the 10th Annual International Conference on Systems Documentation"",
    pages = ""47-55"",
    numpages = ""9"",
    location = ""Ottawa, Ontario, Canada"",
    series = ""SIGDOC '92""
}"	Excluded	Excluded	new_screen			2	ACM		Test Early, Test Often	http://link.springer.com/chapter/10.1007/978-3-030-30701-1_6	Association for Computing Machinery	nan; Venue; Abstract; Keywords; References
529	Behave	Test Frameworks	This chapter covers the topic of test frameworks. In a broad sense, a test framework is a technology or set of tools that supports automated software testing. Most developers are familiar with one of the code-driven test frameworks, which are commonly referred to as unit testing frameworks. In this chapter, you will learn about the four most popular unit testing frameworks. Another important component to any test framework is the test runner. You will learn about a variety of test runners, from the minimalist runners to those that are well-integrated into Visual Studio. This chapter also provides an overview of the xUnit test pattern and explains how each of the unit testing frameworks discussed fits the pattern.	Visual Studio; Generally Accept Account Principle; Test Framework; Test Code; Code Coverage	Stephen D. Ritchie	Pro .NET Best Practices	https://doi.org/10.1007/978-1-4302-4024-2_12		pp 265–312		Excluded	Excluded	new_screen			2	SpringerLink		Test Frameworks	http://link.springer.com/chapter/10.1007/978-1-4302-4024-2_12	Apress	nan; References; Year; Bibtex
530	Behave	Gamification in Test-Driven Development Practice	The challenge of effectively developing and sustaining high-performance professional development practices in software engineering education is one that must be addressed. Test-driven development (TDD), an example of a key professional practical activity, is strongly linked to these high-performance practices. To examine the effects of gamification - the use of game design elements in a non-game context - on motivating students to develop and sustain TDD practice, an experiment was conducted and utilized ordinary least squares (OLS) regression to analyze the data. This experiment showed that gamification motivates students to do high-performing TDD practice. More specifically, gamification changes the individual's TDD behavior, increases engagement in the development activity, and the effect continues for a longer period even after gamification has ceased. Furthermore, a positive association between gamification and the maintainability of the team codebase was supported by the data.	Engagement;  Gamification;  Maintainability;  Software Engineering;  Test-driven Development	Ren, Wei		https://doi.org/10.1145/3617553.3617889		38-46	"@inproceedings{10.1145/3617553.3617889,
    author = ""Ren, Wei"",
    title = ""Gamification in Test-Driven Development Practice"",
    year = ""2023"",
    isbn = ""9798400703737"",
    publisher = ""Association for Computing Machinery"",
    address = ""New York, NY, USA"",
    url = ""https://doi.org/10.1145/3617553.3617889"",
    doi = ""10.1145/3617553.3617889"",
    abstract = ""The challenge of effectively developing and sustaining high-performance professional development practices in software engineering education is one that must be addressed. Test-driven development (TDD), an example of a key professional practical activity, is strongly linked to these high-performance practices. To examine the effects of gamification - the use of game design elements in a non-game context - on motivating students to develop and sustain TDD practice, an experiment was conducted and utilized ordinary least squares (OLS) regression to analyze the data. This experiment showed that gamification motivates students to do high-performing TDD practice. More specifically, gamification changes the individual's TDD behavior, increases engagement in the development activity, and the effect continues for a longer period even after gamification has ceased. Furthermore, a positive association between gamification and the maintainability of the team codebase was supported by the data."",
    booktitle = ""Proceedings of the 2nd International Workshop on Gamification in Software Development, Verification, and Validation"",
    pages = ""38-46"",
    numpages = ""9"",
    keywords = ""Engagement, Gamification, Maintainability, Software Engineering, Test-driven Development"",
    location = ""San Francisco, CA, USA"",
    series = ""Gamify 2023""
}"	Excluded	Excluded	new_screen			2	ACM		Test-Driven Development	http://link.springer.com/chapter/10.1007/978-1-4842-5949-8_8	Association for Computing Machinery	nan; Venue; References
531	Behave	Test-Driven Development 101	In this chapter, we will learn how to applyTDDin our daily development routine through a step-by-step guide. Along with this demo, you will get an idea of how to split a big task into relatively smaller ones and complete each one with a set of passing tests while learning some refactoring techniques. Before we dive into the code, let’s get a fundamental understanding of how to write a proper test.		Juntao Qiu	Test-Driven Development with React	https://doi.org/10.1007/978-1-4842-6972-5_3		pp 35–45		Excluded	Excluded	new_screen			2	SpringerLink		Test-Driven Development 101	http://link.springer.com/chapter/10.1007/978-1-4842-6972-5_3	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
532	Behave	Test-Driven Development as a Reliable Embedded Software Engineering Practice	Due to embedded co-design considerations, testing embedded software is typically deferred after the integration phase. Contrasting with the current embedded engineering practices, Test-Driven Development (TDD) promotes testing software during its development, even before the target hardware becomes available. Principally, TDD promotes a fast feedback cycle in which a test is written before the implementation. Moreover, each test is added to a test suite, which runs at every step in the TDD cycle. As a consequence, test-driven code is well tested and maintainable. Still, embedded software has some typical properties which impose challenges to apply the TDD cycle. Essentially, uploading software to target is generally too time-consuming to frequently run tests on target. Secondary issues are hardware dependencies and limited resources, such as memory footprint or processing power. In order to deal with these limitations, four methods have been identified and evaluated. Furthermore, a number of relevant design patterns are discussed to apply TDD in an embedded environment.		Piet Cordemans,; Sille Van Landschoot,; Jeroen Boydens&; Eric Steegmans	Embedded and Real Time System Development: A Software Engineering Perspective	https://doi.org/10.1007/978-3-642-40888-5_4		pp 91–130		Excluded	Excluded	new_screen			2	SpringerLink		Test-Driven Development as a Reliable Embedded Software Engineering Practice	http://link.springer.com/chapter/10.1007/978-3-642-40888-5_4	Springer, Berlin, Heidelberg	nan; Keywords; References; Year; Bibtex
533	Behave	Testing	Unit testing is the art of taking small sections of your code (called units) and testing that functionality to ensure that it works properly. For example, you might take a small unit of code, like a controller method, and assert that it returns a view class.		Christopher Pitt&; Joe Mancuso	The Definitive Guide to Masonite	https://doi.org/10.1007/978-1-4842-5602-2_12		pp 175–183		Excluded	Excluded	new_screen			2	SpringerLink		Test-Driven Development in Swift	http://link.springer.com/chapter/10.1007/978-1-4842-5602-2_12	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
534	Behave	Automated Testing of Networked Systems Reliability	The reliability of a network is a crucial requirement for systems such as IoT, client-server, or cloud-based solutions. Unfortunately, real networks cannot be assumed to be fault-free, especially when considering various hardware problems, performance issues, or malicious attacks. Testing networked systems should therefore include evaluating fault tolerance under various network conditions. The paper presents a doctoral research project on automated verification of networked systems using fault-attack injection using a derived model of network communication.	Networked systems;  fault/attack injection;  network model;  testing	Rozs\'{\i}val, Michal		https://doi.org/10.1145/3650212.3685559		1920-1922	"@inproceedings{10.1145/3650212.3685559,
    author = ""Rozs\'{\i}val, Michal"",
    title = ""Automated Testing of Networked Systems Reliability"",
    year = ""2024"",
    isbn = ""9798400706127"",
    publisher = ""Association for Computing Machinery"",
    address = ""New York, NY, USA"",
    url = ""https://doi.org/10.1145/3650212.3685559"",
    doi = ""10.1145/3650212.3685559"",
    abstract = ""The reliability of a network is a crucial requirement for systems such as IoT, client-server, or cloud-based solutions. Unfortunately, real networks cannot be assumed to be fault-free, especially when considering various hardware problems, performance issues, or malicious attacks. Testing networked systems should therefore include evaluating fault tolerance under various network conditions. The paper presents a doctoral research project on automated verification of networked systems using fault-attack injection using a derived model of network communication."",
    booktitle = ""Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis"",
    pages = ""1920-1922"",
    numpages = ""3"",
    keywords = ""Networked systems, fault/attack injection, network model, testing"",
    location = ""Vienna, Austria"",
    series = ""ISSTA 2024""
}"	Excluded	Excluded	new_screen			2	ACM		Testing	http://link.springer.com/chapter/10.1007/978-1-4842-0187-9_12	Association for Computing Machinery	nan; Venue; References
535	Behave	Testing & Debugging	It is time to shift our focus to another important part of API design, which is the testing and debugging of the source code. This chapter will briefly share some interesting points on why testing is essential, as well as dive into the implementation details for creating unit and integration tests. Also included in this chapter will be complete instructions on how to debug the source code of compiled external libraries by using their symbols loaded from the Internet.	Dotnet; HttpClient; Behavior-driven Development (BDD); Class Integration Test; ICalculator	Fanie Reynders	Modern API Design with ASP.NET Core 2	https://doi.org/10.1007/978-1-4842-3519-5_10		pp 185–201		Excluded	Excluded	new_screen			2	SpringerLink		Testing & Debugging	http://link.springer.com/chapter/10.1007/978-1-4842-3519-5_10	Apress, Berkeley, CA	nan; References; Year; Bibtex
536	Behave	Testing and Debugging Projects	Test-driven development (TDD) promotes the writing of executable test cases before you start coding. After you add the desired functionality, you then run the tests to make sure the new functionality works as expected, and that the changes don’t break something else. The NetBeans IDE provides quick access to the TDD support that is provided by Ruby and the Rails framework through the IDE’s menu actions, keyboard shortcuts, and Test Results window.	Source Line; Unit Test; Main Menu; Output Window; Test File		NetBeans™ Ruby and Rails IDE with JRuby	https://doi.org/10.1007/978-1-4302-1637-7_7		pp 105–125		Excluded	Excluded	new_screen			2	SpringerLink		Testing and Debugging Projects	http://link.springer.com/chapter/10.1007/978-1-4302-1637-7_7	Apress	nan; Authors; References; Year; Bibtex
537	Behave	Testing Batch Processes	Testing is everyone’s favorite part of programming. The funny thing is, like most things in life, once you get good at it, testing actually is fun. It allows you to be more productive. It provides a safety net for you to try new things. Programmatic tests also give you a test bed to try new technologies (most companies don’t mind if you want to try something new in the tests but mind greatly if you try it in code that’s going to production). You’ve spent the previous ten chapters writing code without the ability to prove that any of it works. This chapter looks at how to exercise your code in a variety of ways so you can not only prove that it works as designed, but also provide a safety net for when you change it.		Michael T. Minella	The Definitive Guide to Spring Batch	https://doi.org/10.1007/978-1-4842-3724-3_13		pp 435–454		Excluded	Excluded	new_screen			2	SpringerLink		Testing Batch Processes	http://link.springer.com/chapter/10.1007/978-1-4842-3724-3_13	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
538	Behave	Testing Chatbots withCharm	Chatbots are software programs with a conversational user interface, typically embedded in webs or messaging systems like Slack, Facebook Messenger or Telegram. Many companies are investing in chatbots to improve their customer support. This has led to a proliferation of chatbot creation platforms (e.g., Dialogflow, Lex, Watson). However, there is currently little support for testing chatbots, which may impact in their final quality.To alleviate this problem, we propose a methodology that automates the generation ofcoherence,sturdinessandprecisiontests for chatbots, and exploits the test results to improve the chatbot precision. The methodology is supported by a tool calledCharm, which usesBotiumas the backend for automated test execution. Moreover, we report on experiments aimed at improving Dialogflow chatbots built by third parties.	Chatbots; Testing; Botium; Dialogflow	Sergio Bravo-Santos,; Esther Guerra&; Juan de Lara	International Conference on the Quality of Information and Communications Technology	https://doi.org/10.1007/978-3-030-58793-2_34		pp 426–438		Excluded	Excluded	new_screen			2	SpringerLink		Testing Chatbots with Charm	http://link.springer.com/chapter/10.1007/978-3-030-58793-2_34	Springer, Cham	nan; References; Year; Bibtex
539	Behave	Testing Go Applications	Automated testing is an important practice in software engineering that ensures the quality of your applications. If you are concerned about application quality, you should write automated tests to verify the behavior of the components of your applications. In your Go applications, automated tests can ensure that the Go packages behave the way they were designed to work. Go provides the fundamental testing capabilities through its standard library packages and tooling support. In this chapter, you will learn how to write unit tests using standard library packages and third-party packages.		Shiju Varghese	Web Development with Go	https://doi.org/10.1007/978-1-4842-1052-9_10		pp 211–249		Excluded	Excluded	new_screen			2	SpringerLink		Testing Go Applications	http://link.springer.com/chapter/10.1007/978-1-4842-1052-9_10	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
540	Behave	Testing in DevOps	DevOps can be explained by a set of principles and these principles indicate that Testing in DevOps should be looked at differently. The customer must be at the center of testing and more specialized tests must also be used. To ensure that there is continuous feedback, automation should be used as much as possible. All these tests are the responsibility of one team. To achieve this, a test engineer in DevOps must become a T-shaped engineer.	Software testing; Software quality; Test automation; Test engineer; DevOps; Agile testing	Frank Faber	The Future of Software Quality Assurance	https://doi.org/10.1007/978-3-030-29509-7_3		pp 27–38		Excluded	Excluded	new_screen			2	SpringerLink		Testing Idempotence for Infrastructure as Code	http://link.springer.com/chapter/10.1007/978-3-030-29509-7_3	Springer, Cham	nan; References; Year; Bibtex
541	Behave	Testing in Node.js	Testing allows you the peace of mind to know that the code you wrote is actually performing the operations that it was intended to do. Node.js offers a native implementation for writing some form of unit tests, and the Node.js community has created several robust libraries to aid you in your test-driven development process.	Test Suite; Application Programming Interface; Coverage Test; Code Coverage; Callback Function	Cory Gackenheimer	Node.js Recipes	https://doi.org/10.1007/978-1-4302-6059-2_11		pp 281–310		Excluded	Excluded	new_screen			2	SpringerLink		Testing in DevOps	http://link.springer.com/chapter/10.1007/978-1-4302-6059-2_11	Apress, Berkeley, CA	nan; References; Year; Bibtex
542	Behave	Testing Prototypes and Final User Interfaces Through an Ontological Perspective for Behavior-Driven Development	In a user-centered development process, prototypes evolve in iterative cycles until they meet users’ requirements and then become the final product. Every cycle gives the opportunity to revise the design and to introduce new requirements which might affect the specification of artifacts that have been set in former development phases. Testing the consistency of multiple artifacts used to develop interactive systems every time that a new requirement is introduced is a cumbersome activity, especially if it is done manually. This paper proposes an approach based on Behavior-Driven Development (BDD) to support the automated assessment of artifacts along the development process of interactive systems. The paper uses an ontology for specifying tests that can run over multiple artifacts sharing similar concepts. A case study testing Prototypes and Final User Interfaces is presented to demonstrate the feasibility of this approach in early phases of the design process, providing a continuous quality assurance of requirements, and helping clients and development teams to identify potential problems and inconsistencies before commitments with software implementation.	Automated requirements checking; Behavior-Driven Development; Ontological modeling; Prototyping; Multi-artifact testing	Thiago Rocha Silva,; Jean-Luc Hak&; Marco Winckler	International Working Conference on Human Error, Safety, and System Development	https://doi.org/10.1007/978-3-319-44902-9_7		pp 86–107		Excluded	Excluded	new_screen			2	SpringerLink		Testing in Node.js	http://link.springer.com/chapter/10.1007/978-3-319-44902-9_7	Springer, Cham	nan; References; Year; Bibtex
543	Behave	Testing Strategies in an Agile Context	Testing in an Agile context is extremely important, not only with its function to ensure quality but also to guide development efforts into the right direction. This is related to a shift in testing paradigms, with quality being viewed as a factor early on in product development, rather than a late-stage reactive activity. It also requires the application of different approaches, such as automation, to enable the flow of potentially shippable product increments. Many teams find themselves stuck into the old ways of testing, especially as they work on legacy systems. However, investment in upskilling quality experts, applying the proper tools, and changing the way testing is done can bring tremendous value and opportunities for innovation. Proper change management needs to be applied to enable teams transition successfully into an Agile mindset and new practices.	Software testing; Software quality; Agile testing; Test automation	Zornitsa Nikolova	The Future of Software Quality Assurance	https://doi.org/10.1007/978-3-030-29509-7_9		pp 111–121		Excluded	Excluded	new_screen			2	SpringerLink		Testing Strategies in an Agile Context	http://link.springer.com/chapter/10.1007/978-3-030-29509-7_9	Springer, Cham	nan; References; Year; Bibtex
544	Behave	Testing Strategies: How to Become a Better Tester?	This chapter about the general strategies to testing. We present the possible sources of testers’ inspiration, psychological aspects of software testing, and several methodological laws and tools that may be helpful in the tester’s everyday work. We also discuss the role of several methods and techniques, such as: standards and norms, error models, plans, documentation, estimation, metrics and simulations.		Adam Roman	Thinking-Driven Testing	https://doi.org/10.1007/978-3-319-73195-7_2		pp 53–97		Excluded	Excluded	new_screen			2	SpringerLink		Testing Strategies: How to Become a Better Tester?	http://link.springer.com/chapter/10.1007/978-3-319-73195-7_2	Springer, Cham	nan; Keywords; References; Year; Bibtex
545	Behave	Testing the Distributed System	In this chapter, you’ll see the importance of having good test suites in a distributed system. You’ll realize how Cucumber and structuring the test project into layers can provide a simple and powerful solution to cover an end-to-end strategy. Cucumber provides a business-friendly language to design the test cases—Gherkin—and it integrates with Java, so it’s a choice that combines perfectly with our use case.Also, the chapter pays extra attention to some details that can ease development—step parameterization and reusability, understanding how Cucumber works when instantiating tests, and how to benefit from dependency injection. And, most importantly, you’ll see how making your code testable makes everything simpler just by adding some optional logic to your services.	Dependency Injection; User John; assertThat; Microservices; Spring Boot	Moises Macero	Learn Microservices with Spring Boot	https://doi.org/10.1007/978-1-4842-3165-4_6		pp 267–314		Excluded	Excluded	new_screen			2	SpringerLink		Testing the Distributed System	http://link.springer.com/chapter/10.1007/978-1-4842-3165-4_6	Apress, Berkeley, CA	nan; References; Year; Bibtex
546	Behave	Testing the User Interface	User Interface (UI) tests allow you to test your application from the outside, just as your users would see the application. Every time you decide to run your application on the simulator or device, you are, in effect, testing the UI of your application. Since Xcode 7, Apple has provided the ability to create automated UI tests. These automated UI tests are great at finding regression defects, and used correctly can reduce the regression testing effort for your apps.		Abhishek Mishra	iOS Code Testing	https://doi.org/10.1007/978-1-4842-2689-6_13		pp 407–432		Excluded	Excluded	new_screen			2	SpringerLink		Testing the User Interface	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_13	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
547	Behave	Testing URLSession	This chapter will examine the process of applying TDD techniques to the networking layer of your application. There are various types of networking technologies available to iOS developers. This chapter will only cover networking with the URLSession class. The URLSession connection allows you to conveniently download resources over HTTP connections.		Abhishek Mishra	iOS Code Testing	https://doi.org/10.1007/978-1-4842-2689-6_7		pp 211–256		Excluded	Excluded	new_screen			2	SpringerLink		Testing URLSession	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_7	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
548	Behave	Testing Your Backbone.js Application	Testing is one of the most essential development activities that you will undertake in large-scale JavaScript applications. Within the vast JavaScript ecosystem, there are a number of options for testing applications, which means there is no longer any excuse for not testing your JavaScript code. This chapter will take a look at the leading testing frameworks available and how creating testable code will not only improve the stability of your application but lead to a cleaner architecture. This chapter also examines some of the key reasons to apply Test-Driven Development to your JavaScript code.	Test Suite; Unit Test; Testing Framework; Test Execution; Profile View	James Sugrue	Beginning Backbone.js	https://doi.org/10.1007/978-1-4302-6335-7_8		pp 151–178		Excluded	Excluded	new_screen			2	SpringerLink		Testing Your Backbone.js Application	http://link.springer.com/chapter/10.1007/978-1-4302-6335-7_8	Apress, Berkeley, CA	nan; References; Year; Bibtex
549	Behave	Testing, Deployment, and Troubleshooting	This chapter contains three small chapters in one, namely, Testing, Deployment, and Troubleshooting. They do not aim to be complete guides for these topics but to provide the essentials for those who are starting this journey and how they apply to a Vue on Rails approach.		Bryan Lim&; Richard LaFranchi	Vue on Rails	https://doi.org/10.1007/978-1-4842-5116-4_7		pp 155–182		Excluded	Excluded	new_screen			2	SpringerLink		Testing, Deployment, and Troubleshooting	http://link.springer.com/chapter/10.1007/978-1-4842-5116-4_7	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
550	Behave	Testmanagement und Softwaretest	http://link.springer.com/book/10.1007/978-3-658-25087-4		Frank Witte		http://link.springer.com/book/10.1007/978-3-658-25087-4				Excluded	Excluded	new_screen			2						
551	Behave	Thailand’s Software Startup Ecosystem	Software startups are currently very popular in Thailand, and existing information reveals an increase in the number of participants and investors in software startup businesses. Moreover, widespread events have been held to showcase the products and services these businesses have contributed. Software startups primarily develop innovations in the form of software produced from limited resources within a limited time. This software must be able to contribute to a sustainable business, and must be adjustable to each business size. Previous research indicates that both attention and emphasis must be placed on the importance of studying software startups in the form of empirical research. This will assist decision-making for those who are interested in initiating software startups and those who want to support them. Research has scarcely studied software startups in Thailand, and therefore, we are interested in Thai startups’ current situation as well as the startup ecosystem. This study clarifies that software startups in Thailand are defined as newly emerging businesses anticipated to help businesses grow quickly. Each software startup is in search of a different business model, as current software startups in Thailand have been created to help and support particular businesses. However, software startups rarely invent their own unique, exotic business models or apply advanced technologies and research in their startups.	Software startups; Software engineering; Case study	Aziz NanthaamornphongORCID:orcid.org/---&; Rattana WetprasitORCID:orcid.org/---	Fundamentals of Software Startups	https://doi.org/10.1007/978-3-030-35983-6_12		pp 195–213		Excluded	Excluded	new_screen			2	SpringerLink		Thailand’s Software Startup Ecosystem	http://link.springer.com/chapter/10.1007/978-3-030-35983-6_12	Springer, Cham	nan; References; Year; Bibtex
552	Behave	The ASMETA Approach to Safety Assurance of Software Systems	Safety-critical systems require development methods and processes that lead to provably correct systems in order to prevent catastrophic consequences due to system failure or unsafe operation. The use of models and formal analysis techniques is highly demanded both at design-time, to guarantee safety and other desired qualities already at the early stages of the system development, and at runtime, to address requirements assurance during the system operational stage.In this paper, we present the modeling features and analysis techniques supported by ASMETA (ASM mETAmodeling), a set of tools for the Abstract State Machines formal method. We show how the modeling and analysis approaches in ASMETA can be used during the design, development, and operation phases of the assurance process for safety-critical systems, and we illustrate the advantages of integrated use of tools as that provided by ASMETA.		Paolo ArcainiORCID:orcid.org/---,; Andrea BombardaORCID:orcid.org/---,; Silvia BonfantiORCID:orcid.org/---,; Angelo GargantiniORCID:orcid.org/---,; Elvinia RiccobeneORCID:orcid.org/---&; Patrizia ScandurraORCID:orcid.org/---	Logic, Computation and Rigorous Methods	https://doi.org/10.1007/978-3-030-76020-5_13		pp 215–238		Excluded	Excluded	new_screen			2	SpringerLink		The ASMETA Approach to Safety Assurance of Software Systems	http://link.springer.com/chapter/10.1007/978-3-030-76020-5_13	Springer, Cham	nan; Keywords; References; Year; Bibtex
553	Behave	The Basic Spring Boot Application	The main goal of this chapter is to introduce the functional requirements of our application and the test-driven development approach you’ll follow in this book. You’ll create a Spring Boot application by developing some basic functionality using TDD.The chapter also sets the stage for you to think in an Agile fashion, that supports the way in which the application will evolve along the book. You take some time to understand your first business requirement, split it into sub-tasks, and think about a first unit test.		Moises Macero	Learn Microservices with Spring Boot	https://doi.org/10.1007/978-1-4842-3165-4_2		pp 9–21		Excluded	Excluded	new_screen			2	SpringerLink		The Basic Spring Boot Application	http://link.springer.com/chapter/10.1007/978-1-4842-3165-4_2	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
554	Behave	The basics of simulation	Simulation is experimentation with a model. The behavior of the model imitates some salient aspect of the behavior of the system under study and the user experiments with the model to infer this behavior. This general framework has proven a powerful adjunct to learning, problem solving, design, and control. In this tutorial, we focus principally on discrete-event simulation - its underlying concepts, structure, and application.		White, K. Preston; Ingalls, Ricki G.		http://link.springer.com/chapter/10.1007/978-1-4842-2638-4_1		1087-1101	"@inproceedings{10.5555/3466184.3466308,
    author = ""White, K. Preston and Ingalls, Ricki G."",
    title = ""The basics of simulation"",
    year = ""2021"",
    isbn = ""9781728194998"",
    publisher = ""IEEE Press"",
    abstract = ""Simulation is experimentation with a model. The behavior of the model imitates some salient aspect of the behavior of the system under study and the user experiments with the model to infer this behavior. This general framework has proven a powerful adjunct to learning, problem solving, design, and control. In this tutorial, we focus principally on discrete-event simulation - its underlying concepts, structure, and application."",
    booktitle = ""Proceedings of the Winter Simulation Conference"",
    pages = ""1087-1101"",
    numpages = ""15"",
    location = ""Orlando, Florida"",
    series = ""WSC '20""
}"	Excluded	Excluded	new_screen			2	ACM		The Basics	http://link.springer.com/chapter/10.1007/978-1-4842-2638-4_1	IEEE Press	nan; Venue; Keywords; References; DOI
555	Behave	The Big Green Check Mark	All this is a long-winded and hunger-inducing way of saying that there are many elements that determine whether something as simple as a sandwich gets the thumbs up, the seal of approval, the big green check mark. Software is no different. When software is produced, particularly when produced by a team as part of a business, there are lots of ways in which the production of the software could, in the final analysis, be considered unsatisfactory.	Technical Debt; Drudge Work; Smoke Test; Edge Cases; Behavior-driven Development	Patrick Gleeson	Working with Coders	https://doi.org/10.1007/978-1-4842-2701-5_5		pp 113–138		Excluded	Excluded	new_screen			2	SpringerLink		The Big Green Check Mark	http://link.springer.com/chapter/10.1007/978-1-4842-2701-5_5	Apress, Berkeley, CA	nan; References; Year; Bibtex
556	Behave	The Design, Evolution, and Use of KernelF	KernelF is a functional language built on top of MPS. It is designed to be highly extensible and embeddable in order to support its use at the core of domain-specific languages, realising an approach we sometimes call Funclerative Programming. “Funclerative” is of course a mash-up of “functional” and “declarative” and refers to the idea of using functional programming in the small, and declarative language constructs for the larger-scale, often domain-specific, structures in a program. We have used KernelF in a wide range of languages including health and medicine, insurance contract definition, security analysis, salary calculations, smart contracts and language-definition. In this paper, I illustrate the evolution of KernelF over the last two years. I discuss requirements on the language, and how those drove design decisions. I showcase a couple of the DSLs we built on top of KernelF to explain how MPS was used to enable the necessary language modularity. I demonstrate how we have integrated the Z3 solver to verify some aspects of programs. I present the architecture we have used to use KernelF-based DSLs in safety-critical environments. I close the keynote with an outlook on how KernelF might evolve in the future, and point out a few challenges for which we don’t yet have good solutions.	Domain-specific languages; Language modularity; Functional Language; Language engineering; Meta programming	Markus Voelter	International Conference on Theory and Practice of Model Transformations	https://doi.org/10.1007/978-3-319-93317-7_1		pp 3–55		Excluded	Excluded	new_screen			2	SpringerLink		The Design, Evolution, and Use of KernelF	http://link.springer.com/chapter/10.1007/978-3-319-93317-7_1	Springer, Cham	nan; References; Year; Bibtex
557	Behave	The Distinct Trends and Transitions in the Information Technology (IT) Space	There is an overwhelming recognition that IT is the real game-changer not only for worldwide businesses but also for the total humanity. The world is investing its talents, treasures, and time on IT, and therefore, there are several noteworthy advancements and accomplishments emerging and evolving in the hot IT field. By sagaciously leveraging those praiseworthy innovations and inventions, business houses across the globe are keeping up the edge earned. All kinds of business acceleration, augmentation, and automation get done through the bevy of IT improvisations. In the recent past, there is a tectonic twist. That is, IT is being adeptly enabled to empower people. All sorts of decision-making, deals, and deeds are being facilitated by IT systems. We can safely anticipate that IT is going to be hugely people-centric hereafter. IT is being tuned for performing not only informational, commercial, and transactional services but also for context-aware, cognitive, and physical services. Humans individually and collectively are getting immensely and immeasurably benefited out of the enigmatic IT. Thus, there is a pioneering and path-breaking impact on people by various evolutions and revolutions in the IT landscape. The disruptions and transformations being brought in by IT are simply incredible. In short, all kinds of industry verticals accelerate their operations, offerings, and outputs through the consistently growing power of IT. Besides IT systems, our everyday devices, machines, instruments, equipment, utensils, wares, consumer electronics, drones, robots, etc., are adequately and adroitly enable to be distinct in their actions and reactions. Physical, mechanical, and electrical systems are IT-enabled to exhibit adaptive behavior in their activities.	Business Acceleration; deploymentDeployment; Cloud Idea; Containment Isolation; Docker Container	Pethuru Raj&; Anupama Raman	Software-Defined Cloud Centers	https://doi.org/10.1007/978-3-319-78637-7_1		pp 1–12		Excluded	Excluded	new_screen			2	SpringerLink		The Distinct Trends and Transitions in the Information Technology (IT) Space	http://link.springer.com/chapter/10.1007/978-3-319-78637-7_1	Springer, Cham	nan; References; Year; Bibtex
558	Behave	The Ecosystem: Extending React Native	If you have come this far, you can proudly say you have become a React Native developer. In this final chapter you learn how expedite your React Native development by using some very useful, stable, and popular libraries. These are designed to make your life a bit easier and help you create your apps faster. This chapter covers the following topics:		Akshat Paul&; Abhishek Nalwaya	React Native for Mobile Development	https://doi.org/10.1007/978-1-4842-4454-8_10		pp 225–232		Excluded	Excluded	new_screen			2	SpringerLink		The Ecosystem: Extending React Native	http://link.springer.com/chapter/10.1007/978-1-4842-4454-8_10	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
559	Behave	The evolution of agile software development in Brazil	http://link.springer.com/article/10.1007/s13173-013-0114-x		Claudia de O. MeloViviane SantosEduardo KatayamaHugo CorbucciRafael PrikladnickiAlfredo GoldmanFabio Kon		http://link.springer.com/article/10.1007/s13173-013-0114-x				Excluded	Excluded	new_screen			2						
560	Behave	The Goals Approach: Agile Enterprise Driven Software Development	Continuous Business Process Improvement (BPI) is necessary in order to maintain and develop the enterprise competitiveness. However, achieving a level of software development performance that matches enterprise needs in terms of producing noticeable results within small amounts of time is a persnickety task, mainly because most available methods do not deliver full software architectures that can be directly used for in-house software development without iterations between implementation and design, as produced specifications are too close to the user interface, or too close to business regulations and domain modeling. Our approach applies a method that structures business processes, business rules and domain concepts, and uses this information in order to identify user tasks (use cases) and interaction spaces, and by means of their detail, methodically specify the software architecture for a particular BPI, bridging business and software using cross-consistent concepts. We present a theoretical example, and the validation of our method.	Enterprise engineering; Software engineering; Human-Computer interaction; Enterprise architecture; Software architecture	Pedro Valente,; Thiago Silva,; Marco Winckler&; Nuno Nunes	Complexity in Information Systems Development	https://doi.org/10.1007/978-3-319-52593-8_13		pp 201–219		Excluded	Excluded	new_screen			2	SpringerLink		The Goals Approach: Agile Enterprise Driven Software Development	http://link.springer.com/chapter/10.1007/978-3-319-52593-8_13	Springer, Cham	nan; References; Year; Bibtex
561	Behave	The Goals Approach: Enterprise Model-Driven Agile Human-Centered Software Engineering	Business Process Improvement (BPI) is a key issue in the development of the enterprise competitiveness. However, achieving a level of software development performance that matches enterprise BPI needs in terms of producing noticeable results in small amounts of time requires the existence of a comprehensive and also agile Software Development Process (SDP). Quite often, SDPs do not deliver software architectures that can be directly used for in-house development, as specifications are either too close to the user interface design or too close to business rules and application domain modeling, and produce architectures that do not cope with software development concerns. In this paper we present theGoals Approach, which structures business processes to extract requirements, and methodologically details them in order to specify the user interface, the business logic and the database structures for the architecture of a BPI. Our approach aims in-house software development in small and medium enterprises.	Enterprise engineering; Software engineering; Human-Computer Interaction; Agile software development process; Software architecture	Pedro Valente,,,; Thiago Rocha Silva,; Marco Winckler&; Nuno Jardim Nunes	International Working Conference on Human Error, Safety, and System Development	https://doi.org/10.1007/978-3-319-44902-9_17		pp 261–280		Excluded	Excluded	new_screen			2	SpringerLink		The Goals Approach: Enterprise Model-Driven Agile Human-Centered Software Engineering	http://link.springer.com/chapter/10.1007/978-3-319-44902-9_17	Springer, Cham	nan; References; Year; Bibtex
562	Behave	The MVVM Architectural Pattern	Well over a billion apps have been developed for the iOS platform since its inception. Most of the early apps were rather simple and often developed by a single developer. Over the years, iOS apps have become increasingly complex pieces of software that often involve large, distributed teams of developers working in Agile environments with complex build and release pipelines.		Abhishek Mishra	iOS Code Testing	https://doi.org/10.1007/978-1-4842-2689-6_3		pp 43–60		Excluded	Excluded	new_screen			2	SpringerLink		The MVVM Architectural Pattern	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_3	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
563	Behave	The Product Backlog	One of the most important artifacts in the Scrum Framework is the Product Backlog. Like the other artifacts, its purpose is to make something transparent and clear. It is managed and maintained by the Product Owner, and its purpose is to make clear the plan for developing a product and the sequence in which the product’s features and functions are to be created.		Frederik M. Fowler	Navigating Hybrid Scrum Environments	https://doi.org/10.1007/978-1-4842-4164-6_9		pp 59–66		Excluded	Excluded	new_screen			2	SpringerLink		The Product Backlog	http://link.springer.com/chapter/10.1007/978-1-4842-4164-6_9	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
564	Behave	The Protractor Handbook	http://link.springer.com/book/10.1007/978-1-4842-7289-3		Shashank Shukla		http://link.springer.com/book/10.1007/978-1-4842-7289-3				Excluded	Excluded	new_screen			2						
565	Behave	The State of Agile Software Development in the Czech Republic: Preliminary Findings Indicate the Dominance of “Abridged” Scrum	This paper presents preliminary results from a survey focused on the state of agile method adoption in the Czech Republic. To this end, an initial survey sample (N = 120) was analyzed. Scrum is the most frequently used agile software development method, reported by 46.7% of respondents as the agile method of choice. However, the results indicate that Scrum seems to be introduced through cherry-picking of those practices that are quite easy to implement. Specifically, the only widely-spread Scrum practice is the maintenance of Product backlog. To the contrary, the teams are rarely cross-functional and the Scrum master role frequently absents. This suggests that in many organizations, Scrum might be invoked due to being a valuable “brand name”, rather than due to professionals’ subscribing to core Scrum values and assumptions. Our results contribute to the body of empirical knowledge on the state of agile software development initiatives. Our findings confirm the theoretical proposition that in the real world, the implementation of software development methods is often patchy and rarely done “by the book”.	Software project management; Agile methods; Agile practices; Scrum practices; Scrum variations; Agile method tailoring; Hybrid methods	Michal DolezelORCID:orcid.org/---,; Alena BuchalcevovaORCID:orcid.org/---&; Michal Mencik	International Conference on Research and Practical Issues of Enterprise Information Systems	https://doi.org/10.1007/978-3-030-37632-1_4		pp 43–54		Excluded	Excluded	new_screen			2	SpringerLink		The State of Agile Software Development in the Czech Republic: Preliminary Findings Indicate the Dominance of “Abridged” Scrum	http://link.springer.com/chapter/10.1007/978-3-030-37632-1_4	Springer, Cham	nan; References; Year; Bibtex
566	Behave	The Study of the Effectiveness of the Secure Software Development Life-Cycle Models in IT Project Management	Software security is an important and a prevalent element in today’s society. The System Development Life-Cycle (SDLC) process that is currently used for most of software development does not address any security components until after the software is developed. The Secure Software Development Life-Cycle (SSDLC) is similar to the SDLC but includes security components into the phases. There have been many models proposed that are primary modified from preexisting SSDLC models. A study was conducted to survey different SSDLC models and their effectiveness. The authors first identified four popular SSDLC models in the IT industry, and then analyzed their common characteristics to derived four sets of Criteria for comparison. These criteria are: Focus Areas of Application, Implementation of model, Security Implementations and Enhancements, and Security training and Staff. The comparison results demonstrate that the Rastogi and Jones model is an effective one for being used for many IT projects. However, it is worthy to mentioned that one specific model cannot be used for all types of IT projects because IT projects are different.	System Development Life-cycle (SDLC); Secure Software Development Life-cycle (SSDLC); Security; IT Project Management	Saniora R. Duclervil&; Jing-Chiou Liou	16th International Conference on Information Technology-New Generations (ITNG 2019)	https://doi.org/10.1007/978-3-030-14070-0_14		pp 91–96		Excluded	Excluded	new_screen			2	SpringerLink		The Study of the Effectiveness of the Secure Software Development Life-Cycle Models in IT Project Management	http://link.springer.com/chapter/10.1007/978-3-030-14070-0_14	Springer, Cham	nan; References; Year; Bibtex
567	Behave	To Build a Fire	Autumn arrives, and the team is celebrating a year into their journey. They can claim some real victories. They’ve really stepped up their game with monitoring and gathering metrics; just in the past few months, they’ve investigated some cool new SaaS-based monitoring services, which has improved their visibility into their application’s actual performance in the field. Better yet, they’re actually caring about the right things; showing business-facing metrics like their order processing rate is helping everyone visualize the part they’re playing in a very long delivery chain. But they are still lacking executive support they need; how can they get the protection to finish the next step of their journey?		Dave Harrison&; Knox Lively	Achieving DevOps	https://doi.org/10.1007/978-1-4842-4388-6_7		pp 311–367		Excluded	Excluded	new_screen			2	SpringerLink		To Build a Fire	http://link.springer.com/chapter/10.1007/978-1-4842-4388-6_7	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
568	Behave	Towards a Taxonomy of Microservices Architectures	The microservices architectural style is gaining more and more momentum for the development of applications as suites of small, autonomous, and conversational services, which are then easy to understand, deploy and scale. However, the proliferation of approaches leveraging microservices calls for a systematic way of analyzing and assessing them as a completely new ecosystem: the first cloud-native architectural style. This paper defines a preliminary analysis framework in the form of a taxonomy of concepts, encompassing the whole microservices lifecycle, as well as organizational aspects. This framework is necessary to enable effective exploration, understanding, assessing, comparing, and selecting microservice-based models, languages, techniques, platforms, and tools. Then, we analyze state of the art approaches related to microservices using this taxonomy to provide a holistic perspective of available solutions.	Microservice Architecture; Preliminary Analytical Framework; Resilience Patterns; Open Cloud Computing Interface (OCCI); OpenAPI Specification	Martin Garriga	International Conference on Software Engineering and Formal Methods	https://doi.org/10.1007/978-3-319-74781-1_15		pp 203–218		Excluded	Excluded	new_screen			2	SpringerLink		Towards a Taxonomy of Microservices Architectures	http://link.springer.com/chapter/10.1007/978-3-319-74781-1_15	Springer, Cham	nan; References; Year; Bibtex
569	Behave	Towards a Verification-Driven Iterative Development of Software for Safety-Critical Cyber-Physical Systems	http://link.springer.com/article/10.1186/s13174-021-00132-z		Marjan SirjaniLuciana ProvenzanoSara Abbaspour AsadollahMahshid Helali MoghadamMehrdad Saadatmand		http://link.springer.com/article/10.1186/s13174-021-00132-z				Excluded	Excluded	new_screen			2						
570	Behave	Towards an Executable Methodology for the Formalization of Legal Texts	A methodology for the formalization of legal texts is presented. This methodology is based on features of the NAI Suite, a recently developed formalization environment for legal texts. The ability of the tool to execute queries is used in order to drive a correct formalization until all queries are validated. The approach is studied on a fragment of theSmoking Prohibition (Children in Motor Vehicles) (Scotland) Act 2016of the Scottish Parliament.	Legal reasoning; Deontic logic; Automated reasoning	Tomer LibalORCID:orcid.org/---&; Alexander SteenORCID:orcid.org/---	International Conference on Logic and Argumentation	https://doi.org/10.1007/978-3-030-44638-3_10		pp 151–165		Excluded	Excluded	new_screen			2	SpringerLink		Towards an Executable Methodology for the Formalization of Legal Texts	http://link.springer.com/chapter/10.1007/978-3-030-44638-3_10	Springer, Cham	nan; References; Year; Bibtex
571	Behave	Towards Automated UI-Tests for Sensor-Based Mobile Applications	Mobile devices changed human-computer interaction, caused the need for specialized software engineering methods and created new business opportunities. The mobile app market is highly competitive and software developers need to maintain high software quality standards for long-lasting economic success. While powerful software development kits support developers in creating mobile applications, testing them is still cumbersome, time-consuming and error-prone. Especially interaction methods depending on sensor input like device motion gestures prevent automated UI testing – developers and testers are forced to manually test all different aspects. We present an approach to integrate sensor information into user acceptance tests and use a sensor simulation engine to enable automatic test case execution for mobile applications.		Tobias Griebe,; Marc Hesenius&; Volker Gruhn	International Conference on Intelligent Software Methodologies, Tools, and Techniques	https://doi.org/10.1007/978-3-319-22689-7_1		pp 3–17		Excluded	Excluded	new_screen			2	SpringerLink		Towards Automated UI-Tests for Sensor-Based Mobile Applications	http://link.springer.com/chapter/10.1007/978-3-319-22689-7_1	Springer, Cham	nan; Keywords; References; Year; Bibtex
572	Behave	Towards Establishing Mass Customization Methods for Cloud-Compliant Services	This paper proposes a chain of service models assembled by design, implementation and operation data. To obtain both economy of scale and economy of scope, appropriate chains are required for producing cloud-compliant services. By specifying a target domain and distributing models’ attributes into commonality or variability, a chain, which consists of necessary and sufficient models with utmost customizable interfaces, can be determined decisively. A field trial elicits representative chains of models, and shows that the chains, i.e. lifecycle patterns, can be used as templates to develop new services on mass customization basis and tailored to meet clients’ varied demands.	Mass Customization; Application Lifecycle Management; Product Line Engineering; Service Factory	Shigeru Hosono&; Yoshiki Shimomura	The Philosopher's Stone for Sustainability	https://doi.org/10.1007/978-3-642-32847-3_75		pp 447–452		Excluded	Excluded	new_screen			2	SpringerLink		Towards Establishing Mass Customization Methods for Cloud-Compliant Services	http://link.springer.com/chapter/10.1007/978-3-642-32847-3_75	Springer, Berlin, Heidelberg	nan; References; Year; Bibtex
573	Behave	Towards More Flexible Enterprise Information Systems	The aim of this paper is to present the software development techniques used to build the EIS Patterns development framework, which is a testbed for a series of techniques that aim at giving more flexibility to EIS in general. Some of these techniques are customizations or extensions of practices created by the agile software development movement, while others represent new proposals. This paper also aims at helping promoting more discussion around the EIS development questions, since most of research papers in EIS area focus on deployment, IT, or business related issues, leaving the discussion on development techniques ill-treated.	Enterprise Information Systems; Domain Specific Languages; Design Patterns; Statechart Diagrams; Natural Language Processing	Rogerio Atem de Carvalho,&; Björn Johansson	Enterprise Information Systems of the Future	https://doi.org/10.1007/978-3-642-36611-6_12		pp 157–164		Excluded	Excluded	new_screen			2	SpringerLink		Towards More Flexible Enterprise Information Systems	http://link.springer.com/chapter/10.1007/978-3-642-36611-6_12	Springer, Berlin, Heidelberg	nan; References; Year; Bibtex
574	Behave	Towards Transparent Legal Formalization	A key challenge in making a transparent formalization of a legal text is the dependency on two domain experts. While a legal expert is needed in order to interpret the legal text, a logician or a programmer is needed for encoding it into a program or a formula. Various existing methods are trying to solve this challenge by improving or automating the communication between the two experts. In this paper, we follow a different direction and attempt to eliminate the dependency on the target domain expert. This is achieved by inverting the translation back into the original text. By skipping over the logical translation, a legal expert can now both interpret and evaluate a translation.	Legal knowledge base; Annotation editor; Formal representation	Tomer LibalORCID:orcid.org/---,&; Tereza Novotná	International Workshop on Explainable, Transparent Autonomous Agents and Multi-Agent Systems	https://doi.org/10.1007/978-3-030-82017-6_18		pp 296–313		Excluded	Excluded	new_screen			2	SpringerLink		Towards Transparent Legal Formalization	http://link.springer.com/chapter/10.1007/978-3-030-82017-6_18	Springer, Cham	nan; References; Year; Bibtex
575	Behave	Towards User-Friendly Projectional Editors	Today’s challenges for language development include language extension and composition, as well as the use of diverse notations. A promising approach is projectional editing, a technique to directly manipulate the abstract syntax tree of a program, without relying on parsers. Its potential lies in the ability to combine diverse notational styles – such as text, symbols, tables, and graphics – and the support for a wide range of composition techniques. However, projectional editing is often perceived as problematic for developers. Expressed drawbacks include the unfamiliar editing experience and challenges in the integration with existing infrastructure. In this paper we investigate the usability of projectional editors. We systematically identify usability issues resulting from the architecture. We use JetBrains Meta Programming System (MPS) as a case study. The case study discusses the concepts that MPS incorporates to address the identified issues, evaluates effectiveness of these concepts by surveying professional developers, and reports industrial experiences from realizing large-scale systems. Our results show that the benefits of flexible language composition and diverse notations come at the cost of serious usability issues – which, however, can be effectively mitigated with facilities that emulate editing experience of parser-based editors.		Markus Voelter,; Janet Siegmund,; Thorsten Berger&; Bernd Kolb	International Conference on Software Language Engineering	https://doi.org/10.1007/978-3-319-11245-9_3		pp 41–61		Excluded	Excluded	new_screen			2	SpringerLink		Towards User-Friendly Projectional Editors	http://link.springer.com/chapter/10.1007/978-3-319-11245-9_3	Springer, Cham	nan; Keywords; References; Year; Bibtex
576	Behave	Transitioning Towards Continuous Experimentation in a Large Software Product and Service Development Organisation – A Case Study	Context:Companies need capabilities to evaluate the customer value of software-intensive products and services. One way of systematically acquiring data on customer value is running continuous experiments as part of the overall development process.Objective:This paper investigates the first steps of transitioning towards continuous experimentation in a large company, including the challenges faced.Method:We conduct a single-case study using participant observation, interviews, and qualitative analysis of the collected data.Results:Results show that continuous experimentation was well received by the practitioners and practising experimentation helped them to enhance understanding of their product value and user needs. Although the complexities of a large multi-stakeholder business-to-business (B2B) environment presented several challenges such as inaccessible users, it was possible to address impediments and integrate an experiment in an ongoing development project.Conclusion:Developing the capability for continuous experimentation in large organisations is a learning process which can be supported by a systematic introduction approach with the guidance of experts. We gained experience by introducing the approach on a small scale in a large organisation, and one of the major steps for future work is to understand how this can be scaled up to the whole development organisation.	Continuous experimentation; Experiment-driven software development; Product management; Lean startup; Customer development; Customer involvement; Organisational transition; Agile software development; Case study	Sezin Gizem Yaman,; Fabian Fagerholm,; Myriam Munezero,; Jürgen Münch,,; Mika Aaltola,; Christina Palmu&; Tomi Männistö	International Conference on Product-Focused Software Process Improvement	https://doi.org/10.1007/978-3-319-49094-6_22		pp 344–359		Excluded	Excluded	new_screen			2	SpringerLink		Transitioning Towards Continuous Experimentation in a Large Software Product and Service Development Organisation – A Case Study	http://link.springer.com/chapter/10.1007/978-3-319-49094-6_22	Springer, Cham	nan; References; Year; Bibtex
577	Behave	TSTL: the template scripting testing language	http://link.springer.com/article/10.1007/s10009-016-0445-y		Josie HolmesAlex GroceJervis PintoPranjal MittalPooria AzimiKevin KellarJames O’Brien		http://link.springer.com/article/10.1007/s10009-016-0445-y				Excluded	Excluded	new_screen			2						
578	Behave	Understanding Core JUnit 5	In the first chapter, we learned the importance of test-driven development (TDD). We also discussed the pivotal role of unit testing. But before we move on to building an application using JUnit 5, it is important to understand its core concepts.		Shekhar Gulati&; Rahul Sharma	Java Unit Testing with JUnit 5	https://doi.org/10.1007/978-1-4842-3015-2_2		pp 25–44		Excluded	Excluded	new_screen			2	SpringerLink		Understanding Core JUnit 5	http://link.springer.com/chapter/10.1007/978-1-4842-3015-2_2	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
579	Behave	Understanding Services with Reactive Programming	Services are an important building block of any application. Usually, services are the entry point to retrieving data from some kind of provider as well as to updating it, when this option is available.	Search Method; Service Class; Media Item; Duration Property; Player Property	Oren Farhi	Reactive Programming with Angular and ngrx	https://doi.org/10.1007/978-1-4842-2620-9_5		pp 73–98		Excluded	Excluded	new_screen			2	SpringerLink		Understanding Services with Reactive Programming	http://link.springer.com/chapter/10.1007/978-1-4842-2620-9_5	Apress, Berkeley, CA	nan; References; Year; Bibtex
580	Behave	Engaging Developers in Exploratory Unit Testing through Gamification	Exploratory testing, known for its flexibility and ability to uncover unexpected issues, often faces challenges in maintaining systematic coverage and producing reproducible results. To address these challenges, we investigate whether gamification of testing directly in the Integrated Development Environment (IDE) can guide exploratory testing. We therefore show challenges and quests generated by the Gamekins gamification system to make testing more engaging and seamlessly blend it with regular coding tasks. In a 60-minute experiment, we evaluated Gamekins' impact on test suite quality and bug detection. The results show that participants actively interacted with the tool, achieving nearly 90\% line coverage and detecting 11 out of 14 bugs. Additionally, participants reported enjoying the experience, indicating that gamification can enhance developer participation in testing and improve software quality.	Exploratory Testing;  Gamification;  IDE;  IntelliJ;  Software Testing	Straubinger, Philipp; Fraser, Gordon		https://doi.org/10.1145/3678869.3685683		2-9	"@inproceedings{10.1145/3678869.3685683,
    author = ""Straubinger, Philipp and Fraser, Gordon"",
    title = ""Engaging Developers in Exploratory Unit Testing through Gamification"",
    year = ""2024"",
    isbn = ""9798400711138"",
    publisher = ""Association for Computing Machinery"",
    address = ""New York, NY, USA"",
    url = ""https://doi.org/10.1145/3678869.3685683"",
    doi = ""10.1145/3678869.3685683"",
    abstract = ""Exploratory testing, known for its flexibility and ability to uncover unexpected issues, often faces challenges in maintaining systematic coverage and producing reproducible results. To address these challenges, we investigate whether gamification of testing directly in the Integrated Development Environment (IDE) can guide exploratory testing. We therefore show challenges and quests generated by the Gamekins gamification system to make testing more engaging and seamlessly blend it with regular coding tasks. In a 60-minute experiment, we evaluated Gamekins' impact on test suite quality and bug detection. The results show that participants actively interacted with the tool, achieving nearly 90\\% line coverage and detecting 11 out of 14 bugs. Additionally, participants reported enjoying the experience, indicating that gamification can enhance developer participation in testing and improve software quality."",
    booktitle = ""Proceedings of the 3rd ACM International Workshop on Gamification in Software Development, Verification, and Validation"",
    pages = ""2-9"",
    numpages = ""8"",
    keywords = ""Exploratory Testing, Gamification, IDE, IntelliJ, Software Testing"",
    location = ""Vienna, Austria"",
    series = ""Gamify 2024""
}"	Excluded	Excluded	new_screen			2	ACM		Unit Testing	http://link.springer.com/chapter/10.1007/978-1-4302-3163-9_7	Association for Computing Machinery	nan; Venue; References
581	Behave	Unit Testing and Integration Testing	It is very likely you have already written unit tests for your projects and thus are familiar with the concepts, frameworks, and steps involved in writing unit tests. This chapter therefore mainly deals with how to apply those skills to the effective writing of unit tests for your Web API. As you will see, unit testing is where you start, not where you finish.	Unit Test; Integration Test; Feature File; Controller Context; Public Class	Tugberk Ugurlu,; Alexander Zeitler&; Ali Kheyrollahi	Pro ASP.NET Web API	https://doi.org/10.1007/978-1-4302-4726-5_15		pp 431–462		Excluded	Excluded	new_screen			2	SpringerLink		Unit Testing and Integration Testing	http://link.springer.com/chapter/10.1007/978-1-4302-4726-5_15	Apress, Berkeley, CA	nan; References; Year; Bibtex
582	Behave	Unit Tests and TDD	While both acceptance-test-driven development (ATDD) and test-driven development (TDD) are methodologies that advocate writing the tests before the code, ATDD (or BDD) is usually considered to lend itself better to bigger test scopes and to scenarios that describe how the users use the system, while TDD is considered to lend itself more specifically to unit tests, which uses the smallest test scope (of a single class or even a method), and therefore tests more technical details. For that reason, unit tests and TDD are considered practices that are done directly by the same developer that implements the code under test (CUT). While toward the end of this chapter we’ll question the distinction between TDD and ATDD, we first need to understand more about unit tests and TDD in general.		Arnon Axelrod	Complete Guide to Test Automation	https://doi.org/10.1007/978-1-4842-3832-5_17		pp 395–424		Excluded	Excluded	new_screen			2	SpringerLink		Unit Tests and TDD	http://link.springer.com/chapter/10.1007/978-1-4842-3832-5_17	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
583	Behave	Unity Application Testing Automation with Appium and Image Recognition	This work is dedicated to the problem of integrating simple functional tests (smoke tests) into the automated continuous integration pipeline. While functional testing is typically performed manually by the QA staff members, there is a large number of scenarios that can be automated, and readily available instruments, such as Appium and Calabash, designed for this task. Automated smoke testing is especially challenging for the applications with nonstandard GUI, such as games made with Unity. The only viable option in this case is to analyze screen content as a flat image and identify GUI elements with pattern matching algorithms. This approach is not novel, but its practical applicability and limitations are rarely discussed. We consider a case study of a mobile tennis game project, developed in Unity and covered with a suite of Appium-supported functional tests. We show how image matching capabilities of OpenCV library can be used in Appium tests to build a reliable automated QA pipeline.	GUI; Testing; Computer game; Automation; Non-native; Smoke test; OpenCV; Unity; Appium	Maxim Mozgovoy&; Evgeny Pyshkin	International Conference on Tools and Methods for Program Analysis	https://doi.org/10.1007/978-3-319-71734-0_12		pp 139–150		Excluded	Excluded	new_screen			2	SpringerLink		Unity Application Testing Automation with Appium and Image Recognition	http://link.springer.com/chapter/10.1007/978-3-319-71734-0_12	Springer, Cham	nan; References; Year; Bibtex
584	Behave	Use, potential, and showstoppers of models in automotive requirements engineering	http://link.springer.com/article/10.1007/s10270-018-0683-4		Grischa LiebelMatthias TichyEric Knauss		http://link.springer.com/article/10.1007/s10270-018-0683-4				Excluded	Excluded	new_screen			2						
585	Behave	Useful RSpec Tools	RSpec is a very feature-rich library. In this chapter, you learn about the most frequently used features (Figure 5-1), and you try to apply them to a real Ruby application. Also, you will be requested to develop a Ruby class and test cover it with RSpec.		Panos Matsinopoulos	Practical Test Automation	https://doi.org/10.1007/978-1-4842-6141-5_5		pp 159–198		Excluded	Excluded	new_screen			2	SpringerLink		Useful RSpec Tools	http://link.springer.com/chapter/10.1007/978-1-4842-6141-5_5	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
586	Behave	User Interface Design	As we are heading toward an open-source digital experience platform, DXP’s provide collaborative user interface. This chapter provides DXP user interface (UI) concepts and shows how to develop intuitive and interactive UI designs. In this chapter we look at:		Shailesh Kumar Shivakumar&; Sourabhh Sethii	Building Digital Experience Platforms	https://doi.org/10.1007/978-1-4842-4303-9_4		pp 119–147		Excluded	Excluded	new_screen			2	SpringerLink		User Interface Design	http://link.springer.com/chapter/10.1007/978-1-4842-4303-9_4	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
587	Behave	Using Data Integration for Security Testing	The explosion of digitisation makes a plethora of security data publicly available for developers. These numerous (often complex) documents expose them to the difficulty of choosing the most appropriate solution for securing their applications. We propose in this paper a method based upon data acquisition and integration, which assists developers in the Threat modelling stage and in the security test case execution. The method firstly helps devise Attack Defense Trees by means of a data-store. These trees show attacks, steps and defenses given under the form of security patterns, which are re-usable solutions to design more secure applications. These trees are then used for the test case generation. The data-store integrates test case stubs, which make this generation easier and developers more efficient. We evaluate our approach on 24 participants and show encouraging results on the use of data integration in software engineering.	Security; Security patterns; Attack Defense Trees; Test case generation	Sébastien Salva&; Loukmen Regainia	IFIP International Conference on Testing Software and Systems	https://doi.org/10.1007/978-3-319-67549-7_11		pp 178–194		Excluded	Excluded	new_screen			2	SpringerLink		Using Agile Testing in an Academic Health System Case Study	http://link.springer.com/chapter/10.1007/978-3-319-67549-7_11	Springer, Cham	nan; References; Year; Bibtex
588	Behave	Vorgehensmodelle	Im vorherigen Kapitel wurde gezeigt, dass es generell wichtig ist, die Vorgehensweisen zu beschreiben, damit die Zusammenarbeit in großen Unternehmen funktioniert. Daraus leitet sich für die Software-Entwicklung die Frage ab, wie hier die beste Vorgehensweise aussieht.Diese Frage wurde und wird von Experten heftig diskutiert. Die daraus gewonnenen Erkenntnisse lassen sich wie folgt zusammenfassen und werden in diesem Kapitel konkretisiert:Es gibt einzelne Teilprozesse, die typischerweise in jedem Software-Projekt vor-kommen, dies sind: Anforderungsanalyse, Design, Implementierung sowie Test und Integration. All diese Prozesse werden von Qualitätssicherungsmaßnahmen begleitet.Die Bedeutung dieser Teilprozesse hängt von sehr vielen Faktoren ab, wichtige Beispiele sind: Größe des Projektes, Erfahrungen des Projektteams mit vergleich-baren Aufgaben und besondere Qualitätsanforderungen z. B. bei Software, die mit für Menschenleben verantwortlich ist.Es gibt Prozesse, die für die Unterstützung der Software-Entwicklung wichtig sind, die sich z. B. mit der Bereitstellung der richtigen Entwicklungsumgebung beschäftigen.Die Zusammenhänge zwischen den Teilprozessen und ihre individuellen Ausprägungen sind in den existierenden Prozessmodellen sehr unterschiedlich.		Stephan Kleuker	Grundkurs Software-Engineering mit UML	https://doi.org/10.1007/978-3-658-19969-2_3		pp 25–54		Excluded	Excluded	new_screen			2	SpringerLink		Using Data Integration for Security Testing	http://link.springer.com/chapter/10.1007/978-3-658-19969-2_3	Springer Vieweg, Wiesbaden	nan; Keywords; References; Year; Bibtex
589	Behave	Vorgehensmodelle in der Softwareentwicklung	Die Entwicklung von Software erfolgt im Rahmen von Projekten. Projekte benötigten eine angemessene Vorgehensweise. Wir sprechen von Vorgehensmodellen. Diese beschreiben die Aufbauorganisation sowie die Ablauforganisation eines Projektes. In der Aufbauorganisation wird die Teamstruktur festgelegt und in der Ablauforganisation der Prozess für die einzelnen Schritte zur Durchführung der Entwicklung. Darüber hinaus sind geeignete Methoden für die Durchführung der geplanten Arbeitsschritte und zur Erarbeitung der Zwischenergebnisse, den Artefakten, zu wählen. Der Zusammenhang zwischen den Artefakten wird in einem sogenannten Artefaktmodell festgelegt. Wesentliche Artefakte sind der Programmcode für das Softwaresystem, aber auch die Beschreibung der Anforderungen an das Softwaresystem, seine Architektur, seiner Qualitätseigenschaften oder der zu verwendenden Testfälle. Die Wahl des Vorgehensmodells bestimmt in weiten Teilen wesentliche Faktoren der Softwareentwicklung wie die Kosten, den Zeitaufwand und die erreichte Qualität. Vorgehensmodelle sind ein wesentliches Bindeglied zwischen Fragen der Organisation und des Managements und der technischen Durchführung von Softwareprojekten. Dieses Kapitel führt die grundlegenden Vorgehensmodelle und Rollen in Projekten ein und erläutert traditionelle und agile Vorgehensmodelle im Kontext der Softwareentwicklung.		Manfred Broy&; Marco Kuhrmann	Einführung in die Softwaretechnik	https://doi.org/10.1007/978-3-662-50263-1_3		pp 83–124		Excluded	Excluded	new_screen			2	SpringerLink		Using language workbenches and domain-specific languages for safety-critical software development	http://link.springer.com/chapter/10.1007/978-3-662-50263-1_3	Springer Vieweg, Berlin, Heidelberg	nan; Keywords; References; Year; Bibtex
590	Behave	Web Testing Practices	Testing a web application requires not only testing the site itself, but also looking at the various application metrics at every layer of the stack. It’s like building an aircraft: each part of the aircraft has to be engineered and tested for safety before it is made a part of the whole. Once each subsystem has been developed and tested, they can all be assembled into the finished product for a test flight. With such a complex system, it only makes sense to be sure you can trust the individual parts before you assume the finished product will get you off the ground.	Sustained Load; Content Delivery Network; Application Metrics; Page Load Time; Quality Assurance Engineer	Matthew Sacks	Pro Website Development and Operations	https://doi.org/10.1007/978-1-4302-3970-3_3		pp 27–43		Excluded	Excluded	new_screen			2	SpringerLink		Web Testing Practices	http://link.springer.com/chapter/10.1007/978-1-4302-3970-3_3	Apress, Berkeley, CA	nan; References; Year; Bibtex
591	Behave	What Do They Do All Day?	We’re going to change gears. Having spent a couple of chapters looking at the management of software development, we’re now going to take a closer look at software development itself, and the processes that involves.		Patrick Gleeson	Working with Coders	https://doi.org/10.1007/978-1-4842-2701-5_4		pp 73–111		Excluded	Excluded	new_screen			2	SpringerLink		What Do They Do All Day?	http://link.springer.com/chapter/10.1007/978-1-4842-2701-5_4	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
592	Behave	What Is Unit Testing?	Unit testing allows you to test your software in isolation.		Rādhārādhya Dāsa	Learn CakePHP	https://doi.org/10.1007/978-1-4842-1212-7_2		pp 8–13		Excluded	Excluded	new_screen			2	SpringerLink		What Is Unit Testing?	http://link.springer.com/chapter/10.1007/978-1-4842-1212-7_2	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
593	Behave	What your plug-in test suites really test: an integration perspective on test suite understanding	http://link.springer.com/article/10.1007/s10664-012-9235-7		Michaela GreilerArie van Deursen		http://link.springer.com/article/10.1007/s10664-012-9235-7				Excluded	Excluded	new_screen			2						
594	Behave	What’s the Big Idea?	ASP.NET MVC is a web development framework from Microsoft that combines the effectiveness and tidiness of model-view-controller (MVC) architecture, the most up-to-date ideas and techniques from agile development, and the best parts of the existing ASP.NET platform. It’s a complete alternative to traditional ASP.NET Web Forms, delivering considerable advantages for all but the most trivial of web development projects.	Unit Testing; Agile Development; Common Gateway Interface; Agile Methodology; Independent Software Vendor	Steven Sanderson	Pro ASP.NET MVC 2 Framework	https://doi.org/10.1007/978-1-4302-2887-5_1		pp 3–14		Excluded	Excluded	new_screen			2	SpringerLink		What’s Ahead for You and Scrum?	http://link.springer.com/chapter/10.1007/978-1-4302-2887-5_1	Apress	nan; References; Year; Bibtex
595	Behave	Why Test-Driven Development Is a Must for Code Quality	Recently, Amazon claimed that it puts a new change into its production system every 1.59 seconds with no risk at all. How can this possibly be true? It’s all to do with test-driven development (hereafter TDD).		Paul David Hardy	Improving the Quality of ABAP Code	https://doi.org/10.1007/978-1-4842-6711-0_2		pp 55–111		Excluded	Excluded	new_screen			2	SpringerLink		What’s the Big Idea?	http://link.springer.com/chapter/10.1007/978-1-4842-6711-0_2	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
596	Behave	Wie E-Learning für Theologen in Afrika zur Erreichung derSustainable Development Goalsbeitragen kann	DieSustainable Development Goals(SDGs) einigen universelle Ziele. Diese wiegen schwer, während sie keinerlei ethische Anleitung bieten. Eine Möglichkeit, diese Leere zu füllen, ist, sie mit einem glaubensbasierten Narrativ zu erzählen. Wir präsentieren unseren Ansatz zum „Ownership-inspired Behavior-driven Development“ als eine Strategie für eine E-Learning-Governance für Länder des Globalen Südens und führen eine Android App ein, um E-Learning basierend auf den SDGs innerhalb theologischer Lehre auch in abgelegenen Regionen Afrikas zu ermöglichen. Basierend auf einem stufenförmigen Curriculum für die Ausbildung zukünftiger Kirchenführer_innen hat die britisch-dänische „Faith-based Organization“ (FBO) Relay Trust ein theoretisches Framework entworfen, das den Transfer von einer hierarchischen Governance-Struktur, die sich in vielen afrikanischen Ländern findet, in ein dynamisches E-Learning-Netzwerk ermöglicht.		Judith Gottschalk&; Nicolai Winther-Nielsen	Nachhaltigkeit in der Lehre	https://doi.org/10.1007/978-3-662-56386-1_9		pp 145–160		Excluded	Excluded	new_screen			2	SpringerLink		Why Test-Driven Development Is a Must for Code Quality	http://link.springer.com/chapter/10.1007/978-3-662-56386-1_9	Springer Spektrum, Berlin, Heidelberg	nan; Keywords; References; Year; Bibtex
597	Behave	Windows Server-Administration mit PowerShell 5.1	http://link.springer.com/book/10.1007/978-3-658-17666-2		Peter Monadjemi		http://link.springer.com/book/10.1007/978-3-658-17666-2				Excluded	Excluded	new_screen			2						
598	Behave	Secure Generic Remote Workflow Execution with TEEs	In scientific environments, the frequent need to process substantial volumes of data poses a common challenge. Individuals tasked with executing these computations frequently encounter a deficit in local computational resources, leading them to opt for the facilities of a Cloud Service Provider (CSP) for data processing. However, the data subjected to these calculations may be subject to confidentiality constraints. This paper introduces a proof-of-concept framework that leverages Gramine LibOS and Intel SGX, enabling the protection of generic remote workflow computations through SGX enclaves as Trusted Execution Environments (TEEs). The framework entails the delineation of user and CSP behavior and has been implemented using Bash scripts. Furthermore, an infrastructure has been designed for the Data Center Attestation Primitives (DCAP) remote attestation mechanism, wherein the user gains trust in the proper instantiation of the enclave within the CSP. To assess the framework efficacy, it has been tested on two distinct workflows, one trivial and the other involving real-world bioinformatics applications for processing DNA data. The performance study revealed that the framework incurred an acceptable overhead, ranging from a factor of x1.4 to x1.8 compared to unsafe execution practice.	trusted execution environment;  workflow;  Intel SGX;  gramine;  privacy-preserving;  confidential computing	Brescia, Lorenzo; Aldinucci, Marco		https://doi.org/10.1145/3642978.3652834		8-13	"@inproceedings{10.1145/3642978.3652834,
    author = ""Brescia, Lorenzo and Aldinucci, Marco"",
    title = ""Secure Generic Remote Workflow Execution with TEEs"",
    year = ""2024"",
    isbn = ""9798400705465"",
    publisher = ""Association for Computing Machinery"",
    address = ""New York, NY, USA"",
    url = ""https://doi.org/10.1145/3642978.3652834"",
    doi = ""10.1145/3642978.3652834"",
    abstract = ""In scientific environments, the frequent need to process substantial volumes of data poses a common challenge. Individuals tasked with executing these computations frequently encounter a deficit in local computational resources, leading them to opt for the facilities of a Cloud Service Provider (CSP) for data processing. However, the data subjected to these calculations may be subject to confidentiality constraints. This paper introduces a proof-of-concept framework that leverages Gramine LibOS and Intel SGX, enabling the protection of generic remote workflow computations through SGX enclaves as Trusted Execution Environments (TEEs). The framework entails the delineation of user and CSP behavior and has been implemented using Bash scripts. Furthermore, an infrastructure has been designed for the Data Center Attestation Primitives (DCAP) remote attestation mechanism, wherein the user gains trust in the proper instantiation of the enclave within the CSP. To assess the framework efficacy, it has been tested on two distinct workflows, one trivial and the other involving real-world bioinformatics applications for processing DNA data. The performance study revealed that the framework incurred an acceptable overhead, ranging from a factor of x1.4 to x1.8 compared to unsafe execution practice."",
    booktitle = ""Proceedings of the 2nd Workshop on Workflows in Distributed Environments"",
    pages = ""8-13"",
    numpages = ""6"",
    keywords = ""trusted execution environment, workflow, Intel SGX, gramine, privacy-preserving, confidential computing"",
    location = ""Athens, Greece"",
    series = ""WiDE '24""
}"	Excluded	Excluded	new_screen			2	ACM		Workflow	http://link.springer.com/chapter/10.1007/978-1-4302-6098-1_8	Association for Computing Machinery	nan; Venue; References
599	Behave	Working with Legacy Code	If you have been for a few years, chances are that you have been brought on to add new features to an existing app with a large code base that has been built over a few years and has been worked on by dozens of developers, most of whom have moved on to other projects.	Legal Code; BankAccount Class; Vigilance Control; NSData; EmailAddress	Abhishek Mishra	iOS Code Testing	https://doi.org/10.1007/978-1-4842-2689-6_8		pp 257–282		Excluded	Excluded	new_screen			2	SpringerLink		Working with Legacy Code	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_8	Apress, Berkeley, CA	nan; References; Year; Bibtex
600	Behave	Writing Your First Set of Unit Tests with Xcode	In this chapter you will download Xcode and learn to use it to create a simple app using test-driven development techniques. The app you will build will use the Single View Application template and allow the user to create different types of cookies by tapping on buttons in the user interface. The app will present a running total of each type of cookie created as well as the total number of cookies created.		Abhishek Mishra	iOS Code Testing	https://doi.org/10.1007/978-1-4842-2689-6_2		pp 13–41		Excluded	Excluded	new_screen			2	SpringerLink		Writing Your First Set of Unit Tests with Xcode	http://link.springer.com/chapter/10.1007/978-1-4842-2689-6_2	Apress, Berkeley, CA	nan; Keywords; References; Year; Bibtex
